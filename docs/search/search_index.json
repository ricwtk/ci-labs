{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"CSC3034 Computational Intelligence <p>This site hosts the lab sheets for the module of CSC3034 Computational Intelligence in the Department of Computing and Information Systems (DCIS) in Sunway University.</p>"},{"location":"#aim","title":"Aim","text":"<p>The aim of these labs is to guide the students to implement the basic computational intelligence (CI) algorithms with and/or without Python libraries.</p>"},{"location":"#information","title":"Information","text":"<p>The labs are designed to follow the schedule of the lectures, therefore you will require the knowledge of the previous lectures to be able to conduct the lab.</p>"},{"location":"#schedule","title":"Schedule","text":"<p>The schedule is subject to change.</p> Week 2 Lab 1 Week 4 Lab 2 Week 6 Lab 3 Week 7 Lab 4 Week 8 Lab 5 Week 9 Lab 6 Week 10 Lab 7 Week 12 Lab 8"},{"location":"lab1/","title":"Lab 1: Refresh on Python","text":""},{"location":"lab1/#amoeba-community","title":"Amoeba community","text":"<ol> <li> <p>Assuming a new amoeba takes one month to grow, and from the second month onwards, it takes one month to duplicate itself to create a new amoeba. Given that there is one new amoeba at the beginning of the first month, this is the progression of the number of amoeba in different months.</p> <ul> <li><code>Month 0</code>: 1 (new)</li> <li><code>Month 1</code>: 1 (grown)</li> <li><code>Month 2</code>: 1 (grown) + 1 (new) = 2</li> <li><code>Month 3</code>: 2 (grown) + 1 (new) = 3</li> <li><code>Month 4</code>: 3 (grown) + 2 (new) = 5</li> <li><code>Month 5</code>: 5 (grown) + 3 (new) = 8</li> <li><code>Month 6</code>: 8 (grown) + 5 (new) = 13</li> <li><code>Month 7</code>: 13 (grown) + 8 (new) = 21</li> <li>...</li> </ul> <p>Hint</p> <p>Note the pattern of the sequence</p> </li> <li> <p>Write a function that takes the month number as input argument and provides the number of amoeba at the beginning of that month as output.</p> <pre><code>def numberofamoeba(month):\n  ...\n  return number_of_amoeba\n</code></pre> </li> <li> <p>Write a function to take the same input argument as <code>numberofamoeba</code> but instead of giving the number of amoeba at that month as output, provide the whole sequence of amoeba number starting from the beginning. For example, if <code>month</code> is <code>4</code>, the output of the function should be the list of <code>[1,1,2,3,5]</code></p> <pre><code>def numberofamoebaseq(month):\n  ...\n  return number_seq\n</code></pre> </li> <li> <p>Create a scatter plot to plot the sequence of amoeba number from month 0 to month 100.</p> <p>Hint</p> <p><code>import matplotlib.pyplot as plt</code> to use the Python visualisation library Matplotlib. Scatter plot can be produced with <code>plt.scatter(...)</code>.</p> </li> </ol>"},{"location":"lab1/#fibonacci-and-golden-ratio","title":"Fibonacci and Golden Ratio","text":"<ol> <li> <p>The above sequence of number is also known as the Fibonacci sequence.</p> <p>Note</p> <p>A Fibonacci sequence may or may not include a 0 as the first element of the series, i.e. <code>0,1,1,2,3,5,8,...</code> instead of <code>1,1,2,3,5,8</code>.</p> </li> <li> <p>Plot the ratio between every two consecutive numbers in the Fibonacci sequence. For Fibonacci sequence of <code>1,1,2,3,5,8,13,21</code>, plot the line of \\(\\frac{1}{1}\\), \\(\\frac{2}{1}\\), \\(\\frac{3}{2}\\), \\(\\frac{5}{3}\\), \\(\\frac{8}{5}\\), \\(\\frac{13}{8}\\), \\(\\frac{21}{13}\\).</p> <p>Note</p> <p>The longer the Fibonacci sequence you use, the closer is the value of the ratio between two consecutive numbers to be the golden ratio.</p> </li> <li> <p>Generate a series of coordinates following the algorithm:</p> <ol> <li>Start from <code>(0,0)</code>.</li> <li>Get the next Fibonacci number, i.e. <code>1</code>.</li> <li>Add <code>(+1,+1)</code> to the previous point <code>(0,0)</code> to get <code>(1,1)</code>.</li> <li>Get the next Fibonacci number, i.e. <code>1</code>.</li> <li>Add <code>(+1,-1)</code> to the previous point <code>(1,1)</code> to get <code>(2,0)</code>.</li> <li>Get the next Fibonacci number, i.e. <code>2</code>.</li> <li>Add <code>(-2,-2)</code> to the previous point <code>(2,0)</code> to get <code>(0,-2)</code>.</li> <li>Get the next Fibonacci number, i.e. <code>3</code>.</li> <li>Add <code>(-3,+3)</code> to the previous point <code>(0,-2)</code> to get <code>(-3,1)</code>.</li> <li>Continue with the next Fibonacci number and update the coordinates with the sequence of the signs <code>(+,+), (+,-), (-,-), (-,+)</code>.</li> </ol> <p>The process will create a spiral in the following manner. The sequence of the signs produce the change in directions, and the fibonacci number provides the distance.  (0,0) (1,1) (2,0) (0,-2) (-3,1) </p> </li> <li> <p>Create a line plot of the series of coordinates. If the lines are smoothen, it would form the golden spiral which can be found in pinecorns, seashells, and hurricanes.</p> <p>Additional</p> <p>If you are interested in how we may plot arc to connect the points instead of using straight lines, you can refer to Additional: plot arc to form golden spiral.</p> </li> </ol>"},{"location":"lab1/#random-selection-based-on-probability","title":"Random selection based on probability","text":"<p>For this section. assume the <code>random.random()</code> function selects the random number with even probability.</p> <ol> <li> <p>Consider a coin tossing event. If the probabilities of getting a head or a tail are even, i.e. 50%. Create a Python function which will simulate the coin tossing event and return the result as <code>head</code> or <code>tail</code>.</p> <pre><code>def tossCoin():\n  ...\n  return headOrTail\n</code></pre> </li> <li> <p>If the probabilities of getting a head or a tail are not even, with head as 20% and tail as 80%, how would you change the Python function you created previously to adapt to this coin?</p> </li> <li> <p>Consider the event of selecting one option out of three options randomly. The probability of choosing option <code>A</code> is 20%, <code>B</code> is 50%, and  <code>C</code> is 30%. Create a Python function to simulate the random selection of the options.</p> <pre><code>def chooseFromThree():\n  ...\n  return selectedOption\n</code></pre> </li> </ol>"},{"location":"lab1/#additional-plot-arc-to-form-golden-spiral","title":"Additional: plot arc to form golden spiral","text":"<ol> <li> <p>The golden spiral can be produced by drawing the arc connecting every consecutive coordinates.      (0,0) (1,1) (2,0) (0,-2) (-3,1) (1,0) (1,0) </p> </li> <li> <p>To draw the arc using <code>matplotlib</code> library, we need to identify the center of each arc. The arc and its corresponding center are colored with the same color in the previous figure.      <pre><code>matplotlib.patches.Arc(\n    xy, # center of the arc\n    width, # length of horizontal axis, \n    height, # length of vertical axis, \n    angle, # rotation of the ellipse in degrees (counterclockwise)\n    theta1, # starting angle of the arc in degrees\n    theta2 # end angle of the arc in degrees\n)\n</code></pre></p> </li> <li> <p>The centers of every arc can be generated from the sequence of coordinates using the following function:     function generatecenters<pre><code>def generatecenters(coordinates):\n    centers = []\n    for i, coord in enumerate(coordinates):\n        if i == 0: # add coordinate to list of center\n        centers.append([coord[0], coord[1]])\n        elif i == 1: # change x-coordinate of the first center\n        centers[-1][0] = coord[0]\n        else:\n        centers.append([centers[-1][0], centers[-1][1]])\n        if i % 2 == 0: # use y-coordinate as y for new center\n            centers[-1][1] = coord[1]\n        else: # use x-coordinate as x for new center\n            centers[-1][0] = coord[0]\n    return centers\n</code></pre>     The <code>coordinates</code> is the list of coordinates generated from Fibonacci and Golden Ratio step 3.</p> </li> <li> <p>The following function will then use the generated centers of the arc, and the Fibonacci sequence generated from <code>numberofamoebaseq</code> to draw the arc. The handler of the axis needs to be passed into the function as well.     function plotspiral<pre><code>def plotspiral(axis, series, centers):\n    angle = 90\n    for number,center in zip(series,centers):\n        arc = Arc(\n            xy=center, \n            width=2*number, \n            height=2*number, \n            angle=angle,\n            theta1=0, \n            theta2=90\n        )\n        axis.add_patch(arc)\n        angle -= 90\n</code></pre></p> <p>In your script, you will first generate the Fibonacci sequence, use the sequence to generate coordinates, generate centers of arcs, and plot the arcs to form the spiral.</p> <pre><code>n = 80\nnumber_seq = numberofamoebaseq(n)\ncoordinates = generatecoordinatesfromseries(number_seq)\ncenters = generatecenters(coordinates)\nplt.figure()\nplt.scatter(...) # or plt.plot(...) to plot the coordinates as in Fibonacci and Golden Ratio step 4\nplotspiral(plt.gca(), number_seq, centers) # plt.gca() returns handle of the current axis\n</code></pre> <p>Limitation</p> <p>Due to the limitation of matplotlib, the spiral plotting only works for the Fibonacci sequence with length less than 93.</p> </li> </ol>"},{"location":"lab2/","title":"Lab 2: Fuzzy Systems","text":""},{"location":"lab2/#fuzzy-systems","title":"Fuzzy Systems","text":""},{"location":"lab2/#objective","title":"Objective","text":"<ul> <li>to construct a Mamdani fuzzy system using the <code>scikit-fuzzy</code> Python library</li> <li>to evaluate the result of the constructed fuzzy system</li> </ul>"},{"location":"lab2/#note","title":"Note","text":"<p>Install the <code>scikit-fuzzy</code> Python library in your environment before proceeding with the lab.</p> <pre><code>conda install -c conda-forge scikit-fuzzy\n</code></pre>"},{"location":"lab2/#fuzzy-control-system-for-a-train","title":"Fuzzy control system for a train","text":"<ol> <li> <p>Consider a fuzzy control system to control the brake and throttle of a train based on the speed of the train and the distance of the train to the next stop.</p> </li> <li> <p>Import the <code>skfuzzy</code>, <code>skfuzzy.control</code>, and <code>numpy</code>.</p> <pre><code>import numpy as np\nfrom skfuzzy import control as ctrl\nfrom skfuzzy import membership as mf\n</code></pre> </li> </ol>"},{"location":"lab2/#initialise-inputs-and-outputs","title":"Initialise inputs and outputs","text":"<ol> <li> <p>Speed and distance are the inputs of the system whereas brake and throttle are the outputs.</p> </li> <li> <p>The ranges for the variables are:</p> Variable Range Speed 0 - 85 km/h Distance 0 - 3000 m Brake 0 - 100% Throttle 0 - 100% </li> <li> <p>As the inputs will be the antecedents of the rules, construct the variables <code>speed</code> and <code>distance</code> as <code>skfuzzy.control.Antecedent</code> objects. </p> <pre><code>speed = ctrl.Antecedent(np.arange(0, 85, 0.1), 'speed')\n</code></pre> </li> <li> <p>The initialisation function for <code>skfuzzy.control.Antecedent</code> object takes 2 arguments, the first is the universe of the variable, i.e. the values the variables can take, the second is the label of the variable. The initialisation function for <code>skfuzzy.control.Consequent</code> is similar. </p> </li> <li> <p>The label and the range of the variable can be accessed using <code>.label</code> and <code>.universe</code> respectively.</p> </li> </ol> <p>Task: Initialise the variables <code>distance</code> as <code>Antecedent</code> object, and <code>brake</code> and <code>throttle</code> as <code>Consequent</code> objects. (Outputs of the system will be consequents of the rules)</p>"},{"location":"lab2/#define-membership-functions-for-fuzzy-sets-of-variables","title":"Define membership functions for fuzzy sets of variables","text":"<ol> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>speed (0 to 85 km/h)</p> Linguistic value Fit vector Stopped (1/0, 0/2) Very slow (0/1, 1/2.5, 0/4) Slow (0/2.5, 1/6.5, 0/10.5) Medium fast (0/6.5, 1/26.5, 0/46.5) Fast (0/26.5, 1/70, 1/85) </li> <li> <p>distance (0 to 3000 m)</p> Linguistic value Fit vector At (1/0, 0/2) Very near (0/1, 1/3, 0/5) Near (0/3, 1/101.5, 0/200) Medium far (0/100, 1/1550, 0/3000) Far (0/1500, 1/2250, 1/3000) </li> <li> <p>brake (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/40) Very slight (0/20, 1/50, 0/80) Slight (0/70, 1/83.5, 0/97) Medium (0/95, 1/97, 0/99) Full (0/98, 1/100) </li> <li> <p>throttle (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/2) Very slight (0/1, 1/3, 0/5) Slight (0/3, 1/16.5, 0/30) Medium (0/20, 1/50, 0/80) Full (0/60, 1/80, 1/100) </li> </ul> </li> <li> <p>The <code>skfuzzy.membership</code> module provides the following membership functions:</p> Membership function Description <code>skfuzzy.membership.dsigmf(x, b1, c1, b2, c2)</code> Difference of two fuzzy sigmoid membership functions <code>skfuzzy.membership.gauss2mf(x, mean1, ...)</code> Gaussian fuzzy membership function of two combined Gaussians <code>skfuzzy.membership.gaussmf(x, mean, sigma)</code> Gaussian fuzzy membership function <code>skfuzzy.membership.gbellmf(x, a, b, c)</code> Generalized Bell function fuzzy membership generator <code>skfuzzy.membership.piecemf(x, abc)</code> Piecewise linear membership function (particularly used in FIRE filters) <code>skfuzzy.membership.pimf(x, a, b, c, d)</code> Pi-function fuzzy membership generator <code>skfuzzy.membership.psigmf(x, b1, c1, b2, c2)</code> Product of two sigmoid membership functions <code>skfuzzy.membership.sigmf(x, b, c)</code> The basic sigmoid membership function generator <code>skfuzzy.membership.smf(x, a, b)</code> S-function fuzzy membership generator <code>skfuzzy.membership.trapmf(x, abcd)</code> Trapezoidal membership function generator <code>skfuzzy.membership.trimf(x, abc)</code> Triangular membership function generator <code>skfuzzy.membership.zmf(x, a, b)</code> Z-function fuzzy membership generator </li> <li> <p>The fit vector of a linguitic value can be assigned to a linguistic variable using</p> <pre><code>speed['stopped'] = mf.trimf(speed.universe, [0, 0, 2])\nspeed['very slow'] = mf.trimf(speed.universe, [1, 2.5, 4])\n</code></pre> <p>Task: Assign all fuzzy sets to the linguistic variables.</p> </li> <li> <p>The fuzzy set diagram of a linguistic variable can be viewed using <code>.view()</code></p> <pre><code>speed.view()\n</code></pre> <p>Task: Check if the fuzzy set diagrams match the fit vectors.</p> </li> </ol>"},{"location":"lab2/#define-rules","title":"Define rules","text":"<ol> <li> <p>The rules for this system are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Distance At Very near Near Medium far Far Speed Stopped Full brakeNo throttle Full brakeVery slight throttle Very slow Full brakeNo throttle Medium brakeVery slight throttle Slight brakeVery slight throttle Slow Full brakeNo throttle Medium brakeVery slight throttle Very slight brakeSlight throttle Medium fast Very slight brakeMedium throttle No brakeFull throttle Fast Very slight brakeMedium throttle No brakeFull throttle </p> </li> <li> <p>Rule can be defined using <code>skfuzzy.control.Rule(antecedent, consequent, label)</code>. To define the first rule, i.e. if distance is 'at' and speed is 'stopped', then full brake and no throttle, </p> <pre><code>rule1 = ctrl.Rule(distance['at'] &amp; speed['stopped'], (brake['full'], throttle['no']))\n</code></pre> <p>If the antecedent consists of multiple parts, they can be combined using operators <code>|</code> (OR), <code>&amp;</code> (AND), and <code>~</code> (NOT).</p> <p>If the consequent consists of multiple parts, they can be combined as a <code>list</code>/<code>tuple</code>.</p> <p>Task: Define all the rules. Then combine all the rules in a <code>list</code>, i.e. <code>rules = [rule1, rule2, ...]</code>.</p> </li> </ol>"},{"location":"lab2/#construct-the-fuzzy-control-system","title":"Construct the fuzzy control system","text":"<ol> <li> <p>The train control system can be constructed with</p> <pre><code>train_ctrl = ctrl.ControlSystem(rules=rules)\n</code></pre> </li> <li> <p>A <code>skfuzzy.control.ControlSystemSimulation</code> object is needed to simulate the control system to obtain the outputs given certain inputs.</p> <pre><code>train = ctrl.ControlSystemSimulation(control_system=train_ctrl)\n</code></pre> </li> <li> <p>To obtain the values for <code>brake</code> and <code>throttle</code> given that <code>speed</code> is 30 km/h and <code>distance</code> is 6 m,</p> <pre><code># define the values for the inputs\ntrain.input['speed'] = 30\ntrain.input['distance'] = 2000\n\n# compute the outputs\ntrain.compute()\n\n# print the output values\nprint(train.output)\n\n# to extract one of the outputs\nprint(train.output['brake'])\n</code></pre> </li> <li> <p>To view the results in the graph,</p> <pre><code>brake.view(sim=train)\nthrottle.view(sim=train)\n</code></pre> </li> </ol>"},{"location":"lab2/#view-the-controloutput-space","title":"View the control/output space","text":"<ol> <li> <p>The control/output space allows us to identify if the outputs fit our expectation.</p> </li> <li> <p>Construct an empty 3D space with 100-by-100 x-y grid.</p> <pre><code>x, y = np.meshgrid(np.linspace(speed.universe.min(), speed.universe.max(), 100),\n                   np.linspace(distance.universe.min(), distance.universe.max(), 100))\nz_brake = np.zeros_like(x, dtype=float)\nz_throttle = np.zeros_like(x, dtype=float)\n</code></pre> </li> <li> <p>Loop through every point and identify the value of brake and throttle of each point. As the specified rules are not exhaustive, i.e. some input combinations do not activate any rule, we will set the output of such input combinations to be <code>float('inf')</code>.     <pre><code>for i,r in enumerate(x):\n  for j,c in enumerate(r):\n    train.input['speed'] = x[i,j]\n    train.input['distance'] = y[i,j]\n    try:\n      train.compute()\n    except:\n      z_brake[i,j] = float('inf')\n      z_throttle[i,j] = float('inf')\n    z_brake[i,j] = train.output['brake']\n    z_throttle[i,j] = train.output['throttle']\n</code></pre></p> </li> <li> <p>Plot the result in a 3D graph using the <code>matplotlib.pyplot</code> library.</p> <pre><code>import matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndef plot3d(x,y,z):\n  fig = plt.figure()\n  ax = fig.add_subplot(111, projection='3d')\n\n  ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap='viridis', linewidth=0.4, antialiased=True)\n\n  ax.contourf(x, y, z, zdir='z', offset=-2.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='x', offset=x.max()*1.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='y', offset=y.max()*1.5, cmap='viridis', alpha=0.5)\n\n  ax.view_init(30, 200)\n\nplot3d(x, y, z_brake)\nplot3d(x, y, z_throttle)\n</code></pre> </li> </ol>"},{"location":"lab2/#fuzzy-tipping-recommendation-system","title":"Fuzzy tipping recommendation system","text":"<ol> <li> <p>A fuzzy expert system is designed to identify the percentage of tips a customer will give based on the service and the food the customer received.</p> </li> <li> <p>The system has service and food as inputs, and tips as output.</p> </li> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>service (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>food (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>tips (0 to 30%)</p> Linguistic value Fit vector Low (1/0, 0/15) Medium (0/0, 1/15, 0/30) High (0/15, 1/30) </li> </ul> </li> <li> <p>The rules are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Food Poor Average Good Service Poor low tips low tips medium tips Average low tips medium tips high tips Good medium tips high tips high tips </p> </li> </ol> <p>Task: Construct the fuzzy inference system.</p> <p>Task: Modify the membership functions of the input 'service' to</p> Linguistic value Fit vector Poor (1/0, 0/3) Average (0/2, 1/5, 0/8) Good (0/6, 1/10)"},{"location":"lab3/","title":"Lab 3: EC (GA)","text":""},{"location":"lab3/#genetic-algorithm","title":"Genetic algorithm","text":"<p>Consider the following problem: </p> <p>Problem</p> <p>You are given a sheet of paper with width <code>w</code> and height <code>h</code>. Your task is to cut the paper into squares of equal size. The aim of the task is to have as many squares as possible, and to have the area of each square as large as possible.</p> <ol> <li> <p>An optimisation problem can always be phrased in the form of</p> <p>to optimise ... such that it maximises/minimises ...</p> <p>In this problem, what is the parameter to be optimised and what are the parameters to be maximised or minimised?</p> </li> <li> <p>Let <code>x</code> denotes the length of the sides of a square. Design a fitness function such that higher fitness corresponds to larger number of squares and large area. If the number of squares (that can be cut out) is zero, or the area of the square is zero, the fitness will be zero.</p> </li> </ol> feature encoding population initialisation selection as parents crossover mutation offspring (next generation population) repeat from fitnexx calculation until termination"},{"location":"lab3/#feature-encoding","title":"Feature encoding","text":"<ol> <li> <p>In this problem as we only have one feature, i.e. the side length of the square, each chromosome consists of the value of the side length of the square. We will encode the chromosome in the form of binary code. </p> </li> <li> <p>Create two functions <code>value2binary</code> and <code>binary2value</code> to convert a decimal value to its binary code and vice versa.</p> <pre><code>def value2binary(value):\n  # this function converts a decimal value to its binary code representation\n  ...\n  return binary\n\ndef binary2value(binary):\n  # this function converts a binary code representation to its decimal value\n  ...\n  return value\n</code></pre> </li> <li> <p>Add the following code snippet to the end of the code to test your functions.</p> <pre><code>if __name__ == \"__main__\":\n  print(value2binary(10))\n  print(binary2value(\"1001\"))\n</code></pre> <p>After running the file as a script, you should see the following output.</p> <pre><code>1010\n9\n</code></pre> </li> </ol>"},{"location":"lab3/#population-initialisation","title":"Population initialisation","text":"<ol> <li> <p>A population is randomly generated according to the defined population size. </p> </li> <li> <p>Create a function to generate randomly a population of size <code>pop_size</code> with each value lies between the range of <code>pop_min</code> to <code>pop_max</code>.</p> <pre><code>def generatePopulation(pop_size, pop_min, pop_max):\n  # this function generate the first generation randomly based on the population size and the range of the value of each chromosome\n  ...\n  return population\n</code></pre> <p>This function and all the functions created after this should be placed before the <code>if __name__ == \"__main__\":</code> code block.</p> </li> <li> <p>[Optional testing] You can test the function by changing the <code>__main__</code> code block to </p> <pre><code>if __name__ == \"__main__\":\n  print(generatePopulation(8, 0, 10))\n</code></pre> <p>The printed output should be a series of 8 chromosomes displayed as decimal values.</p> </li> </ol>"},{"location":"lab3/#fitness-calculation","title":"Fitness calculation","text":"<ol> <li> <p>The fitness function was designed at the beginning of this section. Define a function that takes the input of a chromosome (as decimal value) and returns the fitness of the chromosome.</p> <p><pre><code>def calculateFitness(value):\n  # this function calculates the fitness of a chromosome from the decimal value of the chromosome\n  ...\n  return fitness\n</code></pre> 2. [Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(calculateFitness(5))\n</code></pre> <p>The printed output should be the fitness of a chromosome of value 5, which would be a decimal value larger than zero.</p> </li> </ol>"},{"location":"lab3/#selection-as-parents","title":"Selection as parents","text":"<ol> <li> <p>From the list of the chromosomes, we will select the chromosome pairs as parents. As we will be using one-point crossover, each pair of parents will produce exactly two offsprings. Therefore for population size of <code>pop_size</code>, we need <code>pop_size/2</code> pairs of parents.</p> </li> <li> <p>Define a function that takes the inputs of the current population and the total number of chromosomes in current population, and returns the chromosome pairs which will act as parents. The selection process is performed with the roulette wheel selection. The same chromosome can be selected more than once.</p> <pre><code>def selectParents(chromosomes, pop_size):\n  ...\n  return parent_pairs\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(selectParents([13, 8, 14, 7], 6))\n</code></pre> <p>The printed output should be 3 parent pairs, for example, </p> <pre><code>[[13, 8], [8, 14], [13, 7]]\n</code></pre> </li> </ol>"},{"location":"lab3/#crossover","title":"Crossover","text":"<ol> <li> <p>Define a function that takes a parent pair and returns a pair of offspring after performing one-point crossover.</p> <pre><code>def crossover(parents):\n  # this function takes a parent pair and perform one-point crossover to produce a pair of offspring\n  ...\n  return offsprings\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(crossover([11, 13]))\n</code></pre> <p>The printed output should be a pair of offsprings, for example,</p> <pre><code>[15, 9]\n</code></pre> </li> </ol> <pre><code>*`11` is `1011` and `13` is `1101` in binary code, the offsprings `15` is `1111` and `9` is `1001` in binary code.*\n</code></pre>"},{"location":"lab3/#mutation","title":"Mutation","text":"<ol> <li> <p>Each gene in all chromosomes has the same mutation probability <code>p_mutation</code>. </p> </li> <li> <p>Define a function that takes a chromosome and the mutation probability <code>p_mutation</code> as the inputs, and returns the mutated chromosome. </p> <p><pre><code>def mutate(chromosome, p_mutation):\n  # this function mutates each gene of a chromosome based on the mutation probability\n  ...\n  return mutated\n</code></pre> 3. [Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(mutate(15, 0.1))\n</code></pre> <p>The printed output should be the mutated or unmutated chromosome, for example, <code>9</code>.</p> </li> </ol> <pre><code>*`8` is `1000` and `9` is `1001` in binary code. In the example output, the last bit is mutated.*\n</code></pre>"},{"location":"lab3/#repeat-until-termination","title":"Repeat until termination","text":"<ol> <li> <p>The common termination criteria are the maximum number of iterations and the distance among the fitnesses of the chromosomes of the latest population.</p> </li> <li> <p>Define a function that calculates one metric to measure the distance among the fitnesses of the chromosomes, i.e. how far the fitnesses of all the chromosomes are from each other.</p> <pre><code>def findOverallDistance(chromosomes):\n  # this function takes the input of the current population and returns the overall distance among fitnesses of all chromosomes\n  ...\n  return overall_distance\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(findOverallDistance([13, 11, 14, 7]))\n</code></pre> <p>The printed output should be a decimal value that represents the overall distance of fitnesses.</p> </li> </ol>"},{"location":"lab3/#combining-all-functions","title":"Combining all functions","text":"<ol> <li> <p>The functions we have created can be combined with the following code snippet to execute the genetic algorithm to solve the problem defined at the beginning of this section. Consider the width and the height of the sheet of paper to be <code>20cm</code> and <code>15cm</code>.</p> <pre><code>if __name__ == \"__main__\":\n  # main function\n  ## parameter definition\n  pop_size = 10\n  pop_min = 1 #1cm\n  pop_max = 10 #10cm\n  curr_iter = 0\n  max_iter = 100\n  min_overalldistance = 0.5\n  p_mutation = 0.05\n  ## initialise population\n  population = []\n  population.append(generatePopulation(pop_size, pop_min, pop_max))\n  while (curr_iter &lt; max_iter and findOverallDistance(population[-1]) &gt; min_overalldistance):\n    curr_iter += 1\n    ## select parent pairs\n    parents = selectParents(population[-1], len(population[-1]))\n    ## perform crossover\n    offsprings = []\n    for p in parents:\n      new_offsprings = crossover(p)\n      for o in new_offsprings:\n        offsprings.append(o)\n    ## perform mutation\n    mutated = [mutate(offspring, p_mutation) for offspring in offsprings]\n    ## update current population\n    population.append(mutated)\n</code></pre> </li> </ol>"},{"location":"lab4/","title":"Lab 4: EC (PSO)","text":""},{"location":"lab4/#particle-swarm-optimisation","title":"Particle swarm optimisation","text":""},{"location":"lab4/#objective","title":"Objective","text":"<ul> <li>develop a Python function to perform global best particle swarm optimisation</li> </ul>"},{"location":"lab4/#setup-for-spyder","title":"Setup for Spyder","text":"<ol> <li> <p>If you are using Spyder for this lab, go to Tools &gt; Preferences &gt; IPython console &gt; Graphics and set Backend to Automatic.</p> </li> <li> <p>Restart kernel by going to Consoles &gt; Restart kernel.</p> </li> </ol>"},{"location":"lab4/#problem-to-solve","title":"Problem to solve","text":"<p>Solve the following problem using global best particle swarm optimisation:</p> <p>Problem</p> <p>Find the value of x to minimise the function \\(f(x) = (x+100)(x+50)(x)(x-20)(x-60)(x-100)\\) for \\(-100 &lt; x &lt; 100\\)</p>"},{"location":"lab4/#particle-swarm-optimisation_1","title":"Particle swarm optimisation","text":"particles initialisation personal best identification global best identification velocity calculation position update repeat from personal best identification until termination"},{"location":"lab4/#parameter-definition","title":"Parameter definition","text":"<ol> <li> <p>With global best particle swarm optimisaton, the position update function is given by</p> \\[x_i(t+1) = x_i(t) + v_i(t+1)\\] <p>and the velocity update function is</p> \\[v_i(t+1) = v_i(t) + \\alpha_1\\beta_1(t) \\Big( p_i(t) - x_i(t) \\Big) + \\alpha_2\\beta_2(t)\\Big(p_g(t) - x_i(t)\\Big)\\] </li> <li> <p>\u03b1<sub>1</sub> and \u03b1<sub>2</sub> are acceleration constants that are fixed throughout the algorithm. Define a small value for \u03b1<sub>1</sub> and \u03b1<sub>2</sub>, for example <code>0.1</code>.</p> <pre><code>alpha = [0.1, 0.1]\n</code></pre> </li> <li> <p>\u03b2<sub>1</sub>(t) and \u03b2<sub>2</sub>(t) are random values between <code>0</code> and <code>1</code> that are regenerated every iteration. Therefore no definition is required.</p> </li> <li> <p>Also, define the number of particles to run the algorithm with.</p> <pre><code>n_particle = 10\n</code></pre> </li> <li> <p>Place the definition of these variables in the <code>__main__</code> block.</p> <pre><code>if __name__ == '__main__':\n  alpha = [0.1, 0.1]\n  n_particle = 10\n</code></pre> </li> </ol>"},{"location":"lab4/#create-a-class-for-particle","title":"Create a class for particle","text":"<ol> <li> <p>As each particle is an individual, create a <code>Particle</code> class to hold the data of the particle's current position, velocity, and personal best position.</p> <pre><code>class Particle:\n  def __init__(self, position = 0, velocity = 0):\n    self.position = position\n    self.velocity = velocity\n    self.best_position = position\n</code></pre> </li> </ol>"},{"location":"lab4/#fitness-function","title":"Fitness function","text":"<ol> <li> <p>Fitness function is how we can compare different particles.</p> </li> <li> <p>As our goal is to minimise f(x) as stated in the beginning, we will use f(x) as our fitness function.</p> </li> <li> <p>By using f(x) in minimisation problem, it implies that the lower the value of f(x), the better the particle it is.</p> </li> <li> <p>The value of x is the position of the particle.</p> </li> <li> <p>Define the fitness function as a Python function.</p> <pre><code>def fit_fcn(position):\n  ...\n  return fitness\n</code></pre> </li> </ol>"},{"location":"lab4/#initialise-particles","title":"Initialise particles","text":"<ol> <li> <p>Particles are initialised with random positions within the constraints. </p> </li> <li> <p>At initialisation, we may assume that the initial velocities of all the particles. It is possible to initialise particles with non-zero velocities. For now, we will stick to zero initial velocities.</p> </li> <li> <p>Define a Python function that takes the input of the number of particles and the limits of the positions to initialise and return a list of objects of class <code>Particle</code>. Each particle has random position within the limits and zero velocity.</p> <pre><code>def initialise_particles(n_ptc, position_limits):\n  # position_limits is a list of two values. The first value is the lower boundary and the second value is the upper boundary.\n  ...\n  return particles\n</code></pre> </li> <li> <p>Remember to test your function before proceed.</p> </li> </ol>"},{"location":"lab4/#update-personal-best","title":"Update personal best","text":"<ol> <li> <p>Create a method in the class <code>Particle</code> to update the <code>best_position</code> if necessary.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(self):\n    # 1. calculate the fitnesses of the best_position and the particle's current position\n    # 2. compare the fitnesses and determine if the current position is better than the best_position\n    # 3. update if necessary\n    # 4. no return statement is required\n</code></pre> </li> <li> <p>If the new position has a lower fitness, i.e. the new position is better than the best position, update the <code>best_position</code> to hold the value of the new position.</p> </li> </ol>"},{"location":"lab4/#update-global-best","title":"Update global best","text":"<ol> <li> <p>Initiate a variable named <code>global_best_position</code> with the value <code>None</code> in the <code>__main__</code> block. </p> </li> <li> <p>Create a function that takes two positions as inputs, compare them, and return the better position of the two.</p> <pre><code>def compareFitness(pos1, pos2):\n  # 1. calculate the fitness of pos1 and pos2\n  # 2. compare to determine the better position\n  return betterpos\n</code></pre> </li> <li> <p>We will later use this function to compare the current global best position with the personal best position of each particle.</p> </li> </ol>"},{"location":"lab4/#update-velocity","title":"Update velocity","text":"<ol> <li> <p>Create a method in the class <code>Particle</code> to update the velocity given \u03b1<sub>1</sub>, \u03b1<sub>2</sub>, \u03b2<sub>1</sub>, \u03b2<sub>2</sub>, and the global best position.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(...):\n    ...\n\n  def update_velocity(self, alpha, beta, glob_best_pos):\n    # alpha is a list of two values. we will access alpha_1 and alpha_2 by alpha[0] and alpha[1] respectively. This also applies to beta.\n    # the current position, current velocity, and personal best position of the particle can be accessed by self.position, self.velocity, and self.best_position\n    # assign the particle's velocity with the updated velocity\n</code></pre> </li> </ol>"},{"location":"lab4/#update-particle-position","title":"Update particle position","text":"<ol> <li> <p>As updating a particle position only require information from within the particle object and the limits of the position, create a method called <code>update_position</code> in the class <code>Particle</code> taking the input of the limits of the position.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(...):\n    ...\n\n  def update_velocity(...):\n    ...\n\n  def update_position(self, position_limits):\n    self.position = self.position + self.velocity\n    # how should you solve the problem of the position (x) going out of the limits\n</code></pre> </li> </ol>"},{"location":"lab4/#create-a-loop-until-termination","title":"Create a loop (until termination)","text":"<ol> <li> <p>Consider the following termination criteria:</p> <ul> <li>exceeding 200 iterations</li> <li>fitnesses of all particles are close</li> <li>positions of all particles are close</li> </ul> </li> <li> <p>Create a function to calculate the average difference between the mean fitness and the fitness of each particle.</p> <pre><code>def calc_avg_fit_diff(particles):\n  # 1. calculate mean fitness of all particles\n  # 2. calculate the difference between the mean fitness and the fitness of each particle\n  # 3. calculate the average of the differences obtained from step 2\n  return avg_fit_diff\n</code></pre> </li> <li> <p>Create a function to calculate the average difference between the mean position and the position of each particle.</p> <pre><code>def calc_avg_pos_diff(particles):\n  # 1. calculate mean position of all particles\n  # 2. calculate the difference between the mean position and the position of each particle\n  # 3. calculate the average of the differences obtained from step 2\n  return avg_pos_diff\n</code></pre> </li> <li> <p>Create a loop (in the <code>__main__</code> block) to execute the global best particle swarm optimisation (gbest PSO) until termination. </p> <pre><code>if __name__ == '__main__':\n  # parameter initialisation\n  alpha = [0.1, 0.1]\n  n_particle = 10\n  global_best_position = None\n  position_limits = [-100, 100]\n  # termination threshold\n  iteration = 0\n  max_iter = 200\n  min_avg_fit_diff = 0.1\n  min_avg_pos_diff = 0.1\n  # initialise particles\n  particles = initialise_particles(n_particle, position_limits)\n  while (...): # how should you define the termination criteria here?\n    print(iteration, [round(x.position,2) for x in particles])\n    for particle in particles:\n      # update personal best\n      particle.update_personal_best()\n      # update global best\n      if global_best_position == None:\n        global_best_position = particle.position\n      else:\n        global_best_position = compareFitness(global_best_position, particle.position)\n    # generate beta randomly for current iteration\n    beta = [random.random(), random.random()]\n    for particle in particles:\n      # update velocity\n      particle.update_velocity(alpha, beta, global_best_position)\n      # update position\n      particle.update_position(position_limits)\n    iteration += 1\n  # display results\n  print(iteration, [round(x.position,2) for x in particles])\n</code></pre> </li> </ol>"},{"location":"lab4/#visualisation","title":"Visualisation","text":"<ol> <li> <p>Let's add a few lines to visualise particles \"flying\" towards to optimal position.</p> <ul> <li> <p>import the visualisation library   <pre><code>import matplotlib.pyplot as plt\n</code></pre></p> </li> <li> <p>add the following lines just before the <code>while</code> loop in the last code block in the previous section.   <pre><code>space_ax = plt.axes()\nspace_ax.plot(list(range(*position_limits)),[fit_fcn(x) for x in range(*position_limits)])\nspace_ax.set_title(\"Position of particles in iteration {}\".format(iteration))\nspace_ax.set_xlabel(\"Position\")\nspace_ax.set_ylabel(\"Fitness\")\n</code></pre></p> </li> <li> <p>add the following lines between line 14 and line 15 in the last code block in the previous section, as well as after line 33.   <pre><code>if len(space_ax.lines) &gt; 1:\n  space_ax.lines[1].remove()\nspace_ax.plot([x.position for x in particles], [fit_fcn(x.position) for x in particles], 'go')\nspace_ax.set_title(\"Position of particles in iteration {}\".format(iteration))\nplt.pause(0.5) # pause the program for 0.5 second; if graph changes too quickly, increase this value; you can also speed up the process by decreasing this value\n</code></pre></p> </li> </ul> </li> </ol>"},{"location":"lab4/#evaluation","title":"Evaluation","text":"<ol> <li> <p>Store the values of the variables at each iteration for analysis and evaluation.</p> <ul> <li>position of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.position_list = [position]\n\n  def update_position(...):\n    ...\n    self.position_list.append(self.position)\n</code></pre> <ul> <li>velocity of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.velocity_list = [velocity]\n\n  def update_velocity(...):\n    ...\n    self.velocity_list.append(self.velocity)\n</code></pre> <ul> <li>personal best position of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.best_position_list = []\n\n  def update_personal_best(...):\n    ...\n    self.best_position_list.append(self.best_position)\n</code></pre> <ul> <li>global best position at each iteration</li> </ul> <pre><code>if __init__ == '__main__':\n  # parameter initialisation\n  ...\n  global_best_position_list = []\n  ...\n        global_best_position = ...\n    global_best_position_list.append(global_best_position) # take note on the indentation\n    # generate beta randomly for current iteration\n    ...\n</code></pre> </li> <li> <p>Visualise the progression of these variables by adding the following code to the end of the <code>__main__</code> block.</p> <pre><code>[pos_fig, position_axes] = plt.subplots(4,1,sharex=True)\nposition_axes[0].set_title(\"Position of each particle\")\nposition_axes[1].set_title(\"Fitness of each particle\")\nposition_axes[2].set_title(\"Boxplot of position at each iteration\")\nposition_axes[3].set_title(\"Boxplot of fitness at each iteration\")\nposition_axes[3].set_xlabel(\"Iteration\")\n[vel_fig, velocity_axes] = plt.subplots(2,1,sharex=True)\nvelocity_axes[0].set_title(\"Velocity of each particle\")\nvelocity_axes[1].set_title(\"Boxplot for velocity at each iteration\")\nvelocity_axes[1].set_xlabel(\"Iteration\")\n[p_best_fig, personal_best_axes] = plt.subplots(4,1,sharex=True)\npersonal_best_axes[0].set_title(\"Personal best position of each particle\")\npersonal_best_axes[1].set_title(\"Personal best fitness of each particle\")\npersonal_best_axes[2].set_title(\"Boxplot of personal best position at each iteration\")\npersonal_best_axes[3].set_title(\"Boxplot of personal best fitness at each iteration\")\npersonal_best_axes[3].set_xlabel(\"Iteration\")\n[g_best_fig, global_best_axes] = plt.subplots(2,1,sharex=True)\nglobal_best_axes[0].set_title(\"Global best position\")\nglobal_best_axes[1].set_title(\"Fitness for global best position\")\nglobal_best_axes[1].set_xlabel(\"Iteration\")\nfor particle in particles:\n  iteration_list = list(range(len(particle.position_list)))\n  position_axes[0].plot(iteration_list, particle.position_list, '-o')\n  position_axes[1].plot(iteration_list, [fit_fcn(x) for x in particle.position_list], '-o')\n\n  velocity_axes[0].plot(iteration_list, particle.velocity_list, '-o')\n\n  personal_best_axes[0].plot(iteration_list[:-1], particle.best_position_list, '-o')\n  personal_best_axes[1].plot(iteration_list[:-1], [fit_fcn(x) for x in particle.best_position_list], '-o')\n\nposition_axes[2].boxplot([[p.position_list[i] for p in particles] for i in iteration_list], positions=iteration_list)\nposition_axes[3].boxplot([[fit_fcn(p.position_list[i]) for p in particles] for i in iteration_list], positions=iteration_list)\n\nvelocity_axes[1].boxplot([[p.velocity_list[i] for p in particles] for i in iteration_list], positions=iteration_list)\n\npersonal_best_axes[2].boxplot([[p.best_position_list[i] for p in particles] for i in iteration_list[:-1]], positions=iteration_list[:-1])\npersonal_best_axes[3].boxplot([[fit_fcn(p.best_position_list[i]) for p in particles] for i in iteration_list[:-1]], positions=iteration_list[:-1])\n\nglobal_best_axes[0].plot(iteration_list[:-1], global_best_position_list, '-o')\nglobal_best_axes[1].plot(iteration_list[:-1], [fit_fcn(x) for x in global_best_position_list], '-o')\n</code></pre> </li> </ol>"},{"location":"lab4/#exercise","title":"Exercise","text":"<ol> <li> <p>Multiply the velocity memory, \\(v_i(t)\\), with a value between 0 and 1, let's say 0.5. How does the process change? This is the effect of inertia weight.</p> </li> <li> <p>Reduce the value of \\(\\alpha_1\\) to 0.05 while maintaining \\(\\alpha_2\\) at 0.1 and investigate the effect. </p> </li> <li> <p>Reduce the value of \\(\\alpha_1\\) to 0. How does this affect the result?</p> </li> <li> <p>Modify such that \\(\\alpha_1\\) is larger than \\(\\alpha_2\\). What's the effect?</p> </li> </ol>"},{"location":"lab4/#optional","title":"Optional","text":"<ol> <li>How may you modify the formulae for particles with two variables, in which the fitness function is defined as \\(f(x,y) = x^2 + y^2\\)? </li> </ol>"},{"location":"lab5/","title":"Lab 5: EC (ACO)","text":""},{"location":"lab5/#ant-colony-optimisation","title":"Ant colony optimisation","text":""},{"location":"lab5/#objective","title":"Objective","text":"<ul> <li>to develop a Python function to perform ant colony optimisation on a problem</li> </ul>"},{"location":"lab5/#problem-to-solve","title":"Problem to solve","text":"<p>We will use ant colony optimisation to solve the Nick's route-finding problem in Romania. The problem is a route finding problem to identify the best (cheapest) route to travel from Arad to Bucharest.</p> <p>The road map of Romania is provided as follows:</p> 75 71 151 140 118 111 70 75 120 146 80 99 97 138 101 211 90 85 98 86 142 92 87 Arad Zerind Oradea Sibiu Fagaras Rimnicu Vilcea Pitesti Craiova Drobeta Mehadia Lugoj Timisoara Bucharest Giurgiu Urziceni Hirsova Eforie Vaslui Iasi Neamt"},{"location":"lab5/#problem-formulation","title":"Problem formulation","text":"<ol> <li> <p>The coordinates of each town are provided as follows. This will be used later for the purpose of visualisation.</p> <pre><code>location_list = [ # [x,y,name]\n  [75, 125, 'Arad'],\n  [100, 75, 'Zerind'],\n  [125, 25, 'Oradea'],\n  [265, 175, 'Sibiu'],\n  [425, 175, 'Fagaras'],\n  [320, 230, 'Rimnicu Vilcea'],\n  [475, 310, 'Pitesti'],\n  [350, 465, 'Craiova'],\n  [185, 450, 'Drobeta'],\n  [190, 390, 'Mehadia'],\n  [185, 335, 'Lugoj'],\n  [85, 280, 'Timisoara'],\n  [640, 390, 'Bucharest'],\n  [575, 485, 'Giurgiu'],\n  [745, 340, 'Urziceni'],\n  [875, 340, 'Hirsova'],\n  [935, 440, 'Eforie'],\n  [850, 225, 'Vaslui'],\n  [760, 120, 'Iasi'],\n  [625, 60, 'Neamt']\n]\n</code></pre> </li> <li> <p>Then define the travel cost between connected cities. </p> <pre><code>step_cost = [\n  ['Arad', 'Zerind', 75],\n  ['Zerind', 'Oradea', 71],\n  ['Oradea', 'Sibiu', 151],\n  ['Sibiu', 'Arad', 140],\n  ['Sibiu', 'Fagaras', 99],\n  ['Sibiu', 'Rimnicu Vilcea', 80],\n  ['Fagaras', 'Bucharest', 211],\n  ['Bucharest', 'Giurgiu', 90],\n  ['Bucharest', 'Pitesti', 101],\n  ['Pitesti', 'Rimnicu Vilcea', 97],\n  ['Rimnicu Vilcea', 'Craiova', 146],\n  ['Craiova', 'Pitesti', 138],\n  ['Craiova', 'Drobeta', 120],\n  ['Drobeta', 'Mehadia', 75],\n  ['Mehadia', 'Lugoj', 70],\n  ['Lugoj', 'Timisoara', 111],\n  ['Arad', 'Timisoara', 118],\n  ['Bucharest', 'Urziceni', 85],\n  ['Urziceni', 'Vaslui', 142],\n  ['Vaslui', 'Iasi', 92],\n  ['Iasi', 'Neamt', 87],\n  ['Urziceni', 'Hirsova', 98],\n  ['Hirsova', 'Eforie', 86]\n]\n</code></pre> </li> <li> <p>We will define two class, <code>City</code> and <code>Road</code>.</p> </li> <li> <p>An object of class <code>City</code> has the attributes of <code>name</code> (the name of the city), <code>roads</code> (an array of references to the roads connected to the current city), and <code>coordinates</code> (coordinates of the cities).</p> <pre><code>class City:\n  def __init__(self, name):\n    self.name = name\n    self.roads = []\n    self.coordinates = []\n\n  def set_coordinates(self, coordinates):\n    self.coordinates = coordinates\n\n  def add_road(self, road):\n    if road not in self.roads:\n      self.roads.append(road)\n</code></pre> </li> <li> <p>An object of class <code>Road</code> has the attributes of <code>connected_cities</code> (an array of references to the cities connected through this road), <code>cost</code> (the step cost of this road), and <code>pheromone</code> (the pheromone on this road).</p> <pre><code>class Road:\n  def __init__(self, connected_cities, cost, pheromone=0):\n    self.connected_cities = connected_cities\n    self.cost = cost\n    self.pheromone = pheromone\n</code></pre> </li> <li> <p>We will construct the list of <code>City</code> objects and <code>Road</code> objects from the information provided by the question, i.e. information in <code>location_list</code> and <code>step_cost</code>. The following code block should be in the <code>main</code> code block.</p> <pre><code>cities = {}\nfor coord1, coord2, name in location_list:\n  cities[name] = City(name)\n  cities[name].set_coordinates([coord1, coord2])\nroads = []\nfor city1, city2, cost in step_cost:\n  road = Road([cities[city1], cities[city2]], cost)\n  cities[city1].add_road(road)\n  cities[city2].add_road(road)\n  roads.append(road)\n</code></pre> </li> <li> <p>In the <code>main</code> code block, define the <code>origin</code> and <code>destination</code> cities.</p> <pre><code>origin = cities['Arad']\ndestination = cities['Bucharest']\n</code></pre> </li> </ol>"},{"location":"lab5/#initiating-aco-algorithm","title":"Initiating ACO algorithm","text":"<ol> <li> <p>We then define the parameters for ACO, i.e. number of ants, <code>n_ant</code>, pheromone influence constant, <code>alpha</code>, and evaporation rate, <code>rho</code>.</p> <pre><code>n_ant = 10\nalpha = 1\nrho = 0.1\n</code></pre> </li> <li> <p>Add the method <code>set_pheromone</code> to the class <code>Road</code>.      <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(self, pheromone):\n    self.pheromone = pheromone\n</code></pre></p> </li> <li> <p>Set the initial pheromone of each road to 0.01.     <pre><code># in main block\ninitial_pheromone = 0.01\nfor road in roads:\n  road.set_pheromone(initial_pheromone)\n</code></pre></p> </li> <li> <p>Define the class <code>Ant</code>.      <pre><code>class Ant:\n  def __init__(self):\n    self.cities = [] # cities the ant passes through, in sequence\n    self.path = [] # roads the ant uses, in sequence\n</code></pre></p> </li> <li> <p>Initiate <code>n_ants</code> ants.     <pre><code>ants = [Ant() for _ in range(n_ant)]\n</code></pre></p> </li> </ol>"},{"location":"lab5/#identify-path-of-each-ant","title":"Identify path of each ant","text":"<ol> <li> <p>In the <code>Ant</code> class, define a method to identify the path by taking the inputs of the available roads, the origin, the destination, and the pheromone influence constant \u03b1.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(self, origin, destination, alpha):\n    # 1. append origin to the self.cities\n    # 2. if the last city is not destination, search for the next city to go\n    # 3. after getting to the destination, remove the loop within the path, i.e. if there are repeated cities in self.cities, remove the cities and the roads in between the repetition\n</code></pre> </li> <li> <p>Define a method to calculate the path length.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(...):\n    ...\n\n  def get_path_length(self):\n    # calculate path length based on self.path\n    return path_length\n</code></pre> </li> <li> <p>As the path of each ant will be reset every iteration, define a method that reset the <code>path</code> and <code>cities</code>.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(...):\n    ...\n\n  def get_path_length(...):\n    ...\n\n  def reset(self):\n    self.path = []\n    self.cities = []\n</code></pre> </li> </ol>"},{"location":"lab5/#evaporation","title":"Evaporation","text":"<ol> <li> <p>In the <code>Road</code> class, define a method to evaporate the pheromone by taking the input of evaporation rate \u03c1.</p> <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(...):\n    ...\n\n  def evaporate_pheromone(self, rho):\n    # update the pheromone of the road\n</code></pre> </li> </ol>"},{"location":"lab5/#deposition","title":"Deposition","text":"<ol> <li> <p>In the <code>Road</code> class, define a method to calculate the updated pheromone after pheromone deposition by taking the input of all the ants. We will use the following pheromone deposition formula for ant \\(k\\) on road \\(i\\):</p> \\[\\Delta\\tau_{i,k} = \\frac{1}{L_k}\\] <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(...):\n    ...\n\n  def evaporate_pheromone(...):\n    ...\n\n  def deposit_pheromone(self, ants):\n    # 1. search for ants that uses the raod\n    # 2. deposit pheromone using the inversely proportionate relationship between path length and deposited pheromone\n</code></pre> </li> </ol>"},{"location":"lab5/#termination-conditions","title":"Termination conditions","text":"<ol> <li> <p>We will use the following conditions as the termination conditions:</p> <ul> <li>maximum iteration of 200</li> <li>if \u226590% of the ants use the same path</li> </ul> </li> <li> <p>Define a function to calculate the percentage of the most dominant path.</p> <pre><code>def get_percentage_of_dominant_path(ants):\n  ...\n  return percentage\n</code></pre> </li> </ol>"},{"location":"lab5/#loop-until-termination","title":"Loop until termination","text":"<ol> <li> <p>Create a loop to iterate until termination.</p> <pre><code># termination threshold\nmax_iteration = 200\npercentage_of_dominant_path = 0.9\n\niteration = 0\nwhile ...: # termination conditions\n  # loop through all the ants to identify the path of each ant\n  for ant in ants:\n    # reset the path of the ant\n    ant.reset()\n    # identify the path of the ant\n    ant.get_path(origin, destination, alpha)\n  # loop through all roads\n  for road in roads:\n    # evaporate the pheromone on the road\n    road.evaporate_pheromone(rho)\n    # deposit the pheromone\n    road.deposit_pheromone(ants)\n  # increase iteration count\n  iteration += 1\n# after exiting the loop, return the most occurred path as the solution\n...\n</code></pre> </li> </ol>"},{"location":"lab5/#visualisation","title":"Visualisation","text":"<ol> <li> <p>Define the following functions:</p> <pre><code>import matplotlib.pyplot as plt\n...\ndef create_graph(cities):\n  fig = plt.figure()\n  ax = fig.add_subplot(1,1,1)\n  cities_x = [city.coordinates[0] for key, city in cities.items()]\n  cities_y = [city.coordinates[1] for key, city in cities.items()]\n  ax.scatter(cities_x, cities_y)\n  ax.set_aspect(aspect=1.0)\n  return ax\n</code></pre> <pre><code>def draw_pheromone(ax, roads):\n  lines = []\n  for road in roads:\n    from_coord = road.connected_cities[0].coordinates\n    to_coord = road.connected_cities[1].coordinates\n    coord_x = [from_coord[0], to_coord[0]]\n    coord_y = [from_coord[1], to_coord[1]]\n    lines.append(ax.plot(coord_x, coord_y, c='k', linewidth=road.pheromone**2))\n  return lines\n</code></pre> </li> <li> <p>Add the following lines to the <code>main</code> code block just before the <code>while</code> loop (loop until termination).</p> <pre><code>ax = create_graph(cities)\nlines = draw_pheromone(ax, roads)\n</code></pre> </li> <li> <p>Add the following lines to after <code>iteration += 1</code>.</p> <pre><code># visualise\nfor l in lines:\n  del l\nlines = draw_pheromone(ax, roads)\nplt.pause(0.05)\n</code></pre> </li> </ol>"},{"location":"lab5/#evaluate-effect-of-parameters","title":"Evaluate effect of parameters","text":"<ol> <li> <p>Modify the pheromone depositing formula to</p> \\[\\Delta\\tau_{i,k} = \\frac{1}{L_k^{1.5}}\\] <p>What is the effect of this?</p> </li> <li> <p>Modify the pheromone depositing formula to</p> \\[\\Delta\\tau_{i,k} = \\frac{5}{L_k}\\] <p>What is the effect of this?</p> </li> <li> <p>Investigate the effect of number of ants <code>n_ant</code>.</p> </li> <li> <p>Investigate the effect of pheromone influence constant \\(\\alpha\\) <code>alpha</code>.</p> </li> <li> <p>Investigate the effect of evaporation rate \\(\\rho\\) <code>rho</code>.</p> </li> </ol>"},{"location":"lab6/","title":"Lab 6: ANN (Supervised learning)","text":""},{"location":"lab6/#artificial-neural-networks","title":"Artificial neural networks","text":""},{"location":"lab6/#objective","title":"Objective","text":"<ul> <li>to construct an multi-layer perceptron classifier using the scikit-learn Python library</li> </ul>"},{"location":"lab6/#load-data-to-be-learned","title":"Load data to be learned","text":"<p>We will be constructing an artificial neural network and use it to perform prediction.</p> <p>The data we will be using today is the results of a chemical analysis of wines grown in the same region in Italy but derived from three different cultivars.</p> <p>The dataset is available from the scikit-learn library. Therefore we will first import the module. <pre><code>from sklearn import datasets\n</code></pre></p> <p>To load the data,  <pre><code>data = datasets.load_wine()\n</code></pre></p>"},{"location":"lab6/#examine-the-dataset","title":"Examine the dataset","text":"<p>We will use pandas to get more insight into the dataset. Import <code>pandas</code> and construct a data frame from the input and target values.</p> <pre><code>import pandas as pd\nwine = pd.DataFrame(data.data, columns=data.feature_names)\nwine['target'] = data.target\n</code></pre> <p>The <code>describe</code> method of a data frame provides the statistical summary of the dataset.</p> <pre><code>print(wine.describe().transpose())\n</code></pre>"},{"location":"lab6/#split-data-into-training-and-testing-sets","title":"Split data into training and testing sets","text":"<p>scikit-learn library provides a function to split the data into training and testing sets easily. </p> <pre><code>from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(data.data, data.target, train_size=0.8)\n</code></pre> <p>We will split the data into 80% training data and 20% testing data. The first argument will be split into the first two outputs, the second argument the second pair, and so on and so forth.</p>"},{"location":"lab6/#data-preprocessing","title":"Data preprocessing","text":"<p>From Examine the dataset, notice that the range of different features are different. This will cause the training algorithm to be difficult to converge. </p> <p>Now we will use the method of standardisation to normalise the data. scikit-learn provides a built-in class to perform the standardisation, <code>StandardScaler</code>.</p> <pre><code>from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\n</code></pre> <p>We will scale the data based on the training data and then apply the scaler to both the training and testing data.</p> <pre><code>scaler.fit(X_train)\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)\n</code></pre> <p>Examine the training input data with the following code:</p> <pre><code>print(pd.DataFrame(X_train, columns=data.feature_names).describe().transpose())\n</code></pre> <p>Compare this result with the one in Examine the dataset. How are these two datasets different from each other? What did the <code>StandardScaler</code> do to the dataset?</p>"},{"location":"lab6/#construct-the-ann-model","title":"Construct the ANN model","text":"<p>As the target values are classes, i.e. <code>0</code>, <code>1</code>, or <code>2</code>, we need a classifier to perform the classification. </p> <pre><code>from sklearn.neural_network import MLPClassifier\n</code></pre> <p>We will construct a feedforward neural network with 1 hidden layer of 2 neuron and maximum iteration of 1000.</p> <pre><code>mlp = MLPClassifier(hidden_layer_sizes=(2), max_iter=1000)\n</code></pre>"},{"location":"lab6/#train-the-model","title":"Train the model","text":"<p>The model can be trained using the <code>fit</code> method of the classifier. </p> <pre><code>mlp.fit(X_train, y_train)\n</code></pre>"},{"location":"lab6/#predictions","title":"Predictions","text":"<p>The model is now trained. We can use the fitted (trained) model to predict the output of the testing data.</p> <pre><code>predictions = mlp.predict(X_test)\n</code></pre>"},{"location":"lab6/#evaluation","title":"Evaluation","text":"<p>With the prediction results, we can evaluate the performance of the fitted model. scikit-learn library provides some built-in metrics such as confusion matrix and classification report.</p> <pre><code>from sklearn.metrics import confusion_matrix, classification_report\n</code></pre> <p>confusion matrix <pre><code>print(confusion_matrix(y_test, predictions))\n</code></pre></p> <p>classification report <pre><code>print(classification_report(y_test, predictions))\n</code></pre></p> <p>What information is provided by the confusion matrix and the classification report?</p>"},{"location":"lab6/#parameters-of-the-fitted-model","title":"Parameters of the fitted model","text":"<p>The parameters of the fitted model (<code>mlp</code>) can be access through its public attributes:</p> attributes definition <code>.coefs_</code> weight matrix <code>.intercepts_</code> bias (threshold) vector <code>.n_iter_</code> number of iterations the solver has ran <code>.n_layers_</code> number of layers <code>.n_outputs_</code> number of outputs"},{"location":"lab6/#visualisation-the-neural-network","title":"Visualisation the neural network","text":"<p>Copy the following code for the function <code>visualise</code> to the beginning of the script.</p> <pre><code>import matplotlib.pyplot as plt\n\ndef visualise(mlp):\n  # get number of neurons in each layer\n  n_neurons = [len(layer) for layer in mlp.coefs_]\n  n_neurons.append(mlp.n_outputs_)\n\n  # calculate the coordinates of each neuron on the graph\n  y_range = [0, max(n_neurons)]\n  x_range = [0, len(n_neurons)]\n  loc_neurons = [[[l, (n+1)*(y_range[1]/(layer+1))] for n in range(layer)] for l,layer in enumerate(n_neurons)]\n  x_neurons = [x for layer in loc_neurons for x,y in layer]\n  y_neurons = [y for layer in loc_neurons for x,y in layer]\n\n  # identify the range of weights\n  weight_range = [min([layer.min() for layer in mlp.coefs_]), max([layer.max() for layer in mlp.coefs_])]\n\n  # prepare the figure\n  fig = plt.figure()\n  ax = fig.add_subplot(1,1,1)\n  # draw the neurons\n  ax.scatter(x_neurons, y_neurons, s=100, zorder=5)\n  # draw the connections with line width corresponds to the weight of the connection\n  for l,layer in enumerate(mlp.coefs_):\n    for i,neuron in enumerate(layer):\n      for j,w in enumerate(neuron):\n        ax.plot([loc_neurons[l][i][0], loc_neurons[l+1][j][0]], [loc_neurons[l][i][1], loc_neurons[l+1][j][1]], 'white', linewidth=((w-weight_range[0])/(weight_range[1]-weight_range[0])*5+0.2)*1.2)\n        ax.plot([loc_neurons[l][i][0], loc_neurons[l+1][j][0]], [loc_neurons[l][i][1], loc_neurons[l+1][j][1]], 'grey', linewidth=(w-weight_range[0])/(weight_range[1]-weight_range[0])*5+0.2)\n</code></pre> <p>To use this function to visualise the neural network, use the following line after the predictions.</p> <pre><code>visualise(mlp)\n</code></pre>"},{"location":"lab6/#compare-the-weights-before-and-after-the-training","title":"Compare the weights before and after the training","text":"<p>At initiation, the weights are not assigned. Therefore we need to train the model once before we can visualise the neural network. We can train the model once using the <code>.partial_fit</code> method. Put the following lines right after the initiation of <code>mlp</code>.</p> <pre><code>mlp.partial_fit(X_train, y_train, np.unique(data.target))\nvisualise(mlp)\n</code></pre> <p>Compare the weights of the two visualisations.</p>"},{"location":"lab6/#effect-of-parameters","title":"Effect of parameters","text":"<p>Investigate the effect of the following parameters on the performance of the neural network and the number of iterations to achieve convergence.</p> <ul> <li>number of hidden layers</li> <li>number of neurons in hidden layers</li> <li>splitting ratio of training and testing sets</li> </ul>"},{"location":"archive/201908/lab1/","title":"Lab 1: Pre-lab","text":""},{"location":"archive/201908/lab1/#refresh-on-python","title":"Refresh on Python","text":"<ol> <li> <p>Fibonacci sequence is a series of numbers:</p> <p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</p> <p>The first two numbers are 0 and 1. The rest of the numbers in the sequence is found by summing up two numbers before it.</p> </li> <li> <p>Create a function, in Python, which takes the sequence length sl as the input of the function and prints the Fibonacci sequence of the length sl.</p> <pre><code>def fibonacci(sl):\n  ...\n  return fib_seq\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab1/#random-selection-based-on-probability","title":"Random selection based on probability","text":"<p>For this section. assume the <code>random.random()</code> function selects the random number with even probability.</p> <ol> <li> <p>Consider a coin tossing event. If the probabilities of getting a head or a tail are even, i.e. 50%. Create a Python function which will simulate the coin tossing event and return the result as <code>head</code> or <code>tail</code>.</p> <pre><code>def tossCoin():\n  ...\n  return headOrTail\n</code></pre> </li> <li> <p>If the probabilities of getting a head or a tail are not even, with head as 20% and tail as 80%, how would you change the Python function you created previously to adapt to this coin?</p> </li> <li> <p>Consider the event of selecting one option out of three options randomly. The probability of choosing option <code>A</code> is 20%, <code>B</code> is 50%, and  <code>C</code> is 30%. Create a Python funciton to simulate the random selection of the options.</p> <pre><code>def chooseFromThree():\n  ...\n  return selectedOption\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab2/","title":"Lab 2: EC (GA)","text":""},{"location":"archive/201908/lab2/#binary-to-gray-code-conversion","title":"Binary-to-gray code conversion","text":"<p>Binary string is often used in the implementation of genetic algorithm. However, the downside of using a binary code is that the Hamming distance between two adjacent values is not consistent. This situation is solved by using a Gray code in place of a binary code.</p> <ol> <li> <p><code>numpy</code> provides the function of <code>binary_repr</code> to convert a decimal value to its corresponding binary code.</p> </li> <li> <p>Create a function to take the input of a binary code and return the correponding Gray code of the binary code. </p> </li> <li> <p>Create a function to calculate the Hamming distance between two binary strings (two binary codes or two Gray codes).</p> </li> <li> <p>Consider a sequence of decimal values of <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>. Convert the sequence to a series of binary codes. Identify and plot (example of a line plot) the Hamming distances between the adjacent values.</p> </li> <li> <p>Repeat the previous step with Gray codes instead of binary codes.</p> </li> </ol>"},{"location":"archive/201908/lab2/#genetic-algorithm","title":"Genetic algorithm","text":"<p>Consider the following problem: </p> <p>You are given a sheet of paper with width <code>w</code> and height <code>h</code>. Your task is to cut the paper into squares of equal size. The aim of the task is to have as many squares as possible, and to have the area of each square as large as possible.</p> <ol> <li> <p>An optimisation problem can always be phrased in the form of</p> <p>to optimise ... such that it maximises/minimises ...</p> <p>In this problem, what is the parameter to be optimised and what are the parameters to be maximised or minimised?</p> </li> <li> <p>Let <code>x</code> denotes the length of the sides of a square. Design a fitness function such that higher fitness corresponds to larger number of squares and large area. If the number of squares (that can be cut out) is zero, or the area of the square is zero, the fitness will be zero.</p> </li> </ol> feature encoding population initialisation selection as parents crossover mutation offspring (next generation population) repeat from fitnexx calculation until termination"},{"location":"archive/201908/lab2/#feature-encoding","title":"Feature encoding","text":"<ol> <li> <p>In this problem as we only have one feature, i.e. the side length of the square, each chromosome consists of the value of the side length of the square. We will encode the chromosome in the form of Gray code. </p> </li> <li> <p>Create two functions <code>value2gray</code> and <code>gray2value</code> to convert a decimal value to its Gray code and vice versa.</p> <pre><code>def value2gray(value):\n  # this function converts a decimal value to its gray code representation\n  ...\n  return gray\n\ndef gray2value(gray):\n  # this function converts a gray code representation to its decimal value\n  ...\n  return value\n</code></pre> </li> <li> <p>Add the following code snippet to the end of the code to test your functions.</p> <pre><code>if __name__ == \"__main__\":\n  print(value2gray(10))\n  print(gray2value(\"1001\"))\n</code></pre> <p>After running the file as a script, you should see the following output.</p> <pre><code>1111\n14\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab2/#population-initialisation","title":"Population initialisation","text":"<ol> <li> <p>A population is randomly generated according to the defined population size. </p> </li> <li> <p>Create a function to generate randomly a population of size <code>pop_size</code> with each value lies between the range of <code>pop_min</code> to <code>pop_max</code>.</p> <pre><code>def generatePopulation(pop_size, pop_min, pop_max):\n  # this function generate the first generation randomly based on the population size and the range of the value of each chromosome\n  ...\n  return population\n</code></pre> <p>This function and all the functions created after this should be placed before the <code>if __name__ == \"__main__\":</code> code block.</p> </li> <li> <p>[Optional testing] You can test the function by changing the <code>__main__</code> code block to </p> <pre><code>if __name__ == \"__main__\":\n  print(generatePopulation(8, 0, 10))\n</code></pre> <p>The printed output should be a series of 8 chromosomes displayed as decimal values.</p> </li> </ol>"},{"location":"archive/201908/lab2/#fitness-calculation","title":"Fitness calculation","text":"<ol> <li> <p>The fitness function was designed at the beginning of this section. Define a function that takes the input of a chromosome (as decimal value) and returns the fitness of the chromosome.</p> <p><pre><code>def calculateFitness(value):\n  # this function calculates the fitness of a chromosome from the decimal value of the chromosome\n  ...\n  return fitness\n</code></pre> 2. [Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(calculateFitness(5))\n</code></pre> <p>The printed output should be the fitness of a chromosome of value 5, which would be a decimal value larger than zero.</p> </li> </ol>"},{"location":"archive/201908/lab2/#selection-as-parents","title":"Selection as parents","text":"<ol> <li> <p>From the list of the chromosomes, we will select the chromosome pairs as parents. As we will be using one-point crossover, each pair of parents will produce exactly two offsprings. Therefore for population size of <code>pop_size</code>, we need <code>pop_size/2</code> pairs of parents.</p> </li> <li> <p>Define a function that takes the inputs of the current population and the total number of chromosomes in current population, and returns the chromosome pairs which will act as parents. The selection process is performed with the roulette wheel selection. The same chromosome can be selected more than once.</p> <pre><code>def selectParents(chromosomes, pop_size):\n  ...\n  return parent_pairs\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(selectParents([13, 8, 14, 7], 6))\n</code></pre> <p>The printed output should be 3 parent pairs, for example, </p> <pre><code>[[13, 8], [8, 14], [13, 7]]\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab2/#crossover","title":"Crossover","text":"<ol> <li> <p>Define a function that takes a parent pair and returns a pair of offspring after performing one-point crossover.</p> <pre><code>def crossover(parents):\n  # this function takes a parent pair and perform one-point crossover to produce a pair of offspring\n  ...\n  return offsprings\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(crossover([13, 9]))\n</code></pre> <p>The printed output should be a pair of offsprings, for example,</p> <pre><code>[10, 14]\n</code></pre> <p><code>13</code> is <code>1011</code> and <code>9</code> is <code>1101</code> in Gray code, the offsprings <code>10</code> is <code>1111</code> and <code>14</code> is <code>1001</code> in Gray code.</p> </li> </ol>"},{"location":"archive/201908/lab2/#mutation","title":"Mutation","text":"<ol> <li> <p>Each gene in all chromosomes has the same mutation probability <code>p_mutation</code>. </p> </li> <li> <p>Define a function that takes a chromosome and the mutation probability <code>p_mutation</code> as the inputs, and returns the mutated chromosome. </p> <p><pre><code>def mutate(chromosome, p_mutation):\n  # this function mutates each gene of a chromosome based on the mutation probability\n  ...\n  return mutated\n</code></pre> 3. [Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(mutate(15, 0.1))\n</code></pre> <p>The printed output should be the mutated or unmutated chromosome, for example, <code>14</code>.</p> <p><code>15</code> is <code>1000</code> and <code>14</code> is <code>1001</code> in Gray code. In the example output, the last bit is mutated.</p> </li> </ol>"},{"location":"archive/201908/lab2/#repeat-until-termination","title":"Repeat until termination","text":"<ol> <li> <p>The common termination criteria are the maximum number of iterations and the distance among the fitnesses of the chromosomes of the latest population.</p> </li> <li> <p>Define a function that calculates one metric to measure the distance among the fitnesses of the chromosomes, i.e. how far the fitnesses of all the chromosomes are from each other.</p> <pre><code>def findOverallDistance(chromosomes):\n  # this function takes the input of the current population and returns the overall distance among fitnesses of all chromosomes\n  ...\n  return overall_distance\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(findOverallDistance([13, 11, 14, 7]))\n</code></pre> <p>The printed output should be a decimal value that represents the overall distance of fitnesses.</p> </li> </ol>"},{"location":"archive/201908/lab2/#combining-all-functions","title":"Combining all functions","text":"<ol> <li> <p>The functions we have created can be combined with the following code snippet to execute the genetic algorithm to solve the problem defined at the beginning of this section. Consider the width and the height of the sheet of paper to be <code>20cm</code> and <code>15cm</code>.</p> <pre><code>if __name__ == \"__main__\":\n  # main function\n  ## parameter definition\n  pop_size = 10\n  pop_min = 1 #1cm\n  pop_max = 10 #10cm\n  curr_iter = 0\n  max_iter = 100\n  min_overalldistance = 0.5\n  p_mutation = 0.05\n  ## initialise population\n  population = []\n  population.append(generatePopulation(pop_size, pop_min, pop_max))\n  while (curr_iter &lt; max_iter and findOverallDistance(population[-1]) &gt; min_overalldistance):\n    curr_iter += 1\n    ## select parent pairs\n    parents = selectParents(population[-1], len(population[-1]))\n    ## perform crossover\n    offsprings = []\n    for p in parents:\n      new_offsprings = crossover(p)\n      for o in new_offsprings:\n        offsprings.append(o)\n    ## perform mutation\n    mutated = [mutate(offspring, p_mutation) for offspring in offsprings]\n    ## update current population\n    population.append(offsprings)\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab3/","title":"Lab 3: EC (PSO)","text":""},{"location":"archive/201908/lab3/#particle-swarm-optimisation","title":"Particle swarm optimisation","text":""},{"location":"archive/201908/lab3/#objective","title":"Objective","text":"<ul> <li>develop a Python function to perform global best particle swarm optimisation</li> </ul>"},{"location":"archive/201908/lab3/#setup-for-spyder","title":"Setup for Spyder","text":"<ol> <li> <p>If you are using Spyder for this lab, go to Tools &gt; Preferences &gt; IPython console &gt; Graphics and set Backend to Automatic.</p> </li> <li> <p>Restart kernel by going to Consoles &gt; Restart kernel.</p> </li> </ol>"},{"location":"archive/201908/lab3/#problem-to-solve","title":"Problem to solve","text":"<p>Solve the following problem using global best particle swarm optimisation:</p> <p>Find the value of x to minimise the function f(x) = (x+100)(x+50)(x)(x-20)(x-60)(x-100) for -100 &lt; x &lt; 100</p>"},{"location":"archive/201908/lab3/#particle-swarm-optimisation_1","title":"Particle swarm optimisation","text":"particles initialisation personal best identification global best identification velocity calculation position update repeat from personal best identification until termination"},{"location":"archive/201908/lab3/#parameter-definition","title":"Parameter definition","text":"<ol> <li> <p>With global best particle swarm optimisaton, the position update function is given by</p> <p>x<sub>i</sub>(t+1) = x<sub>i</sub>(t) + v<sub>i</sub>(t+1)</p> <p>and the velocity update function is</p> <p>v<sub>i</sub>(t+1) = v<sub>i</sub>(t) + \u03b1<sub>1</sub>\u00a0\u03b2<sub>1</sub>(t)\u00a0(\u00a0p<sub>i</sub>(t) - x<sub>i</sub>(t)\u00a0) + \u03b1<sub>2</sub>\u00a0\u03b2<sub>2</sub>(t)\u00a0(\u00a0p<sub>g</sub>(t) - x<sub>i</sub>(t)\u00a0)</p> </li> <li> <p>\u03b1<sub>1</sub> and \u03b1<sub>2</sub> are acceleration constants that are fixed throughout the algorithm. Define a small value for \u03b1<sub>1</sub> and \u03b1<sub>2</sub>, for example <code>0.1</code>.</p> <pre><code>alpha = [0.1, 0.1]\n</code></pre> </li> <li> <p>\u03b2<sub>1</sub>(t) and \u03b2<sub>2</sub>(t) are random values between <code>0</code> and <code>1</code> that are regenerated every iteration. Therefore no definition is required.</p> </li> <li> <p>Also, define the number of particles to run the algorithm with.</p> <pre><code>n_particle = 10\n</code></pre> </li> <li> <p>Place the definition of these variables in the <code>__main__</code> block.</p> <pre><code>if __name__ == '__main__':\n  alpha = [0.1, 0.1]\n  n_particle = 10\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab3/#create-a-class-for-particle","title":"Create a class for particle","text":"<ol> <li> <p>As each particle is an individual, create a <code>Particle</code> class to hold the data of the particle's current position, velocity, and personal best position.</p> <pre><code>class Particle:\n  def __init__(self, position = 0, velocity = 0):\n    self.position = position\n    self.velocity = velocity\n    self.best_position = position\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab3/#fitness-function","title":"Fitness function","text":"<ol> <li> <p>Fitness function is how we can compare different particles.</p> </li> <li> <p>As our goal is to minimise f(x) as stated in the beginning, we will use f(x) as our fitness function.</p> </li> <li> <p>By using f(x) in minimisation problem, it implies that the lower the value of f(x), the better the particle it is.</p> </li> <li> <p>The value of x is the position of the particle.</p> </li> <li> <p>Define the fitness function as a Python function.</p> <pre><code>def fit_fcn(position):\n  ...\n  return fitness\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab3/#initialise-particles","title":"Initialise particles","text":"<ol> <li> <p>Particles are initialised with random positions within the constraints. </p> </li> <li> <p>At initialisation, we may assume that the initial velocities of all the particles. It is possible to initialise particles with non-zero velocities. For now, we will stick to zero initial velocities.</p> </li> <li> <p>Define a Python function that takes the input of the number of particles and the limits of the positions to initialise and return a list of objects of class <code>Particle</code>. Each particle has random position within the limits and zero velocity.</p> <pre><code>def initialise_particles(n_ptc, position_limits):\n  # position_limits is a list of two values. The first value is the lower boundary and the second value is the upper boundary.\n  ...\n  return particles\n</code></pre> </li> <li> <p>Remember to test your function before proceed.</p> </li> </ol>"},{"location":"archive/201908/lab3/#update-personal-best","title":"Update personal best","text":"<ol> <li> <p>Create a method in the class <code>Particle</code> to update the <code>best_position</code> if necessary.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(self):\n    # 1. calculate the fitnesses of the best_position and the particle's current position\n    # 2. compare the fitnesses and determine if the current position is better than the best_position\n    # 3. update if necessary\n    # 4. no return statement is required\n</code></pre> </li> <li> <p>If the new position has a lower fitness, i.e. the new position is better than the best position, update the <code>best_position</code> to hold the value of the new position.</p> </li> </ol>"},{"location":"archive/201908/lab3/#update-global-best","title":"Update global best","text":"<ol> <li> <p>Initiate a variable named <code>global_best_position</code> with the value <code>None</code> in the <code>__main__</code> block. </p> </li> <li> <p>Create a function that takes two positions as inputs, compare them, and return the better position of the two.</p> <pre><code>def compareFitness(pos1, pos2):\n  # 1. calculate the fitness of pos1 and pos2\n  # 2. compare to determine the better position\n  return betterpos\n</code></pre> </li> <li> <p>We will later use this function to compare the current global best position with the personal best position of each particle.</p> </li> </ol>"},{"location":"archive/201908/lab3/#update-velocity","title":"Update velocity","text":"<ol> <li> <p>Create a method in the class <code>Particle</code> to update the velocity given \u03b1<sub>1</sub>, \u03b1<sub>2</sub>, \u03b2<sub>1</sub>, \u03b2<sub>2</sub>, and the global best position.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(...):\n    ...\n\n  def update_velocity(self, alpha, beta, glob_best_pos):\n    # alpha is a list of two values. we will access alpha_1 and alpha_2 by alpha[0] and alpha[1] respectively. This also applies to beta.\n    # the current position, current velocity, and personal best position of the particle can be accessed by self.position, self.velocity, and self.best_position\n    # assign the particle's velocity with the updated velocity\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab3/#update-particle-position","title":"Update particle position","text":"<ol> <li> <p>As updating a particle position only require information from within the particle object and the limits of the position, create a method called <code>update_position</code> in the class <code>Particle</code> taking the input of the limits of the position.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(...):\n    ...\n\n  def calc_velocity(...):\n    ...\n\n  def update_position(self, position_limits):\n    self.position = self.position + self.velocity\n    # how should you solve the problem of the position (x) going out of the limits\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab3/#create-a-loop-until-termination","title":"Create a loop (until termination)","text":"<ol> <li> <p>Consider the following termination criteria:</p> <ul> <li>exceeding 200 iterations</li> <li>fitnesses of all particles are close</li> <li>positions of all particles are close</li> </ul> </li> <li> <p>Create a function to calculate the average difference between the mean fitness and the fitness of each particle.</p> <pre><code>def calc_avg_fit_diff(particles):\n  # 1. calculate mean fitness of all particles\n  # 2. calculate the difference between the mean fitness and the fitness of each particle\n  # 3. calculate the average of the differences obtained from step 2\n  return avg_fit_diff\n</code></pre> </li> <li> <p>Create a function to calculate the average difference between the mean position and the position of each particle.</p> <pre><code>def calc_avg_pos_diff(particles):\n  # 1. calculate mean position of all particles\n  # 2. calculate the difference between the mean position and the position of each particle\n  # 3. calculate the average of the differences obtained from step 2\n  return avg_pos_diff\n</code></pre> </li> <li> <p>Create a loop (in the <code>__main__</code> block) to execute the global best particle swarm optimisation (gbest PSO) until termination. </p> <pre><code>if __name__ == '__main__':\n  # parameter initialisation\n  alpha = [0.1, 0.1]\n  n_particle = 10\n  global_best_position = None\n  position_limits = [-100, 100]\n  # termination threshold\n  iteration = 0\n  max_iter = 200\n  min_avg_fit_diff = 0.1\n  min_avg_pos_diff = 0.1\n  # initialise particles\n  particles = initialise_particles(n_particle, position_limits)\n  while (...): # how should you define the termination criteria here?\n    print(iteration, [round(x.position,2) for x in particles])\n    for particle in particles:\n      # update personal best\n      particle.update_personal_best()\n      # update global best\n      if global_best_position == None:\n        global_best_position = particle.position\n      else:\n        global_best_position = compareFitness(global_best_position, particle.position)\n    # generate beta randomly for current iteration\n    beta = [random.random(), random.random()]\n    for particle in particles:\n      # update velocity\n      particle.update_velocity(alpha, beta, global_best_position)\n      # update position\n      particle.update_position(position_limits)\n    iteration += 1\n  # display results\n  print(iteration, [round(x.position,2) for x in particles])\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab3/#visualisation","title":"Visualisation","text":"<ol> <li> <p>Let's add a few lines to visualise particles \"flying\" towards to optimal position.</p> <ul> <li> <p>import the visualisation library   <pre><code>import matplotlib.pyplot as plt\n</code></pre></p> </li> <li> <p>add the following lines just before the <code>while</code> loop in the last code block in the previous section.   <pre><code>space_ax = plt.axes()\nspace_ax.plot(list(range(*position_limits)),[fit_fcn(x) for x in range(*position_limits)])\nspace_ax.set_title(\"Position of particles in iteration {}\".format(iteration))\nspace_ax.set_xlabel(\"Position\")\nspace_ax.set_ylabel(\"Fitness\")\n</code></pre></p> </li> <li> <p>add the following lines between line 14 and line 15 in the last code block in the previous section, as well as after line 33.   <pre><code>if len(space_ax.lines) &gt; 1:\n  del space_ax.lines[1]\nspace_ax.plot([x.position for x in particles], [fit_fcn(x.position) for x in particles], 'go')\nspace_ax.set_title(\"Position of particles in iteration {}\".format(iteration))\nplt.pause(0.5) # pause the program for 0.5 second; if graph changes too quickly, increase this value; you can also speed up the process by decreasing this value\n</code></pre></p> </li> </ul> </li> </ol>"},{"location":"archive/201908/lab3/#evaluation","title":"Evaluation","text":"<ol> <li> <p>Store the values of the variables at each iteration for analysis and evaluation.</p> <ul> <li>position of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.position_list = [position]\n\n  def update_position(...):\n    ...\n    self.position_list.append(self.position)\n</code></pre> <ul> <li>velocity of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.velocity_list = [velocity]\n\n  def update_velocity(...):\n    ...\n    self.velocity_list.append(self.velocity)\n</code></pre> <ul> <li>personal best position of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.best_position_list = []\n\n  def update_personal_best(...):\n    ...\n    self.best_position_list.append(self.best_position)\n</code></pre> <ul> <li>global best position at each iteration</li> </ul> <pre><code>if __init__ == '__main__':\n  # parameter initialisation\n  ...\n  global_best_position_list = []\n  ...\n        global_best_position = ...\n    global_best_position_list.append(global_best_position) # take note on the indentation\n    # generate beta randomly for current iteration\n    ...\n</code></pre> </li> <li> <p>Visualise the progression of these variables by adding the following code to the end of the <code>__main__</code> block.</p> <pre><code>[pos_fig, position_axes] = plt.subplots(4,1,sharex=True)\nposition_axes[0].set_title(\"Position of each particle\")\nposition_axes[1].set_title(\"Fitness of each particle\")\nposition_axes[2].set_title(\"Boxplot of position at each iteration\")\nposition_axes[3].set_title(\"Boxplot of fitness at each iteration\")\nposition_axes[3].set_xlabel(\"Iteration\")\n[vel_fig, velocity_axes] = plt.subplots(2,1,sharex=True)\nvelocity_axes[0].set_title(\"Velocity of each particle\")\nvelocity_axes[1].set_title(\"Boxplot for velocity at each iteration\")\nvelocity_axes[1].set_xlabel(\"Iteration\")\n[p_best_fig, personal_best_axes] = plt.subplots(4,1,sharex=True)\npersonal_best_axes[0].set_title(\"Personal best position of each particle\")\npersonal_best_axes[1].set_title(\"Personal best fitness of each particle\")\npersonal_best_axes[2].set_title(\"Boxplot of personal best position at each iteration\")\npersonal_best_axes[3].set_title(\"Boxplot of personal best fitness at each iteration\")\npersonal_best_axes[3].set_xlabel(\"Iteration\")\n[g_best_fig, global_best_axes] = plt.subplots(2,1,sharex=True)\nglobal_best_axes[0].set_title(\"Global best position\")\nglobal_best_axes[1].set_title(\"Boxplot for global best position\")\nglobal_best_axes[1].set_xlabel(\"Iteration\")\nfor particle in particles:\n  iteration_list = list(range(len(particle.position_list)))\n  position_axes[0].plot(iteration_list, particle.position_list, '-o')\n  position_axes[1].plot(iteration_list, [fit_fcn(x) for x in particle.position_list], '-o')\n\n  velocity_axes[0].plot(iteration_list, particle.velocity_list, '-o')\n\n  personal_best_axes[0].plot(iteration_list[:-1], particle.best_position_list, '-o')\n  personal_best_axes[1].plot(iteration_list[:-1], [fit_fcn(x) for x in particle.best_position_list], '-o')\n\nposition_axes[2].boxplot([[p.position_list[i] for p in particles] for i in iteration_list], positions=iteration_list)\nposition_axes[3].boxplot([[fit_fcn(p.position_list[i]) for p in particles] for i in iteration_list], positions=iteration_list)\n\nvelocity_axes[1].boxplot([[p.velocity_list[i] for p in particles] for i in iteration_list], positions=iteration_list)\n\npersonal_best_axes[2].boxplot([[p.best_position_list[i] for p in particles] for i in iteration_list[:-1]], positions=iteration_list[:-1])\npersonal_best_axes[3].boxplot([[fit_fcn(p.best_position_list[i]) for p in particles] for i in iteration_list[:-1]], positions=iteration_list[:-1])\n\nglobal_best_axes[0].plot(iteration_list[:-1], global_best_position_list, '-o')\nglobal_best_axes[1].plot(iteration_list[:-1], [fit_fcn(x) for x in global_best_position_list], '-o')\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab3/#exercise","title":"Exercise","text":"<ol> <li> <p>Multiply the velocity memory, v<sub>i</sub>(t), with a value between 0 and 1, let's say 0.5. How does the process change? This is the effect of inertia weight.</p> </li> <li> <p>Reduce the value of \u03b1<sub>1</sub> to 0.05 while maintaining \u03b1<sub>2</sub> at 0.1 and investigate the effect. </p> </li> <li> <p>Reduce the value of \u03b1<sub>1</sub> to 0. How does this affect the result?</p> </li> <li> <p>Modify such that \u03b1<sub>1</sub> is larger than \u03b1<sub>2</sub>. What's the effect?</p> </li> </ol>"},{"location":"archive/201908/lab3/#optional","title":"Optional","text":"<ol> <li>How may you modify the formulae for particles with two variables, in which the fitness function is defined as f(x,y) = x<sup>2</sup> + y<sup>2</sup>? </li> </ol>"},{"location":"archive/201908/lab4/","title":"Lab 4: EC (ACO)","text":""},{"location":"archive/201908/lab4/#ant-colony-optimisation","title":"Ant colony optimisation","text":""},{"location":"archive/201908/lab4/#objective","title":"Objective","text":"<ul> <li>to develop a Python function to perform ant colony optimisation on a problem</li> </ul>"},{"location":"archive/201908/lab4/#problem-to-solve","title":"Problem to solve","text":"<p>We will use ant colony optimisation to solve the Nick's route-finding problem in Romania. The problem is a route finding problem to identify the best (cheapest) route to travel from Arad to Bucharest.</p> <p>The road map of Romania is provided as follows:</p> 75 71 151 140 118 111 70 75 120 146 80 99 97 138 101 211 90 85 98 86 142 92 87 Arad Zerind Oradea Sibiu Fagaras Rimnicu Vilcea Pitesti Craiova Drobeta Mehadia Lugoj Timisoara Bucharest Giurgiu Urziceni Hirsova Eforie Vaslui Iasi Neamt"},{"location":"archive/201908/lab4/#problem-formulation","title":"Problem formulation","text":"<ol> <li> <p>The coordinates of each town are provided as follows. This will be used later for the purpose of visualisation.</p> <pre><code>location_list = [ # [x,y,name]\n  [75, 125, 'Arad'],\n  [100, 75, 'Zerind'],\n  [125, 25, 'Oradea'],\n  [265, 175, 'Sibiu'],\n  [425, 175, 'Fagaras'],\n  [320, 230, 'Rimnicu Vilcea'],\n  [475, 310, 'Pitesti'],\n  [350, 465, 'Craiova'],\n  [185, 450, 'Drobeta'],\n  [190, 390, 'Mehadia'],\n  [185, 335, 'Lugoj'],\n  [85, 280, 'Timisoara'],\n  [640, 390, 'Bucharest'],\n  [575, 485, 'Giurgiu'],\n  [745, 340, 'Urziceni'],\n  [875, 340, 'Hirsova'],\n  [935, 440, 'Eforie'],\n  [850, 225, 'Vaslui'],\n  [760, 120, 'Iasi'],\n  [625, 60, 'Neamt']\n]\n</code></pre> </li> <li> <p>Then define the travel cost between connected cities. </p> <pre><code>step_cost = [\n  ['Arad', 'Zerind', 75],\n  ['Zerind', 'Oradea', 71],\n  ['Oradea', 'Sibiu', 151],\n  ['Sibiu', 'Arad', 140],\n  ['Sibiu', 'Fagaras', 99],\n  ['Sibiu', 'Rimnicu Vilcea', 80],\n  ['Fagaras', 'Bucharest', 211],\n  ['Bucharest', 'Giurgiu', 90],\n  ['Bucharest', 'Pitesti', 101],\n  ['Pitesti', 'Rimnicu Vilcea', 97],\n  ['Rimnicu Vilcea', 'Craiova', 146],\n  ['Craiova', 'Pitesti', 138],\n  ['Craiova', 'Drobeta', 120],\n  ['Drobeta', 'Mehadia', 75],\n  ['Mehadia', 'Lugoj', 70],\n  ['Lugoj', 'Timisoara', 111],\n  ['Arad', 'Timisoara', 118],\n  ['Bucharest', 'Urziceni', 85],\n  ['Urziceni', 'Vaslui', 142],\n  ['Vaslui', 'Iasi', 92],\n  ['Iasi', 'Neamt', 87],\n  ['Urziceni', 'Hirsova', 98],\n  ['Hirsova', 'Eforie', 86]\n]\n</code></pre> </li> <li> <p>We will define two class, <code>City</code> and <code>Road</code>.</p> </li> <li> <p>An object of class <code>City</code> has the attributes of <code>name</code> (the name of the city), <code>roads</code> (an array of references to the roads connected to the current city), and <code>coordinates</code> (coordinates of the cities).</p> <pre><code>class City:\n  def __init__(self, name):\n    self.name = name\n    self.roads = []\n    self.coordinates = []\n\n  def set_coordinates(self, coordinates):\n    self.coordinates = coordinates\n\n  def add_road(self, road):\n    if road not in self.roads:\n      self.roads.append(road)\n</code></pre> </li> <li> <p>An object of class <code>Road</code> has the attributes of <code>connected_cities</code> (an array of references to the cities connected through this road), <code>cost</code> (the step cost of this road), and <code>pheromone</code> (the pheromone on this road).</p> <pre><code>class Road:\n  def __init__(self, connected_cities, cost, pheromone=0):\n    self.connected_cities = connected_cities\n    self.cost = cost\n    self.pheromone = pheromone\n</code></pre> </li> <li> <p>We will construct the list of <code>City</code> objects and <code>Road</code> objects from the information provided by the question, i.e. information in <code>location_list</code> and <code>step_cost</code>. The following code block should be in the <code>main</code> code block.</p> <pre><code>cities = {}\nfor coord1, coord2, name in location_list:\n  cities[name] = City(name)\n  cities[name].set_coordinates([coord1, coord2])\nroads = []\nfor city1, city2, cost in step_cost:\n  road = Road([cities[city1], cities[city2]], cost)\n  cities[city1].add_road(road)\n  cities[city2].add_road(road)\n  roads.append(road)\n</code></pre> </li> <li> <p>In the <code>main</code> code block, define the <code>origin</code> and <code>destination</code> cities.</p> <pre><code>origin = cities['Arad']\ndestination = cities['Bucharest']\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab4/#initiating-aco-algorithm","title":"Initiating ACO algorithm","text":"<ol> <li> <p>We then define the parameters for ACO, i.e. number of ants, <code>n_ant</code>, pheromone influence constant, <code>alpha</code>, and evaporation rate, <code>rho</code>.</p> <pre><code>n_ant = 10\nalpha = 1\nrho = 0.1\n</code></pre> </li> <li> <p>Add the method <code>set_pheromone</code> to the class <code>Road</code>.      <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(self, pheromone):\n    self.pheromone = pheromone\n</code></pre></p> </li> <li> <p>Set the initial pheromone of each road to 0.01.     <pre><code># in main block\ninitial_pheromone = 0.01\nfor road in roads:\n  road.set_pheromone(initial_pheromone)\n</code></pre></p> </li> <li> <p>Define the class <code>Ant</code>.      <pre><code>class Ant:\n  def __init__(self):\n    self.cities = [] # cities the ant passes through, in sequence\n    self.path = [] # roads the ant uses, in sequence\n</code></pre></p> </li> <li> <p>Initiate <code>n_ants</code> ants.     <pre><code>ants = [Ant() for _ in range(n_ant)]\n</code></pre></p> </li> </ol>"},{"location":"archive/201908/lab4/#identify-path-of-each-ant","title":"Identify path of each ant","text":"<ol> <li> <p>In the <code>Ant</code> class, define a method to identify the path by taking the inputs of the available roads, the origin, the destination, and the pheromone influence constant \u03b1.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(self, origin, destination, alpha):\n    # 1. append origin to the self.cities\n    # 2. if the last city is not destination, search for the next city to go\n    # 3. after getting to the destination, remove the loop within the path, i.e. if there are repeated cities in self.cities, remove the cities and the roads in between the repetition\n</code></pre> </li> <li> <p>Define a method to calculate the path length.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(...):\n    ...\n\n  def get_path_length(self):\n    # calculate path length based on self.path\n    return path_length\n</code></pre> </li> <li> <p>As the path of each ant will be reset every iteration, define a method that reset the <code>path</code> and <code>cities</code>.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(...):\n    ...\n\n  def get_path_length(...):\n    ...\n\n  def reset(self):\n    self.path = []\n    self.cities = []\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab4/#evaporation","title":"Evaporation","text":"<ol> <li> <p>In the <code>Road</code> class, define a method to evaporate the pheromone by taking the input of evaporation rate \u03c1.</p> <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(...):\n    ...\n\n  def evaporate_pheromone(self, rho):\n    # update the pheromone of the road\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab4/#deposition","title":"Deposition","text":"<ol> <li> <p>In the <code>Road</code> class, define a method to calculate the updated pheromone after pheromone deposition by taking the input of all the ants. We will use the following pheromone deposition formula for ant k on road i:</p> <p>\u0394\u03c4<sub>i,k</sub> = 1/L<sub>k</sub></p> <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(...):\n    ...\n\n  def evaporate_pheromone(...):\n    ...\n\n  def deposit_pheromone(self, ants):\n    # 1. search for ants that uses the raod\n    # 2. deposit pheromone using the inversely proportionate relationship between path length and deposited pheromone\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab4/#termination-conditions","title":"Termination conditions","text":"<ol> <li> <p>We will use the following conditions as the termination conditions:</p> <ul> <li>maximum iteration of 200</li> <li>if \u226590% of the ants use the same path</li> </ul> </li> <li> <p>Define a function to calculate the percentage of the most dominant path.</p> <pre><code>def get_percentage_of_dominant_path(ants):\n  ...\n  return percentage\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab4/#loop-until-termination","title":"Loop until termination","text":"<ol> <li> <p>Create a loop to iterate until termination.</p> <pre><code># termination threshold\nmax_iteration = 200\npercentage_of_dominant_path = 0.9\n\niteration = 0\nwhile ...: # termination conditions\n  # loop through all the ants to identify the path of each ant\n  for ant in ants:\n    # reset the path of the ant\n    ant.reset()\n    # identify the path of the ant\n    ant.get_path(origin, destination, alpha)\n  # loop through all roads\n  for road in roads:\n    # evaporate the pheromone on the road\n    road.evaporate_pheromone(rho)\n    # deposit the pheromone\n    road.deposit_pheromone(ants)\n  # increase iteration count\n  iteration += 1\n# after exiting the loop, return the most occurred path as the solution\n...\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab4/#visualisation","title":"Visualisation","text":"<ol> <li> <p>Define the following functions:</p> <pre><code>import matplotlib.pyplot as plt\n...\ndef create_graph(cities):\n  fig = plt.figure()\n  ax = fig.add_subplot(1,1,1)\n  cities_x = [city.coordinates[0] for key, city in cities.items()]\n  cities_y = [city.coordinates[1] for key, city in cities.items()]\n  ax.scatter(cities_x, cities_y)\n  ax.set_aspect(aspect=1.0)\n  return ax\n</code></pre> <pre><code>def draw_pheromone(ax, roads):\n  lines = []\n  for road in roads:\n    from_coord = road.connected_cities[0].coordinates\n    to_coord = road.connected_cities[1].coordinates\n    coord_x = [from_coord[0], to_coord[0]]\n    coord_y = [from_coord[1], to_coord[1]]\n    lines.append(ax.plot(coord_x, coord_y, c='k', linewidth=road.pheromone**2))\n  return lines\n</code></pre> </li> <li> <p>Add the following lines to the <code>main</code> code block just before the <code>while</code> loop (loop until termination).</p> <pre><code>ax = create_graph(cities)\nlines = draw_pheromone(ax, roads)\n</code></pre> </li> <li> <p>Add the following lines to after <code>iteration += 1</code>.</p> <pre><code># visualise\nfor l in lines:\n  del l\nlines = draw_pheromone(ax, roads)\nplt.pause(0.05)\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab4/#evaluate-effect-of-parameters","title":"Evaluate effect of parameters","text":"<ol> <li> <p>Modify the pheromone depositing formula to</p> <p>\u0394\u03c4<sub>i,k</sub> = 1/L<sub>k</sub><sup>1.5</sup></p> <p>What is the effect of this?</p> </li> <li> <p>Modify the pheromone depositing formula to</p> <p>\u0394\u03c4<sub>i,k</sub> = 5/L<sub>k</sub></p> <p>What is the effect of this?</p> </li> <li> <p>Investigate the effect of number of ants <code>n_ant</code>.</p> </li> <li> <p>Investigate the effect of pheromone influence constant \u03b1 <code>alpha</code>.</p> </li> <li> <p>Investigate the effect of evaporation rate \u03c1 <code>rho</code>.</p> </li> </ol>"},{"location":"archive/201908/lab5/","title":"Lab 5: ANN (Supervised learning)","text":""},{"location":"archive/201908/lab5/#artificial-neural-networks","title":"Artificial neural networks","text":""},{"location":"archive/201908/lab5/#objective","title":"Objective","text":"<ul> <li>to construct an multi-layer perceptron classifier using the scikit-learn Python library</li> </ul>"},{"location":"archive/201908/lab5/#load-data-to-be-learned","title":"Load data to be learned","text":"<p>We will be constructing an artificial neural network and use it to perform prediction.</p> <p>The data we will be using today is the results of a chemical analysis of wines grown in the same region in Italy but derived from three different cultivars.</p> <p>The dataset is available from the scikit-learn library. Therefore we will first import the module. <pre><code>from sklearn import datasets\n</code></pre></p> <p>To load the data,  <pre><code>data = datasets.load_wine()\n</code></pre></p>"},{"location":"archive/201908/lab5/#examine-the-dataset","title":"Examine the dataset","text":"<p>We will use pandas to get more insight into the dataset. Import <code>pandas</code> and construct a data frame from the input and target values.</p> <pre><code>import pandas as pd\nwine = pd.DataFrame(data.data, columns=data.feature_names)\nwine['target'] = data.target\n</code></pre> <p>The <code>describe</code> method of a data frame provides the statistical summary of the dataset.</p> <pre><code>print(wine.describe().transpose())\n</code></pre>"},{"location":"archive/201908/lab5/#split-data-into-training-and-testing-sets","title":"Split data into training and testing sets","text":"<p>scikit-learn library provides a function to split the data into training and testing sets easily. </p> <pre><code>from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(data.data, data.target, train_size=0.8)\n</code></pre> <p>We will split the data into 80% training data and 20% testing data. The first argument will be split into the first two outputs, the second argument the second pair, and so on and so forth.</p>"},{"location":"archive/201908/lab5/#data-preprocessing","title":"Data preprocessing","text":"<p>From Examine the dataset, notice that the range of different features are different. This will cause the training algorithm to be difficult to converge. </p> <p>Now we will use the method of standardisation to normalise the data. scikit-learn provides a built-in class to perform the standardisation, <code>StandardScaler</code>.</p> <pre><code>from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\n</code></pre> <p>We will scale the data based on the training data and then apply the scaler to both the training and testing data.</p> <pre><code>scaler.fit(X_train)\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)\n</code></pre> <p>Examine the training input data with the following code:</p> <pre><code>print(pd.DataFrame(X_train, columns=data.feature_names).describe().transpose())\n</code></pre> <p>Compare this result with the one in Examine the dataset. How are these two datasets different from each other? What did the <code>StandardScaler</code> do to the dataset?</p>"},{"location":"archive/201908/lab5/#construct-the-ann-model","title":"Construct the ANN model","text":"<p>As the target values are classes, i.e. <code>0</code>, <code>1</code>, or <code>2</code>, we need a classifier to perform the classification. </p> <pre><code>from sklearn.neural_network import MLPClassifier\n</code></pre> <p>We will construct a feedforward neural network with 1 hidden layer of 2 neuron and maximum iteration of 1000.</p> <pre><code>mlp = MLPClassifier(hidden_layer_sizes=(2), max_iter=1000)\n</code></pre>"},{"location":"archive/201908/lab5/#train-the-model","title":"Train the model","text":"<p>The model can be trained using the <code>fit</code> method of the classifier. </p> <pre><code>mlp.fit(X_train, y_train)\n</code></pre>"},{"location":"archive/201908/lab5/#predictions","title":"Predictions","text":"<p>The model is now trained. We can use the fitted (trained) model to predict the output of the testing data.</p> <pre><code>predictions = mlp.predict(X_test)\n</code></pre>"},{"location":"archive/201908/lab5/#evaluation","title":"Evaluation","text":"<p>With the prediction results, we can evaluate the performance of the fitted model. scikit-learn library provides some built-in metrics such as confusion matrix and classification report.</p> <pre><code>from sklearn.metrics import confusion_matrix, classification_report\n</code></pre> <p>confusion matrix <pre><code>print(confusion_matrix(y_test, predictions))\n</code></pre></p> <p>classification report <pre><code>print(classification_report(y_test, predictions))\n</code></pre></p> <p>What information is provided by the confusion matrix and the classification report?</p>"},{"location":"archive/201908/lab5/#parameters-of-the-fitted-model","title":"Parameters of the fitted model","text":"<p>The parameters of the fitted model (<code>mlp</code>) can be access through its public attributes:</p> attributes definition <code>.coefs_</code> weight matrix <code>.intercepts_</code> bias (threshold) vector <code>.n_iter_</code> number of iterations the solver has ran <code>.n_layers_</code> number of layers <code>.n_outputs_</code> number of outputs"},{"location":"archive/201908/lab5/#visualisation-the-neural-network","title":"Visualisation the neural network","text":"<p>Copy the following code for the function <code>visualise</code> to the beginning of the script.</p> <pre><code>import matplotlib as plt\n\ndef visualise(mlp):\n  # get number of neurons in each layer\n  n_neurons = [len(layer) for layer in mlp.coefs_]\n  n_neurons.append(mlp.n_outputs_)\n\n  # calculate the coordinates of each neuron on the graph\n  y_range = [0, max(n_neurons)]\n  x_range = [0, len(n_neurons)]\n  loc_neurons = [[[l, (n+1)*(y_range[1]/(layer+1))] for n in range(layer)] for l,layer in enumerate(n_neurons)]\n  x_neurons = [x for layer in loc_neurons for x,y in layer]\n  y_neurons = [y for layer in loc_neurons for x,y in layer]\n\n  # identify the range of weights\n  weight_range = [min([layer.min() for layer in mlp.coefs_]), max([layer.max() for layer in mlp.coefs_])]\n\n  # prepare the figure\n  fig = plt.figure()\n  ax = fig.add_subplot(1,1,1)\n  # draw the neurons\n  ax.scatter(x_neurons, y_neurons, s=100, zorder=5)\n  # draw the connections with line width corresponds to the weight of the connection\n  for l,layer in enumerate(mlp.coefs_):\n    for i,neuron in enumerate(layer):\n      for j,w in enumerate(neuron):\n        ax.plot([loc_neurons[l][i][0], loc_neurons[l+1][j][0]], [loc_neurons[l][i][1], loc_neurons[l+1][j][1]], 'white', linewidth=((w-weight_range[0])/(weight_range[1]-weight_range[0])*5+0.2)*1.2)\n        ax.plot([loc_neurons[l][i][0], loc_neurons[l+1][j][0]], [loc_neurons[l][i][1], loc_neurons[l+1][j][1]], 'grey', linewidth=(w-weight_range[0])/(weight_range[1]-weight_range[0])*5+0.2)\n</code></pre> <p>To use this function to visualise the neural network, use the following line after the predictions.</p> <pre><code>visualise(mlp)\n</code></pre>"},{"location":"archive/201908/lab5/#compare-the-weights-before-and-after-the-training","title":"Compare the weights before and after the training","text":"<p>At initiation, the weights are not assigned. Therefore we need to train the model once before we can visualise the neural network. We can train the model once using the <code>.partial_fit</code> method. Put the following lines right after the initiation of <code>mlp</code>.</p> <pre><code>mlp.partial_fit(X_train, y_train, np.unique(data.target))\nvisualise(mlp)\n</code></pre> <p>Compare the weights of the two visualisations.</p>"},{"location":"archive/201908/lab5/#effect-of-parameters","title":"Effect of parameters","text":"<p>Investigate the effect of the following parameters on the performance of the neural network and the number of iterations to achieve convergence.</p> <ul> <li>number of hidden layers</li> <li>number of neurons in hidden layers</li> <li>splitting ratio of training and testing sets</li> </ul>"},{"location":"archive/201908/lab6/","title":"Lab 6: ANN (Hyperplane)","text":""},{"location":"archive/201908/lab6/#artificial-neural-networks","title":"Artificial neural networks","text":""},{"location":"archive/201908/lab6/#objective","title":"Objective","text":"<ul> <li>to visualise the hyperplanes of a neural network configuration for better understanding</li> </ul>"},{"location":"archive/201908/lab6/#data-preparation","title":"Data preparation","text":"<p>We will use the iris data for the training in this lab.</p> <pre><code>from sklearn import datasets\niris = datasets.load_iris()\n</code></pre> <p>We will start with using just two input features. <pre><code>X = [[d[1],d[2]] for d in iris.data]\nnames = [iris.target_names[1],iris.target_names[2]]\nY = iris.target\n</code></pre></p>"},{"location":"archive/201908/lab6/#setup-the-first-configuration-for-neural-network","title":"Setup the first configuration for neural network","text":""},{"location":"archive/201908/lab6/#data-preprocessing","title":"Data preprocessing","text":"<ol> <li> <p>Training and testing sets split</p> <pre><code>from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, Y, train_size=0.8)\n</code></pre> </li> <li> <p>Scale the input data based on the training input data</p> <pre><code>from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nscaler.fit(X_train)\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab6/#construct-and-train-the-ann-model","title":"Construct and train the ANN model","text":"<ol> <li> <p>Construct the model</p> <pre><code>from sklearn.neural_network import MLPClassifier\nmlp = MLPClassifier(hidden_layer_sizes=(2), max_iter=1000)\n</code></pre> </li> <li> <p>Train the model</p> <pre><code>mlp.fit(X_train, y_train)\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab6/#visualise-the-classification-of-a-fitted-model","title":"Visualise the classification of a fitted model","text":""},{"location":"archive/201908/lab6/#prepare-the-figure-and-axis","title":"Prepare the figure and axis","text":"<pre><code>import matplotlib.pyplot as plt\nfig = plt.figure()\nax = fig.add_subplot(1,1,1)\n</code></pre>"},{"location":"archive/201908/lab6/#visualisation-function","title":"Visualisation function","text":"<ol> <li> <p>Download the vis.py and save it to the same folder as your script.</p> </li> <li> <p>Import all functions under the namespace of <code>vis</code> <pre><code>import vis\n</code></pre></p> </li> </ol>"},{"location":"archive/201908/lab6/#visualise-the-result","title":"Visualise the result","text":"<p>Use the following code to visualise the decision area of the model. <pre><code>vis.vis2d(ax, mlp, X_train, y_train, X_test, y_test)\n</code></pre></p>"},{"location":"archive/201908/lab6/#setup-the-second-third-and-more-neural-network-configurations","title":"Setup the second, third, and more neural network configurations","text":"<p>We will investigate the effect of using different activation functions on the hyperplane.</p> <p>The activation functions that are available for <code>MLPClassifier</code> are <code>identity</code>, <code>logistic</code>, <code>tanh</code>, and <code>relu</code> (default). They are explained in the documentation.</p> <p>We can use a <code>for</code>-loop to construct and train the neural network model with different configurations. The same datasets from previous sections are used.</p> <pre><code>activation_functions = ['identity', 'logistic', 'tanh', 'relu']\nfig = plt.figure()\nfor i, actfcn in enumerate(activation_functions):\n  mlp = MLPClassifier(hidden_layer_sizes=(3), activation=actfcn, max_iter=1000)\n  mlp.fit(X_train, y_train)\n  ax = fig.add_subplot(1, len(activation_functions), i+1)\n  ax.set_title(actfcn)\n  vis.vis2d(ax, mlp, X_train, y_train, X_test, y_test)\n</code></pre> <p>Apart from the activation functions, let's compare the results of having different number of hidden layers.</p> <pre><code>activation_functions = ['identity', 'logistic', 'tanh', 'relu']\nhidden_layers = [(3), (3,3), (3,3,3)]\nfig = plt.figure()\nfor i,actfcn in enumerate(activation_functions):\n  for j,hlyr in enumerate(hidden_layers):\n    mlp = MLPClassifier(hidden_layer_sizes=hlyr, activation=actfcn, max_iter=1000)\n    mlp.fit(X_train, y_train)\n    ax = fig.add_subplot(len(hidden_layers), len(activation_functions), j*len(activation_functions)+i+1)\n    ax.set_title('{},{},{}'.format(actfcn,str(hlyr),round(mlp.score(X_test,y_test),2)))\n    vis.vis2d(ax, mlp, X_train, y_train, X_test, y_test)\n    ax.set_xticks([])\n    ax.set_yticks([])\n</code></pre> <p><code>mlp.score(X_test, y_test)</code> gives the prediction accuracy of the model on <code>X_test</code> compared against <code>y_test</code>.</p>"},{"location":"archive/201908/lab6/#consider-more-input-features","title":"Consider more input features","text":"<p>We will now use all the input features instead of two. To prepare the data, <pre><code>X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, train_size=0.8)\nscaler.fit(X_train)\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)\n</code></pre></p>"},{"location":"archive/201908/lab6/#construct-and-train-the-model","title":"Construct and train the model","text":"<pre><code>mlp = MLPClassifier(hidden_layer_sizes=(3), max_iter=10000)\nmlp.fit(X_train, y_train)\n</code></pre>"},{"location":"archive/201908/lab6/#visualise-decision-area-with-more-input-features","title":"Visualise decision area with more input features","text":"<p>We will be using parallel coordinates to display data with more than 2 input features. The following is not a complete parallel coordinates plot but a partial one.</p> <pre><code>fig = plt.figure()\naxes = vis.vis3d(fig, mlp, X_train, y_train, X_test, y_test)\nfor i,a in enumerate(axes):\n  a.set_title(iris.target_names[i])\n  a.set_xticklabels([])\n  a.get_yaxis().set_visible(False)\naxes[-1].set_xticklabels(iris.feature_names)\n</code></pre> <p>Is there other alternative to display data with more than 2 input features?</p>"},{"location":"archive/201908/lab6/#additional","title":"Additional","text":"<p>There is a tensorflow playground which tries to visualise the training process of a neural network. It's similar to what we did in this lab.</p>"},{"location":"archive/201908/lab7/","title":"Lab 7: Fuzzy Systems","text":""},{"location":"archive/201908/lab7/#fuzzy-systems","title":"Fuzzy Systems","text":""},{"location":"archive/201908/lab7/#objective","title":"Objective","text":"<ul> <li>to construct a Mamdani fuzzy system using the <code>scikit-fuzzy</code> Python library</li> <li>to evaluate the result of the constructed fuzzy system</li> </ul>"},{"location":"archive/201908/lab7/#note","title":"Note","text":"<p>As of 3<sup>rd</sup> Nov 2019, the <code>scikit-fuzzy</code> Python library only work properly with Python 3.7 and <code>networkx</code> Python library of version 2.3. <code>networkx</code> version 2.4 is not supported yet.</p> <p>To create a separate environment in Anaconda for <code>scikit-fuzzy</code> library, run the following code in the Anaconda prompt.</p> <pre><code>conda create -n fuzzy python=3.7 networkx=2.3 spyder\nconda activate fuzzy\nconda install -c conda-forge scikit-fuzzy\n</code></pre> <p>Launch Spyder IDE using the command <code>spyder</code>.</p>"},{"location":"archive/201908/lab7/#fuzzy-control-system-for-a-train","title":"Fuzzy control system for a train","text":"<ol> <li> <p>Consider a fuzzy control system to control the brake and throttle of a train based on the speed of the train and the distance of the train to the next stop.</p> </li> <li> <p>Import the <code>skfuzzy</code>, <code>skfuzzy.control</code>, and <code>numpy</code>.</p> <pre><code>import numpy as np\nfrom skfuzzy import control as ctrl\nfrom skfuzzy import membership as mf\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab7/#initialise-inputs-and-outputs","title":"Initialise inputs and outputs","text":"<ol> <li> <p>Speed and distance are the inputs of the system whereas brake and throttle are the outputs.</p> </li> <li> <p>The ranges for the variables are:</p> Variable Range Speed 0 - 85 km/h Distance 0 - 3000 m Brake 0 - 100% Throttle 0 - 100% </li> <li> <p>As the inputs will be the antecedents of the rules, construct the variables <code>speed</code> and <code>distance</code> as <code>skfuzzy.control.Antecedent</code> objects. </p> <pre><code>speed = ctrl.Antecedent(np.arange(0, 85, 0.1), 'speed')\n</code></pre> </li> <li> <p>The initialisation function for <code>skfuzzy.control.Antecedent</code> object takes 2 arguments, the first is the universe of the variable, i.e. the values the variables can take, the second is the label of the variable. The initialisation function for <code>skfuzzy.control.Consequent</code> is similar. </p> </li> <li> <p>The label and the range of the variable can be accessed using <code>.label</code> and <code>.universe</code> respectively.</p> </li> </ol> <p>Task: Initialise the variables <code>distance</code> as <code>Antecedent</code> object, and <code>brake</code> and <code>throttle</code> as <code>Consequent</code> objects. (Outputs of the system will be consequents of the rules)</p>"},{"location":"archive/201908/lab7/#define-membership-functions-for-fuzzy-sets-of-variables","title":"Define membership functions for fuzzy sets of variables","text":"<ol> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>speed (0 to 85 km/h)</p> Linguistic value Fit vector Stopped (1/0, 0/2) Very slow (0/1, 1/2.5, 0/4) Slow (0/2.5, 1/6.5, 0/10.5) Medium fast (0/6.5, 1/26.5, 0/46.5) Fast (0/26.5, 1/70, 1/85) </li> <li> <p>distance (0 to 3000 m)</p> Linguistic value Fit vector At (1/0, 0/2) Very near (0/1, 1/3, 0/5) Near (0/3, 1/101.5, 0/200) Medium far (0/100, 1/1550, 0/3000) Far (0/1500, 1/2250, 1/3000) </li> <li> <p>brake (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/40) Very slight (0/20, 1/50, 0/80) Slight (0/70, 1/83.5, 0/97) Medium (0/95, 1/97, 0/99) Full (0/98, 1/100) </li> <li> <p>throttle (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/2) Very slight (0/1, 1/3, 0/5) Slight (0/3, 1/16.5, 0/30) Medium (0/20, 1/50, 0/80) Full (0/60, 1/80, 1/100) </li> </ul> </li> <li> <p>The <code>skfuzzy.membership</code> module provides the following membership functions:</p> Membership function Description <code>skfuzzy.membership.dsigmf(x, b1, c1, b2, c2)</code> Difference of two fuzzy sigmoid membership functions <code>skfuzzy.membership.gauss2mf(x, mean1, ...)</code> Gaussian fuzzy membership function of two combined Gaussians <code>skfuzzy.membership.gaussmf(x, mean, sigma)</code> Gaussian fuzzy membership function <code>skfuzzy.membership.gbellmf(x, a, b, c)</code> Generalized Bell function fuzzy membership generator <code>skfuzzy.membership.piecemf(x, abc)</code> Piecewise linear membership function (particularly used in FIRE filters) <code>skfuzzy.membership.pimf(x, a, b, c, d)</code> Pi-function fuzzy membership generator <code>skfuzzy.membership.psigmf(x, b1, c1, b2, c2)</code> Product of two sigmoid membership functions <code>skfuzzy.membership.sigmf(x, b, c)</code> The basic sigmoid membership function generator <code>skfuzzy.membership.smf(x, a, b)</code> S-function fuzzy membership generator <code>skfuzzy.membership.trapmf(x, abcd)</code> Trapezoidal membership function generator <code>skfuzzy.membership.trimf(x, abc)</code> Triangular membership function generator <code>skfuzzy.membership.zmf(x, a, b)</code> Z-function fuzzy membership generator </li> <li> <p>The fit vector of a linguitic value can be assigned to a linguistic variable using</p> <pre><code>speed['stopped'] = mf.trimf(speed.universe, [0, 0, 2])\nspeed['very slow'] = mf.trimf(speed.universe, [1, 2.5, 4])\n</code></pre> <p>Task: Assign all fuzzy sets to the linguistic variables.</p> </li> <li> <p>The fuzzy set diagram of a linguistic variable can be viewed using <code>.view()</code></p> <pre><code>speed.view()\n</code></pre> <p>Task: Check if the fuzzy set diagrams match the fit vectors.</p> </li> </ol>"},{"location":"archive/201908/lab7/#define-rules","title":"Define rules","text":"<ol> <li> <p>The rules for this system are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Distance At Very near Near Medium far Far Speed Stopped Full brakeNo throttle Full brakeVery slight throttle Very slow Full brakeNo throttle Medium brakeVery slight throttle Slight brakeVery slight throttle Slow Full brakeNo throttle Medium brakeVery slight throttle Very slight brakeSlight throttle Medium fast Very slight brakeMedium throttle No brakeFull throttle Fast Very slight brakeMedium throttle No brakeFull throttle </p> </li> <li> <p>Rule can be defined using <code>skfuzzy.control.Rule(antecedent, consequent, label)</code>. To define the first rule, i.e. if distance is 'at' and speed is 'stopped', then full brake and no throttle, </p> <pre><code>rule1 = ctrl.Rule(distance['at'] &amp; speed['stopped'], (brake['full'], throttle['no']))\n</code></pre> <p>If the antecedent consists of multiple parts, they can be combined using operators <code>|</code> (OR), <code>&amp;</code> (AND), and <code>~</code> (NOT).</p> <p>If the consequent consists of multiple parts, they can be combined as a <code>list</code>/<code>tuple</code>.</p> <p>Task: Define all the rules. Then combine all the rules in a <code>list</code>, i.e. <code>rules = [rule1, rule2, ...]</code>.</p> </li> </ol>"},{"location":"archive/201908/lab7/#construct-the-fuzzy-control-system","title":"Construct the fuzzy control system","text":"<ol> <li> <p>The train control system can be constructed with</p> <pre><code>train_ctrl = ctrl.ControlSystem(rules=rules)\n</code></pre> </li> <li> <p>A <code>skfuzzy.control.ControlSystemSimulation</code> object is needed to simulate the control system to obtain the outputs given certain inputs.</p> <pre><code>train = ctrl.ControlSystemSimulation(control_system=train_ctrl)\n</code></pre> </li> <li> <p>To obtain the values for <code>brake</code> and <code>throttle</code> given that <code>speed</code> is 30 km/h and <code>distance</code> is 6 m,</p> <pre><code># define the values for the inputs\ntrain.input['speed'] = 30\ntrain.input['distance'] = 2000\n\n# compute the outputs\ntrain.compute()\n\n# print the output values\nprint(train.output)\n\n# to extract one of the outputs\nprint(train.output['brake'])\n</code></pre> </li> <li> <p>To view the results in the graph,</p> <pre><code>brake.view(sim=train)\nthrottle.view(sim=train)\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab7/#view-the-controloutput-space","title":"View the control/output space","text":"<ol> <li> <p>The control/output space allows us to identify if the outputs fit our expectation.</p> </li> <li> <p>Construct an empty 3D space with 100-by-100 x-y grid.</p> <pre><code>x, y = np.meshgrid(np.linspace(speed.universe.min(), speed.universe.max(), 100),\n                   np.linspace(distance.universe.min(), distance.universe.max(), 100))\nz_brake = np.zeros_like(x, dtype=float)\nz_throttle = np.zeros_like(x, dtype=float)\n</code></pre> </li> <li> <p>Loop through every point and identify the value of brake and throttle of each point. As the specified rules are not exhaustive, i.e. some input combinations do not activate any rule, we will set the output of such input combinations to be <code>float('inf')</code>.     <pre><code>for i,r in enumerate(x):\n  for j,c in enumerate(r):\n    train.input['speed'] = x[i,j]\n    train.input['distance'] = y[i,j]\n    try:\n      train.compute()\n    except:\n      z_brake[i,j] = float('inf')\n      z_throttle[i,j] = float('inf')\n    z_brake[i,j] = train.output['brake']\n    z_throttle[i,j] = train.output['throttle']\n</code></pre></p> </li> <li> <p>Plot the result in a 3D graph using the <code>matplotlib.pyplot</code> library.</p> <pre><code>import matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndef plot3d(x,y,z):\n  fig = plt.figure()\n  ax = fig.add_subplot(111, projection='3d')\n\n  ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap='viridis', linewidth=0.4, antialiased=True)\n\n  ax.contourf(x, y, z, zdir='z', offset=-2.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='x', offset=x.max()*1.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='y', offset=y.max()*1.5, cmap='viridis', alpha=0.5)\n\n  ax.view_init(30, 200)\n\nplot3d(x, y, z_brake)\nplot3d(x, y, z_throttle)\n</code></pre> </li> </ol>"},{"location":"archive/201908/lab7/#fuzzy-tipping-recommendation-system","title":"Fuzzy tipping recommendation system","text":"<ol> <li> <p>A fuzzy expert system is designed to identify the percentage of tips a customer will give based on the service and the food the customer received.</p> </li> <li> <p>The system has service and food as inputs, and tips as output.</p> </li> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>service (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>food (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>tips (0 to 30%)</p> Linguistic value Fit vector Low (1/0, 0/15) Medium (0/0, 1/15, 0/30) High (0/15, 1/30) </li> </ul> </li> <li> <p>The rules are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Food Poor Average Good Service Poor low tips low tips medium tips Average low tips medium tips high tips Good medium tips high tips high tips </p> </li> </ol> <p>Task: Construct the fuzzy inference system.</p> <p>Task: Modify the membership functions of the input 'service' to</p> Linguistic value Fit vector Poor (1/0, 0/3) Average (0/2, 1/5, 0/8) Good (0/6, 1/10)"},{"location":"archive/202008/lab1/","title":"Lab 1: Pre-lab","text":""},{"location":"archive/202008/lab1/#refresh-on-python","title":"Refresh on Python","text":"<ol> <li> <p>Fibonacci sequence is a series of numbers:</p> <p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</p> <p>The first two numbers are 0 and 1. The rest of the numbers in the sequence is found by summing up two numbers before it.</p> </li> <li> <p>Create a function, in Python, which takes the sequence length sl as the input of the function and prints the Fibonacci sequence of the length sl.</p> <pre><code>def fibonacci(sl):\n  ...\n  return fib_seq\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab1/#random-selection-based-on-probability","title":"Random selection based on probability","text":"<p>For this section. assume the <code>random.random()</code> function selects the random number with even probability.</p> <ol> <li> <p>Consider a coin tossing event. If the probabilities of getting a head or a tail are even, i.e. 50%. Create a Python function which will simulate the coin tossing event and return the result as <code>head</code> or <code>tail</code>.</p> <pre><code>def tossCoin():\n  ...\n  return headOrTail\n</code></pre> </li> <li> <p>If the probabilities of getting a head or a tail are not even, with head as 20% and tail as 80%, how would you change the Python function you created previously to adapt to this coin?</p> </li> <li> <p>Consider the event of selecting one option out of three options randomly. The probability of choosing option <code>A</code> is 20%, <code>B</code> is 50%, and  <code>C</code> is 30%. Create a Python funciton to simulate the random selection of the options.</p> <pre><code>def chooseFromThree():\n  ...\n  return selectedOption\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab1/#submission","title":"Submission","text":"<p>Submit a Python file with the three functions: <code>fibonacci</code>, <code>tossCoin</code>, and <code>chooseFromThree</code>.</p>"},{"location":"archive/202008/lab2/","title":"Lab 2: EC (GA)","text":""},{"location":"archive/202008/lab2/#binary-to-gray-code-conversion","title":"Binary-to-gray code conversion","text":"<p>Binary string is often used in the implementation of genetic algorithm. However, the downside of using a binary code is that the Hamming distance between two adjacent values is not consistent. This situation is solved by using a Gray code in place of a binary code.</p> <ol> <li> <p><code>numpy</code> provides the function of <code>binary_repr</code> to convert a decimal value to its corresponding binary code.</p> </li> <li> <p>Create a function to take the input of a binary code and return the correponding Gray code of the binary code. </p> </li> <li> <p>Create a function to calculate the Hamming distance between two binary strings (two binary codes or two Gray codes).</p> </li> <li> <p>Consider a sequence of decimal values of <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>. Convert the sequence to a series of binary codes. Identify and plot (example of a line plot) the Hamming distances between the adjacent values.</p> </li> <li> <p>Repeat the previous step with Gray codes instead of binary codes.</p> </li> </ol>"},{"location":"archive/202008/lab2/#genetic-algorithm","title":"Genetic algorithm","text":"<p>Consider the following problem: </p> <p>You are given a sheet of paper with width <code>w</code> and height <code>h</code>. Your task is to cut the paper into squares of equal size. The aim of the task is to have as many squares as possible, and to have the area of each square as large as possible.</p> <ol> <li> <p>An optimisation problem can always be phrased in the form of</p> <p>to optimise ... such that it maximises/minimises ...</p> <p>In this problem, what is the parameter to be optimised and what are the parameters to be maximised or minimised?</p> </li> <li> <p>Let <code>x</code> denotes the length of the sides of a square. Design a fitness function such that higher fitness corresponds to larger number of squares and large area. If the number of squares (that can be cut out) is zero, or the area of the square is zero, the fitness will be zero.</p> </li> </ol> feature encoding population initialisation selection as parents crossover mutation offspring (next generation population) repeat from fitnexx calculation until termination"},{"location":"archive/202008/lab2/#feature-encoding","title":"Feature encoding","text":"<ol> <li> <p>In this problem as we only have one feature, i.e. the side length of the square, each chromosome consists of the value of the side length of the square. We will encode the chromosome in the form of Gray code. </p> </li> <li> <p>Create two functions <code>value2gray</code> and <code>gray2value</code> to convert a decimal value to its Gray code and vice versa.</p> <pre><code>def value2gray(value):\n  # this function converts a decimal value to its gray code representation\n  ...\n  return gray\n\ndef gray2value(gray):\n  # this function converts a gray code representation to its decimal value\n  ...\n  return value\n</code></pre> </li> <li> <p>Add the following code snippet to the end of the code to test your functions.</p> <pre><code>if __name__ == \"__main__\":\n  print(value2gray(10))\n  print(gray2value(\"1001\"))\n</code></pre> <p>After running the file as a script, you should see the following output.</p> <pre><code>1111\n14\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab2/#population-initialisation","title":"Population initialisation","text":"<ol> <li> <p>A population is randomly generated according to the defined population size. </p> </li> <li> <p>Create a function to generate randomly a population of size <code>pop_size</code> with each value lies between the range of <code>pop_min</code> to <code>pop_max</code>.</p> <pre><code>def generatePopulation(pop_size, pop_min, pop_max):\n  # this function generate the first generation randomly based on the population size and the range of the value of each chromosome\n  ...\n  return population\n</code></pre> <p>This function and all the functions created after this should be placed before the <code>if __name__ == \"__main__\":</code> code block.</p> </li> <li> <p>[Optional testing] You can test the function by changing the <code>__main__</code> code block to </p> <pre><code>if __name__ == \"__main__\":\n  print(generatePopulation(8, 0, 10))\n</code></pre> <p>The printed output should be a series of 8 chromosomes displayed as decimal values.</p> </li> </ol>"},{"location":"archive/202008/lab2/#fitness-calculation","title":"Fitness calculation","text":"<ol> <li> <p>The fitness function was designed at the beginning of this section. Define a function that takes the input of a chromosome (as decimal value) and returns the fitness of the chromosome.</p> <p><pre><code>def calculateFitness(value):\n  # this function calculates the fitness of a chromosome from the decimal value of the chromosome\n  ...\n  return fitness\n</code></pre> 2. [Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(calculateFitness(5))\n</code></pre> <p>The printed output should be the fitness of a chromosome of value 5, which would be a decimal value larger than zero.</p> </li> </ol>"},{"location":"archive/202008/lab2/#selection-as-parents","title":"Selection as parents","text":"<ol> <li> <p>From the list of the chromosomes, we will select the chromosome pairs as parents. As we will be using one-point crossover, each pair of parents will produce exactly two offsprings. Therefore for population size of <code>pop_size</code>, we need <code>pop_size/2</code> pairs of parents.</p> </li> <li> <p>Define a function that takes the inputs of the current population and the total number of chromosomes in current population, and returns the chromosome pairs which will act as parents. The selection process is performed with the roulette wheel selection. The same chromosome can be selected more than once.</p> <pre><code>def selectParents(chromosomes, pop_size):\n  ...\n  return parent_pairs\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(selectParents([13, 8, 14, 7], 6))\n</code></pre> <p>The printed output should be 3 parent pairs, for example, </p> <pre><code>[[13, 8], [8, 14], [13, 7]]\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab2/#crossover","title":"Crossover","text":"<ol> <li> <p>Define a function that takes a parent pair and returns a pair of offspring after performing one-point crossover.</p> <pre><code>def crossover(parents):\n  # this function takes a parent pair and perform one-point crossover to produce a pair of offspring\n  ...\n  return offsprings\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(crossover([13, 9]))\n</code></pre> <p>The printed output should be a pair of offsprings, for example,</p> <pre><code>[10, 14]\n</code></pre> <p><code>13</code> is <code>1011</code> and <code>9</code> is <code>1101</code> in Gray code, the offsprings <code>10</code> is <code>1111</code> and <code>14</code> is <code>1001</code> in Gray code.</p> </li> </ol>"},{"location":"archive/202008/lab2/#mutation","title":"Mutation","text":"<ol> <li> <p>Each gene in all chromosomes has the same mutation probability <code>p_mutation</code>. </p> </li> <li> <p>Define a function that takes a chromosome and the mutation probability <code>p_mutation</code> as the inputs, and returns the mutated chromosome. </p> <p><pre><code>def mutate(chromosome, p_mutation):\n  # this function mutates each gene of a chromosome based on the mutation probability\n  ...\n  return mutated\n</code></pre> 3. [Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(mutate(15, 0.1))\n</code></pre> <p>The printed output should be the mutated or unmutated chromosome, for example, <code>14</code>.</p> <p><code>15</code> is <code>1000</code> and <code>14</code> is <code>1001</code> in Gray code. In the example output, the last bit is mutated.</p> </li> </ol>"},{"location":"archive/202008/lab2/#repeat-until-termination","title":"Repeat until termination","text":"<ol> <li> <p>The common termination criteria are the maximum number of iterations and the distance among the fitnesses of the chromosomes of the latest population.</p> </li> <li> <p>Define a function that calculates one metric to measure the distance among the fitnesses of the chromosomes, i.e. how far the fitnesses of all the chromosomes are from each other.</p> <pre><code>def findOverallDistance(chromosomes):\n  # this function takes the input of the current population and returns the overall distance among fitnesses of all chromosomes\n  ...\n  return overall_distance\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(findOverallDistance([13, 11, 14, 7]))\n</code></pre> <p>The printed output should be a decimal value that represents the overall distance of fitnesses.</p> </li> </ol>"},{"location":"archive/202008/lab2/#combining-all-functions","title":"Combining all functions","text":"<ol> <li> <p>The functions we have created can be combined with the following code snippet to execute the genetic algorithm to solve the problem defined at the beginning of this section. Consider the width and the height of the sheet of paper to be <code>20cm</code> and <code>15cm</code>.</p> <pre><code>if __name__ == \"__main__\":\n  # main function\n  ## parameter definition\n  pop_size = 10\n  pop_min = 1 #1cm\n  pop_max = 10 #10cm\n  curr_iter = 0\n  max_iter = 100\n  min_overalldistance = 0.5\n  p_mutation = 0.05\n  ## initialise population\n  population = []\n  population.append(generatePopulation(pop_size, pop_min, pop_max))\n  while (curr_iter &lt; max_iter and findOverallDistance(population[-1]) &gt; min_overalldistance):\n    curr_iter += 1\n    ## select parent pairs\n    parents = selectParents(population[-1], len(population[-1]))\n    ## perform crossover\n    offsprings = []\n    for p in parents:\n      new_offsprings = crossover(p)\n      for o in new_offsprings:\n        offsprings.append(o)\n    ## perform mutation\n    mutated = [mutate(offspring, p_mutation) for offspring in offsprings]\n    ## update current population\n    population.append(mutated)\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab3/","title":"Lab 3: EC (PSO)","text":""},{"location":"archive/202008/lab3/#particle-swarm-optimisation","title":"Particle swarm optimisation","text":""},{"location":"archive/202008/lab3/#objective","title":"Objective","text":"<ul> <li>develop a Python function to perform global best particle swarm optimisation</li> </ul>"},{"location":"archive/202008/lab3/#setup-for-spyder","title":"Setup for Spyder","text":"<ol> <li> <p>If you are using Spyder for this lab, go to Tools &gt; Preferences &gt; IPython console &gt; Graphics and set Backend to Automatic.</p> </li> <li> <p>Restart kernel by going to Consoles &gt; Restart kernel.</p> </li> </ol>"},{"location":"archive/202008/lab3/#problem-to-solve","title":"Problem to solve","text":"<p>Solve the following problem using global best particle swarm optimisation:</p> <p>Find the value of x to minimise the function f(x) = (x+100)(x+50)(x)(x-20)(x-60)(x-100) for -100 &lt; x &lt; 100</p>"},{"location":"archive/202008/lab3/#particle-swarm-optimisation_1","title":"Particle swarm optimisation","text":"particles initialisation personal best identification global best identification velocity calculation position update repeat from personal best identification until termination"},{"location":"archive/202008/lab3/#parameter-definition","title":"Parameter definition","text":"<ol> <li> <p>With global best particle swarm optimisaton, the position update function is given by</p> <p>x<sub>i</sub>(t+1) = x<sub>i</sub>(t) + v<sub>i</sub>(t+1)</p> <p>and the velocity update function is</p> <p>v<sub>i</sub>(t+1) = v<sub>i</sub>(t) + \u03b1<sub>1</sub>\u00a0\u03b2<sub>1</sub>(t)\u00a0(\u00a0p<sub>i</sub>(t) - x<sub>i</sub>(t)\u00a0) + \u03b1<sub>2</sub>\u00a0\u03b2<sub>2</sub>(t)\u00a0(\u00a0p<sub>g</sub>(t) - x<sub>i</sub>(t)\u00a0)</p> </li> <li> <p>\u03b1<sub>1</sub> and \u03b1<sub>2</sub> are acceleration constants that are fixed throughout the algorithm. Define a small value for \u03b1<sub>1</sub> and \u03b1<sub>2</sub>, for example <code>0.1</code>.</p> <pre><code>alpha = [0.1, 0.1]\n</code></pre> </li> <li> <p>\u03b2<sub>1</sub>(t) and \u03b2<sub>2</sub>(t) are random values between <code>0</code> and <code>1</code> that are regenerated every iteration. Therefore no definition is required.</p> </li> <li> <p>Also, define the number of particles to run the algorithm with.</p> <pre><code>n_particle = 10\n</code></pre> </li> <li> <p>Place the definition of these variables in the <code>__main__</code> block.</p> <pre><code>if __name__ == '__main__':\n  alpha = [0.1, 0.1]\n  n_particle = 10\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab3/#create-a-class-for-particle","title":"Create a class for particle","text":"<ol> <li> <p>As each particle is an individual, create a <code>Particle</code> class to hold the data of the particle's current position, velocity, and personal best position.</p> <pre><code>class Particle:\n  def __init__(self, position = 0, velocity = 0):\n    self.position = position\n    self.velocity = velocity\n    self.best_position = position\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab3/#fitness-function","title":"Fitness function","text":"<ol> <li> <p>Fitness function is how we can compare different particles.</p> </li> <li> <p>As our goal is to minimise f(x) as stated in the beginning, we will use f(x) as our fitness function.</p> </li> <li> <p>By using f(x) in minimisation problem, it implies that the lower the value of f(x), the better the particle it is.</p> </li> <li> <p>The value of x is the position of the particle.</p> </li> <li> <p>Define the fitness function as a Python function.</p> <pre><code>def fit_fcn(position):\n  ...\n  return fitness\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab3/#initialise-particles","title":"Initialise particles","text":"<ol> <li> <p>Particles are initialised with random positions within the constraints. </p> </li> <li> <p>At initialisation, we may assume that the initial velocities of all the particles. It is possible to initialise particles with non-zero velocities. For now, we will stick to zero initial velocities.</p> </li> <li> <p>Define a Python function that takes the input of the number of particles and the limits of the positions to initialise and return a list of objects of class <code>Particle</code>. Each particle has random position within the limits and zero velocity.</p> <pre><code>def initialise_particles(n_ptc, position_limits):\n  # position_limits is a list of two values. The first value is the lower boundary and the second value is the upper boundary.\n  ...\n  return particles\n</code></pre> </li> <li> <p>Remember to test your function before proceed.</p> </li> </ol>"},{"location":"archive/202008/lab3/#update-personal-best","title":"Update personal best","text":"<ol> <li> <p>Create a method in the class <code>Particle</code> to update the <code>best_position</code> if necessary.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(self):\n    # 1. calculate the fitnesses of the best_position and the particle's current position\n    # 2. compare the fitnesses and determine if the current position is better than the best_position\n    # 3. update if necessary\n    # 4. no return statement is required\n</code></pre> </li> <li> <p>If the new position has a lower fitness, i.e. the new position is better than the best position, update the <code>best_position</code> to hold the value of the new position.</p> </li> </ol>"},{"location":"archive/202008/lab3/#update-global-best","title":"Update global best","text":"<ol> <li> <p>Initiate a variable named <code>global_best_position</code> with the value <code>None</code> in the <code>__main__</code> block. </p> </li> <li> <p>Create a function that takes two positions as inputs, compare them, and return the better position of the two.</p> <pre><code>def compareFitness(pos1, pos2):\n  # 1. calculate the fitness of pos1 and pos2\n  # 2. compare to determine the better position\n  return betterpos\n</code></pre> </li> <li> <p>We will later use this function to compare the current global best position with the personal best position of each particle.</p> </li> </ol>"},{"location":"archive/202008/lab3/#update-velocity","title":"Update velocity","text":"<ol> <li> <p>Create a method in the class <code>Particle</code> to update the velocity given \u03b1<sub>1</sub>, \u03b1<sub>2</sub>, \u03b2<sub>1</sub>, \u03b2<sub>2</sub>, and the global best position.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(...):\n    ...\n\n  def update_velocity(self, alpha, beta, glob_best_pos):\n    # alpha is a list of two values. we will access alpha_1 and alpha_2 by alpha[0] and alpha[1] respectively. This also applies to beta.\n    # the current position, current velocity, and personal best position of the particle can be accessed by self.position, self.velocity, and self.best_position\n    # assign the particle's velocity with the updated velocity\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab3/#update-particle-position","title":"Update particle position","text":"<ol> <li> <p>As updating a particle position only require information from within the particle object and the limits of the position, create a method called <code>update_position</code> in the class <code>Particle</code> taking the input of the limits of the position.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(...):\n    ...\n\n  def calc_velocity(...):\n    ...\n\n  def update_position(self, position_limits):\n    self.position = self.position + self.velocity\n    # how should you solve the problem of the position (x) going out of the limits\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab3/#create-a-loop-until-termination","title":"Create a loop (until termination)","text":"<ol> <li> <p>Consider the following termination criteria:</p> <ul> <li>exceeding 200 iterations</li> <li>fitnesses of all particles are close</li> <li>positions of all particles are close</li> </ul> </li> <li> <p>Create a function to calculate the average difference between the mean fitness and the fitness of each particle.</p> <pre><code>def calc_avg_fit_diff(particles):\n  # 1. calculate mean fitness of all particles\n  # 2. calculate the difference between the mean fitness and the fitness of each particle\n  # 3. calculate the average of the differences obtained from step 2\n  return avg_fit_diff\n</code></pre> </li> <li> <p>Create a function to calculate the average difference between the mean position and the position of each particle.</p> <pre><code>def calc_avg_pos_diff(particles):\n  # 1. calculate mean position of all particles\n  # 2. calculate the difference between the mean position and the position of each particle\n  # 3. calculate the average of the differences obtained from step 2\n  return avg_pos_diff\n</code></pre> </li> <li> <p>Create a loop (in the <code>__main__</code> block) to execute the global best particle swarm optimisation (gbest PSO) until termination. </p> <pre><code>if __name__ == '__main__':\n  # parameter initialisation\n  alpha = [0.1, 0.1]\n  n_particle = 10\n  global_best_position = None\n  position_limits = [-100, 100]\n  # termination threshold\n  iteration = 0\n  max_iter = 200\n  min_avg_fit_diff = 0.1\n  min_avg_pos_diff = 0.1\n  # initialise particles\n  particles = initialise_particles(n_particle, position_limits)\n  while (...): # how should you define the termination criteria here?\n    print(iteration, [round(x.position,2) for x in particles])\n    for particle in particles:\n      # update personal best\n      particle.update_personal_best()\n      # update global best\n      if global_best_position == None:\n        global_best_position = particle.position\n      else:\n        global_best_position = compareFitness(global_best_position, particle.position)\n    # generate beta randomly for current iteration\n    beta = [random.random(), random.random()]\n    for particle in particles:\n      # update velocity\n      particle.update_velocity(alpha, beta, global_best_position)\n      # update position\n      particle.update_position(position_limits)\n    iteration += 1\n  # display results\n  print(iteration, [round(x.position,2) for x in particles])\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab3/#visualisation","title":"Visualisation","text":"<ol> <li> <p>Let's add a few lines to visualise particles \"flying\" towards to optimal position.</p> <ul> <li> <p>import the visualisation library   <pre><code>import matplotlib.pyplot as plt\n</code></pre></p> </li> <li> <p>add the following lines just before the <code>while</code> loop in the last code block in the previous section.   <pre><code>space_ax = plt.axes()\nspace_ax.plot(list(range(*position_limits)),[fit_fcn(x) for x in range(*position_limits)])\nspace_ax.set_title(\"Position of particles in iteration {}\".format(iteration))\nspace_ax.set_xlabel(\"Position\")\nspace_ax.set_ylabel(\"Fitness\")\n</code></pre></p> </li> <li> <p>add the following lines between line 14 and line 15 in the last code block in the previous section, as well as after line 33.   <pre><code>if len(space_ax.lines) &gt; 1:\n  del space_ax.lines[1]\nspace_ax.plot([x.position for x in particles], [fit_fcn(x.position) for x in particles], 'go')\nspace_ax.set_title(\"Position of particles in iteration {}\".format(iteration))\nplt.pause(0.5) # pause the program for 0.5 second; if graph changes too quickly, increase this value; you can also speed up the process by decreasing this value\n</code></pre></p> </li> </ul> </li> </ol>"},{"location":"archive/202008/lab3/#evaluation","title":"Evaluation","text":"<ol> <li> <p>Store the values of the variables at each iteration for analysis and evaluation.</p> <ul> <li>position of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.position_list = [position]\n\n  def update_position(...):\n    ...\n    self.position_list.append(self.position)\n</code></pre> <ul> <li>velocity of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.velocity_list = [velocity]\n\n  def update_velocity(...):\n    ...\n    self.velocity_list.append(self.velocity)\n</code></pre> <ul> <li>personal best position of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.best_position_list = []\n\n  def update_personal_best(...):\n    ...\n    self.best_position_list.append(self.best_position)\n</code></pre> <ul> <li>global best position at each iteration</li> </ul> <pre><code>if __init__ == '__main__':\n  # parameter initialisation\n  ...\n  global_best_position_list = []\n  ...\n        global_best_position = ...\n    global_best_position_list.append(global_best_position) # take note on the indentation\n    # generate beta randomly for current iteration\n    ...\n</code></pre> </li> <li> <p>Visualise the progression of these variables by adding the following code to the end of the <code>__main__</code> block.</p> <pre><code>[pos_fig, position_axes] = plt.subplots(4,1,sharex=True)\nposition_axes[0].set_title(\"Position of each particle\")\nposition_axes[1].set_title(\"Fitness of each particle\")\nposition_axes[2].set_title(\"Boxplot of position at each iteration\")\nposition_axes[3].set_title(\"Boxplot of fitness at each iteration\")\nposition_axes[3].set_xlabel(\"Iteration\")\n[vel_fig, velocity_axes] = plt.subplots(2,1,sharex=True)\nvelocity_axes[0].set_title(\"Velocity of each particle\")\nvelocity_axes[1].set_title(\"Boxplot for velocity at each iteration\")\nvelocity_axes[1].set_xlabel(\"Iteration\")\n[p_best_fig, personal_best_axes] = plt.subplots(4,1,sharex=True)\npersonal_best_axes[0].set_title(\"Personal best position of each particle\")\npersonal_best_axes[1].set_title(\"Personal best fitness of each particle\")\npersonal_best_axes[2].set_title(\"Boxplot of personal best position at each iteration\")\npersonal_best_axes[3].set_title(\"Boxplot of personal best fitness at each iteration\")\npersonal_best_axes[3].set_xlabel(\"Iteration\")\n[g_best_fig, global_best_axes] = plt.subplots(2,1,sharex=True)\nglobal_best_axes[0].set_title(\"Global best position\")\nglobal_best_axes[1].set_title(\"Boxplot for global best position\")\nglobal_best_axes[1].set_xlabel(\"Iteration\")\nfor particle in particles:\n  iteration_list = list(range(len(particle.position_list)))\n  position_axes[0].plot(iteration_list, particle.position_list, '-o')\n  position_axes[1].plot(iteration_list, [fit_fcn(x) for x in particle.position_list], '-o')\n\n  velocity_axes[0].plot(iteration_list, particle.velocity_list, '-o')\n\n  personal_best_axes[0].plot(iteration_list[:-1], particle.best_position_list, '-o')\n  personal_best_axes[1].plot(iteration_list[:-1], [fit_fcn(x) for x in particle.best_position_list], '-o')\n\nposition_axes[2].boxplot([[p.position_list[i] for p in particles] for i in iteration_list], positions=iteration_list)\nposition_axes[3].boxplot([[fit_fcn(p.position_list[i]) for p in particles] for i in iteration_list], positions=iteration_list)\n\nvelocity_axes[1].boxplot([[p.velocity_list[i] for p in particles] for i in iteration_list], positions=iteration_list)\n\npersonal_best_axes[2].boxplot([[p.best_position_list[i] for p in particles] for i in iteration_list[:-1]], positions=iteration_list[:-1])\npersonal_best_axes[3].boxplot([[fit_fcn(p.best_position_list[i]) for p in particles] for i in iteration_list[:-1]], positions=iteration_list[:-1])\n\nglobal_best_axes[0].plot(iteration_list[:-1], global_best_position_list, '-o')\nglobal_best_axes[1].plot(iteration_list[:-1], [fit_fcn(x) for x in global_best_position_list], '-o')\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab3/#exercise","title":"Exercise","text":"<ol> <li> <p>Multiply the velocity memory, v<sub>i</sub>(t), with a value between 0 and 1, let's say 0.5. How does the process change? This is the effect of inertia weight.</p> </li> <li> <p>Reduce the value of \u03b1<sub>1</sub> to 0.05 while maintaining \u03b1<sub>2</sub> at 0.1 and investigate the effect. </p> </li> <li> <p>Reduce the value of \u03b1<sub>1</sub> to 0. How does this affect the result?</p> </li> <li> <p>Modify such that \u03b1<sub>1</sub> is larger than \u03b1<sub>2</sub>. What's the effect?</p> </li> </ol>"},{"location":"archive/202008/lab3/#optional","title":"Optional","text":"<ol> <li>How may you modify the formulae for particles with two variables, in which the fitness function is defined as f(x,y) = x<sup>2</sup> + y<sup>2</sup>? </li> </ol>"},{"location":"archive/202008/lab4/","title":"Lab 4: EC (ACO)","text":""},{"location":"archive/202008/lab4/#ant-colony-optimisation","title":"Ant colony optimisation","text":""},{"location":"archive/202008/lab4/#objective","title":"Objective","text":"<ul> <li>to develop a Python function to perform ant colony optimisation on a problem</li> </ul>"},{"location":"archive/202008/lab4/#problem-to-solve","title":"Problem to solve","text":"<p>We will use ant colony optimisation to solve the Nick's route-finding problem in Romania. The problem is a route finding problem to identify the best (cheapest) route to travel from Arad to Bucharest.</p> <p>The road map of Romania is provided as follows:</p> 75 71 151 140 118 111 70 75 120 146 80 99 97 138 101 211 90 85 98 86 142 92 87 Arad Zerind Oradea Sibiu Fagaras Rimnicu Vilcea Pitesti Craiova Drobeta Mehadia Lugoj Timisoara Bucharest Giurgiu Urziceni Hirsova Eforie Vaslui Iasi Neamt"},{"location":"archive/202008/lab4/#problem-formulation","title":"Problem formulation","text":"<ol> <li> <p>The coordinates of each town are provided as follows. This will be used later for the purpose of visualisation.</p> <pre><code>location_list = [ # [x,y,name]\n  [75, 125, 'Arad'],\n  [100, 75, 'Zerind'],\n  [125, 25, 'Oradea'],\n  [265, 175, 'Sibiu'],\n  [425, 175, 'Fagaras'],\n  [320, 230, 'Rimnicu Vilcea'],\n  [475, 310, 'Pitesti'],\n  [350, 465, 'Craiova'],\n  [185, 450, 'Drobeta'],\n  [190, 390, 'Mehadia'],\n  [185, 335, 'Lugoj'],\n  [85, 280, 'Timisoara'],\n  [640, 390, 'Bucharest'],\n  [575, 485, 'Giurgiu'],\n  [745, 340, 'Urziceni'],\n  [875, 340, 'Hirsova'],\n  [935, 440, 'Eforie'],\n  [850, 225, 'Vaslui'],\n  [760, 120, 'Iasi'],\n  [625, 60, 'Neamt']\n]\n</code></pre> </li> <li> <p>Then define the travel cost between connected cities. </p> <pre><code>step_cost = [\n  ['Arad', 'Zerind', 75],\n  ['Zerind', 'Oradea', 71],\n  ['Oradea', 'Sibiu', 151],\n  ['Sibiu', 'Arad', 140],\n  ['Sibiu', 'Fagaras', 99],\n  ['Sibiu', 'Rimnicu Vilcea', 80],\n  ['Fagaras', 'Bucharest', 211],\n  ['Bucharest', 'Giurgiu', 90],\n  ['Bucharest', 'Pitesti', 101],\n  ['Pitesti', 'Rimnicu Vilcea', 97],\n  ['Rimnicu Vilcea', 'Craiova', 146],\n  ['Craiova', 'Pitesti', 138],\n  ['Craiova', 'Drobeta', 120],\n  ['Drobeta', 'Mehadia', 75],\n  ['Mehadia', 'Lugoj', 70],\n  ['Lugoj', 'Timisoara', 111],\n  ['Arad', 'Timisoara', 118],\n  ['Bucharest', 'Urziceni', 85],\n  ['Urziceni', 'Vaslui', 142],\n  ['Vaslui', 'Iasi', 92],\n  ['Iasi', 'Neamt', 87],\n  ['Urziceni', 'Hirsova', 98],\n  ['Hirsova', 'Eforie', 86]\n]\n</code></pre> </li> <li> <p>We will define two class, <code>City</code> and <code>Road</code>.</p> </li> <li> <p>An object of class <code>City</code> has the attributes of <code>name</code> (the name of the city), <code>roads</code> (an array of references to the roads connected to the current city), and <code>coordinates</code> (coordinates of the cities).</p> <pre><code>class City:\n  def __init__(self, name):\n    self.name = name\n    self.roads = []\n    self.coordinates = []\n\n  def set_coordinates(self, coordinates):\n    self.coordinates = coordinates\n\n  def add_road(self, road):\n    if road not in self.roads:\n      self.roads.append(road)\n</code></pre> </li> <li> <p>An object of class <code>Road</code> has the attributes of <code>connected_cities</code> (an array of references to the cities connected through this road), <code>cost</code> (the step cost of this road), and <code>pheromone</code> (the pheromone on this road).</p> <pre><code>class Road:\n  def __init__(self, connected_cities, cost, pheromone=0):\n    self.connected_cities = connected_cities\n    self.cost = cost\n    self.pheromone = pheromone\n</code></pre> </li> <li> <p>We will construct the list of <code>City</code> objects and <code>Road</code> objects from the information provided by the question, i.e. information in <code>location_list</code> and <code>step_cost</code>. The following code block should be in the <code>main</code> code block.</p> <pre><code>cities = {}\nfor coord1, coord2, name in location_list:\n  cities[name] = City(name)\n  cities[name].set_coordinates([coord1, coord2])\nroads = []\nfor city1, city2, cost in step_cost:\n  road = Road([cities[city1], cities[city2]], cost)\n  cities[city1].add_road(road)\n  cities[city2].add_road(road)\n  roads.append(road)\n</code></pre> </li> <li> <p>In the <code>main</code> code block, define the <code>origin</code> and <code>destination</code> cities.</p> <pre><code>origin = cities['Arad']\ndestination = cities['Bucharest']\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab4/#initiating-aco-algorithm","title":"Initiating ACO algorithm","text":"<ol> <li> <p>We then define the parameters for ACO, i.e. number of ants, <code>n_ant</code>, pheromone influence constant, <code>alpha</code>, and evaporation rate, <code>rho</code>.</p> <pre><code>n_ant = 10\nalpha = 1\nrho = 0.1\n</code></pre> </li> <li> <p>Add the method <code>set_pheromone</code> to the class <code>Road</code>.      <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(self, pheromone):\n    self.pheromone = pheromone\n</code></pre></p> </li> <li> <p>Set the initial pheromone of each road to 0.01.     <pre><code># in main block\ninitial_pheromone = 0.01\nfor road in roads:\n  road.set_pheromone(initial_pheromone)\n</code></pre></p> </li> <li> <p>Define the class <code>Ant</code>.      <pre><code>class Ant:\n  def __init__(self):\n    self.cities = [] # cities the ant passes through, in sequence\n    self.path = [] # roads the ant uses, in sequence\n</code></pre></p> </li> <li> <p>Initiate <code>n_ants</code> ants.     <pre><code>ants = [Ant() for _ in range(n_ant)]\n</code></pre></p> </li> </ol>"},{"location":"archive/202008/lab4/#identify-path-of-each-ant","title":"Identify path of each ant","text":"<ol> <li> <p>In the <code>Ant</code> class, define a method to identify the path by taking the inputs of the available roads, the origin, the destination, and the pheromone influence constant \u03b1.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(self, origin, destination, alpha):\n    # 1. append origin to the self.cities\n    # 2. if the last city is not destination, search for the next city to go\n    # 3. after getting to the destination, remove the loop within the path, i.e. if there are repeated cities in self.cities, remove the cities and the roads in between the repetition\n</code></pre> </li> <li> <p>Define a method to calculate the path length.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(...):\n    ...\n\n  def get_path_length(self):\n    # calculate path length based on self.path\n    return path_length\n</code></pre> </li> <li> <p>As the path of each ant will be reset every iteration, define a method that reset the <code>path</code> and <code>cities</code>.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(...):\n    ...\n\n  def get_path_length(...):\n    ...\n\n  def reset(self):\n    self.path = []\n    self.cities = []\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab4/#evaporation","title":"Evaporation","text":"<ol> <li> <p>In the <code>Road</code> class, define a method to evaporate the pheromone by taking the input of evaporation rate \u03c1.</p> <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(...):\n    ...\n\n  def evaporate_pheromone(self, rho):\n    # update the pheromone of the road\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab4/#deposition","title":"Deposition","text":"<ol> <li> <p>In the <code>Road</code> class, define a method to calculate the updated pheromone after pheromone deposition by taking the input of all the ants. We will use the following pheromone deposition formula for ant k on road i:</p> <p>\u0394\u03c4<sub>i,k</sub> = 1/L<sub>k</sub></p> <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(...):\n    ...\n\n  def evaporate_pheromone(...):\n    ...\n\n  def deposit_pheromone(self, ants):\n    # 1. search for ants that uses the raod\n    # 2. deposit pheromone using the inversely proportionate relationship between path length and deposited pheromone\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab4/#termination-conditions","title":"Termination conditions","text":"<ol> <li> <p>We will use the following conditions as the termination conditions:</p> <ul> <li>maximum iteration of 200</li> <li>if \u226590% of the ants use the same path</li> </ul> </li> <li> <p>Define a function to calculate the percentage of the most dominant path.</p> <pre><code>def get_percentage_of_dominant_path(ants):\n  ...\n  return percentage\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab4/#loop-until-termination","title":"Loop until termination","text":"<ol> <li> <p>Create a loop to iterate until termination.</p> <pre><code># termination threshold\nmax_iteration = 200\npercentage_of_dominant_path = 0.9\n\niteration = 0\nwhile ...: # termination conditions\n  # loop through all the ants to identify the path of each ant\n  for ant in ants:\n    # reset the path of the ant\n    ant.reset()\n    # identify the path of the ant\n    ant.get_path(origin, destination, alpha)\n  # loop through all roads\n  for road in roads:\n    # evaporate the pheromone on the road\n    road.evaporate_pheromone(rho)\n    # deposit the pheromone\n    road.deposit_pheromone(ants)\n  # increase iteration count\n  iteration += 1\n# after exiting the loop, return the most occurred path as the solution\n...\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab4/#visualisation","title":"Visualisation","text":"<ol> <li> <p>Define the following functions:</p> <pre><code>import matplotlib.pyplot as plt\n...\ndef create_graph(cities):\n  fig = plt.figure()\n  ax = fig.add_subplot(1,1,1)\n  cities_x = [city.coordinates[0] for key, city in cities.items()]\n  cities_y = [city.coordinates[1] for key, city in cities.items()]\n  ax.scatter(cities_x, cities_y)\n  ax.set_aspect(aspect=1.0)\n  return ax\n</code></pre> <pre><code>def draw_pheromone(ax, roads):\n  lines = []\n  for road in roads:\n    from_coord = road.connected_cities[0].coordinates\n    to_coord = road.connected_cities[1].coordinates\n    coord_x = [from_coord[0], to_coord[0]]\n    coord_y = [from_coord[1], to_coord[1]]\n    lines.append(ax.plot(coord_x, coord_y, c='k', linewidth=road.pheromone**2))\n  return lines\n</code></pre> </li> <li> <p>Add the following lines to the <code>main</code> code block just before the <code>while</code> loop (loop until termination).</p> <pre><code>ax = create_graph(cities)\nlines = draw_pheromone(ax, roads)\n</code></pre> </li> <li> <p>Add the following lines to after <code>iteration += 1</code>.</p> <pre><code># visualise\nfor l in lines:\n  del l\nlines = draw_pheromone(ax, roads)\nplt.pause(0.05)\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab4/#evaluate-effect-of-parameters","title":"Evaluate effect of parameters","text":"<ol> <li> <p>Modify the pheromone depositing formula to</p> <p>\u0394\u03c4<sub>i,k</sub> = 1/L<sub>k</sub><sup>1.5</sup></p> <p>What is the effect of this?</p> </li> <li> <p>Modify the pheromone depositing formula to</p> <p>\u0394\u03c4<sub>i,k</sub> = 5/L<sub>k</sub></p> <p>What is the effect of this?</p> </li> <li> <p>Investigate the effect of number of ants <code>n_ant</code>.</p> </li> <li> <p>Investigate the effect of pheromone influence constant \u03b1 <code>alpha</code>.</p> </li> <li> <p>Investigate the effect of evaporation rate \u03c1 <code>rho</code>.</p> </li> </ol>"},{"location":"archive/202008/lab5/","title":"Lab 5: ANN (Supervised learning)","text":""},{"location":"archive/202008/lab5/#artificial-neural-networks","title":"Artificial neural networks","text":""},{"location":"archive/202008/lab5/#objective","title":"Objective","text":"<ul> <li>to construct an multi-layer perceptron classifier using the scikit-learn Python library</li> </ul>"},{"location":"archive/202008/lab5/#load-data-to-be-learned","title":"Load data to be learned","text":"<p>We will be constructing an artificial neural network and use it to perform prediction.</p> <p>The data we will be using today is the results of a chemical analysis of wines grown in the same region in Italy but derived from three different cultivars.</p> <p>The dataset is available from the scikit-learn library. Therefore we will first import the module. <pre><code>from sklearn import datasets\n</code></pre></p> <p>To load the data,  <pre><code>data = datasets.load_wine()\n</code></pre></p>"},{"location":"archive/202008/lab5/#examine-the-dataset","title":"Examine the dataset","text":"<p>We will use pandas to get more insight into the dataset. Import <code>pandas</code> and construct a data frame from the input and target values.</p> <pre><code>import pandas as pd\nwine = pd.DataFrame(data.data, columns=data.feature_names)\nwine['target'] = data.target\n</code></pre> <p>The <code>describe</code> method of a data frame provides the statistical summary of the dataset.</p> <pre><code>print(wine.describe().transpose())\n</code></pre>"},{"location":"archive/202008/lab5/#split-data-into-training-and-testing-sets","title":"Split data into training and testing sets","text":"<p>scikit-learn library provides a function to split the data into training and testing sets easily. </p> <pre><code>from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(data.data, data.target, train_size=0.8)\n</code></pre> <p>We will split the data into 80% training data and 20% testing data. The first argument will be split into the first two outputs, the second argument the second pair, and so on and so forth.</p>"},{"location":"archive/202008/lab5/#data-preprocessing","title":"Data preprocessing","text":"<p>From Examine the dataset, notice that the range of different features are different. This will cause the training algorithm to be difficult to converge. </p> <p>Now we will use the method of standardisation to normalise the data. scikit-learn provides a built-in class to perform the standardisation, <code>StandardScaler</code>.</p> <pre><code>from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\n</code></pre> <p>We will scale the data based on the training data and then apply the scaler to both the training and testing data.</p> <pre><code>scaler.fit(X_train)\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)\n</code></pre> <p>Examine the training input data with the following code:</p> <pre><code>print(pd.DataFrame(X_train, columns=data.feature_names).describe().transpose())\n</code></pre> <p>Compare this result with the one in Examine the dataset. How are these two datasets different from each other? What did the <code>StandardScaler</code> do to the dataset?</p>"},{"location":"archive/202008/lab5/#construct-the-ann-model","title":"Construct the ANN model","text":"<p>As the target values are classes, i.e. <code>0</code>, <code>1</code>, or <code>2</code>, we need a classifier to perform the classification. </p> <pre><code>from sklearn.neural_network import MLPClassifier\n</code></pre> <p>We will construct a feedforward neural network with 1 hidden layer of 2 neuron and maximum iteration of 1000.</p> <pre><code>mlp = MLPClassifier(hidden_layer_sizes=(2), max_iter=1000)\n</code></pre>"},{"location":"archive/202008/lab5/#train-the-model","title":"Train the model","text":"<p>The model can be trained using the <code>fit</code> method of the classifier. </p> <pre><code>mlp.fit(X_train, y_train)\n</code></pre>"},{"location":"archive/202008/lab5/#predictions","title":"Predictions","text":"<p>The model is now trained. We can use the fitted (trained) model to predict the output of the testing data.</p> <pre><code>predictions = mlp.predict(X_test)\n</code></pre>"},{"location":"archive/202008/lab5/#evaluation","title":"Evaluation","text":"<p>With the prediction results, we can evaluate the performance of the fitted model. scikit-learn library provides some built-in metrics such as confusion matrix and classification report.</p> <pre><code>from sklearn.metrics import confusion_matrix, classification_report\n</code></pre> <p>confusion matrix <pre><code>print(confusion_matrix(y_test, predictions))\n</code></pre></p> <p>classification report <pre><code>print(classification_report(y_test, predictions))\n</code></pre></p> <p>What information is provided by the confusion matrix and the classification report?</p>"},{"location":"archive/202008/lab5/#parameters-of-the-fitted-model","title":"Parameters of the fitted model","text":"<p>The parameters of the fitted model (<code>mlp</code>) can be access through its public attributes:</p> attributes definition <code>.coefs_</code> weight matrix <code>.intercepts_</code> bias (threshold) vector <code>.n_iter_</code> number of iterations the solver has ran <code>.n_layers_</code> number of layers <code>.n_outputs_</code> number of outputs"},{"location":"archive/202008/lab5/#visualisation-the-neural-network","title":"Visualisation the neural network","text":"<p>Copy the following code for the function <code>visualise</code> to the beginning of the script.</p> <pre><code>import matplotlib.pyplot as plt\n\ndef visualise(mlp):\n  # get number of neurons in each layer\n  n_neurons = [len(layer) for layer in mlp.coefs_]\n  n_neurons.append(mlp.n_outputs_)\n\n  # calculate the coordinates of each neuron on the graph\n  y_range = [0, max(n_neurons)]\n  x_range = [0, len(n_neurons)]\n  loc_neurons = [[[l, (n+1)*(y_range[1]/(layer+1))] for n in range(layer)] for l,layer in enumerate(n_neurons)]\n  x_neurons = [x for layer in loc_neurons for x,y in layer]\n  y_neurons = [y for layer in loc_neurons for x,y in layer]\n\n  # identify the range of weights\n  weight_range = [min([layer.min() for layer in mlp.coefs_]), max([layer.max() for layer in mlp.coefs_])]\n\n  # prepare the figure\n  fig = plt.figure()\n  ax = fig.add_subplot(1,1,1)\n  # draw the neurons\n  ax.scatter(x_neurons, y_neurons, s=100, zorder=5)\n  # draw the connections with line width corresponds to the weight of the connection\n  for l,layer in enumerate(mlp.coefs_):\n    for i,neuron in enumerate(layer):\n      for j,w in enumerate(neuron):\n        ax.plot([loc_neurons[l][i][0], loc_neurons[l+1][j][0]], [loc_neurons[l][i][1], loc_neurons[l+1][j][1]], 'white', linewidth=((w-weight_range[0])/(weight_range[1]-weight_range[0])*5+0.2)*1.2)\n        ax.plot([loc_neurons[l][i][0], loc_neurons[l+1][j][0]], [loc_neurons[l][i][1], loc_neurons[l+1][j][1]], 'grey', linewidth=(w-weight_range[0])/(weight_range[1]-weight_range[0])*5+0.2)\n</code></pre> <p>To use this function to visualise the neural network, use the following line after the predictions.</p> <pre><code>visualise(mlp)\n</code></pre>"},{"location":"archive/202008/lab5/#compare-the-weights-before-and-after-the-training","title":"Compare the weights before and after the training","text":"<p>At initiation, the weights are not assigned. Therefore we need to train the model once before we can visualise the neural network. We can train the model once using the <code>.partial_fit</code> method. Put the following lines right after the initiation of <code>mlp</code>.</p> <pre><code>mlp.partial_fit(X_train, y_train, np.unique(data.target))\nvisualise(mlp)\n</code></pre> <p>Compare the weights of the two visualisations.</p>"},{"location":"archive/202008/lab5/#effect-of-parameters","title":"Effect of parameters","text":"<p>Investigate the effect of the following parameters on the performance of the neural network and the number of iterations to achieve convergence.</p> <ul> <li>number of hidden layers</li> <li>number of neurons in hidden layers</li> <li>splitting ratio of training and testing sets</li> </ul>"},{"location":"archive/202008/lab6/","title":"Lab 6: ANN (Hyperplane)","text":""},{"location":"archive/202008/lab6/#artificial-neural-networks","title":"Artificial neural networks","text":""},{"location":"archive/202008/lab6/#objective","title":"Objective","text":"<ul> <li>to visualise the hyperplanes of a neural network configuration for better understanding</li> </ul>"},{"location":"archive/202008/lab6/#data-preparation","title":"Data preparation","text":"<p>We will use the iris data for the training in this lab.</p> <pre><code>from sklearn import datasets\niris = datasets.load_iris()\n</code></pre> <p>We will start with using just two input features. <pre><code>X = [[d[1],d[2]] for d in iris.data]\nnames = [iris.target_names[1],iris.target_names[2]]\nY = iris.target\n</code></pre></p>"},{"location":"archive/202008/lab6/#setup-the-first-configuration-for-neural-network","title":"Setup the first configuration for neural network","text":""},{"location":"archive/202008/lab6/#data-preprocessing","title":"Data preprocessing","text":"<ol> <li> <p>Training and testing sets split</p> <pre><code>from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, Y, train_size=0.8)\n</code></pre> </li> <li> <p>Scale the input data based on the training input data</p> <pre><code>from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nscaler.fit(X_train)\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab6/#construct-and-train-the-ann-model","title":"Construct and train the ANN model","text":"<ol> <li> <p>Construct the model</p> <pre><code>from sklearn.neural_network import MLPClassifier\nmlp = MLPClassifier(hidden_layer_sizes=(2), max_iter=1000)\n</code></pre> </li> <li> <p>Train the model</p> <pre><code>mlp.fit(X_train, y_train)\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab6/#visualise-the-classification-of-a-fitted-model","title":"Visualise the classification of a fitted model","text":""},{"location":"archive/202008/lab6/#prepare-the-figure-and-axis","title":"Prepare the figure and axis","text":"<pre><code>import matplotlib.pyplot as plt\nfig = plt.figure()\nax = fig.add_subplot(1,1,1)\n</code></pre>"},{"location":"archive/202008/lab6/#visualisation-function","title":"Visualisation function","text":"<ol> <li> <p>Download the vis.py and save it to the same folder as your script.</p> </li> <li> <p>Import all functions under the namespace of <code>vis</code> <pre><code>import vis\n</code></pre></p> </li> </ol>"},{"location":"archive/202008/lab6/#visualise-the-result","title":"Visualise the result","text":"<p>Use the following code to visualise the decision area of the model. <pre><code>vis.vis2d(ax, mlp, X_train, y_train, X_test, y_test)\n</code></pre></p>"},{"location":"archive/202008/lab6/#setup-the-second-third-and-more-neural-network-configurations","title":"Setup the second, third, and more neural network configurations","text":"<p>We will investigate the effect of using different activation functions on the hyperplane.</p> <p>The activation functions that are available for <code>MLPClassifier</code> are <code>identity</code>, <code>logistic</code>, <code>tanh</code>, and <code>relu</code> (default). They are explained in the documentation.</p> <p>We can use a <code>for</code>-loop to construct and train the neural network model with different configurations. The same datasets from previous sections are used.</p> <pre><code>activation_functions = ['identity', 'logistic', 'tanh', 'relu']\nfig = plt.figure()\nfor i, actfcn in enumerate(activation_functions):\n  mlp = MLPClassifier(hidden_layer_sizes=(3), activation=actfcn, max_iter=1000)\n  mlp.fit(X_train, y_train)\n  ax = fig.add_subplot(1, len(activation_functions), i+1)\n  ax.set_title(actfcn)\n  vis.vis2d(ax, mlp, X_train, y_train, X_test, y_test)\n</code></pre> <p>Apart from the activation functions, let's compare the results of having different number of hidden layers.</p> <pre><code>activation_functions = ['identity', 'logistic', 'tanh', 'relu']\nhidden_layers = [(3), (3,3), (3,3,3)]\nfig = plt.figure()\nfor i,actfcn in enumerate(activation_functions):\n  for j,hlyr in enumerate(hidden_layers):\n    mlp = MLPClassifier(hidden_layer_sizes=hlyr, activation=actfcn, max_iter=1000)\n    mlp.fit(X_train, y_train)\n    ax = fig.add_subplot(len(hidden_layers), len(activation_functions), j*len(activation_functions)+i+1)\n    ax.set_title('{},{},{}'.format(actfcn,str(hlyr),round(mlp.score(X_test,y_test),2)))\n    vis.vis2d(ax, mlp, X_train, y_train, X_test, y_test)\n    ax.set_xticks([])\n    ax.set_yticks([])\n</code></pre> <p><code>mlp.score(X_test, y_test)</code> gives the prediction accuracy of the model on <code>X_test</code> compared against <code>y_test</code>.</p>"},{"location":"archive/202008/lab6/#consider-more-input-features","title":"Consider more input features","text":"<p>We will now use all the input features instead of two. To prepare the data, <pre><code>X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, train_size=0.8)\nscaler.fit(X_train)\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)\n</code></pre></p>"},{"location":"archive/202008/lab6/#construct-and-train-the-model","title":"Construct and train the model","text":"<pre><code>mlp = MLPClassifier(hidden_layer_sizes=(3), max_iter=10000)\nmlp.fit(X_train, y_train)\n</code></pre>"},{"location":"archive/202008/lab6/#visualise-decision-area-with-more-input-features","title":"Visualise decision area with more input features","text":"<p>We will be using parallel coordinates to display data with more than 2 input features. The following is not a complete parallel coordinates plot but a partial one.</p> <pre><code>fig = plt.figure()\naxes = vis.vis3d(fig, mlp, X_train, y_train, X_test, y_test)\nfor i,a in enumerate(axes):\n  a.set_title(iris.target_names[i])\n  a.set_xticklabels([])\n  a.get_yaxis().set_visible(False)\naxes[-1].set_xticklabels(iris.feature_names)\n</code></pre> <p>Is there other alternative to display data with more than 2 input features?</p>"},{"location":"archive/202008/lab6/#additional","title":"Additional","text":"<p>There is a tensorflow playground which tries to visualise the training process of a neural network. It's similar to what we did in this lab.</p>"},{"location":"archive/202008/lab7/","title":"Lab 7: Fuzzy Systems","text":""},{"location":"archive/202008/lab7/#fuzzy-systems","title":"Fuzzy Systems","text":""},{"location":"archive/202008/lab7/#objective","title":"Objective","text":"<ul> <li>to construct a Mamdani fuzzy system using the <code>scikit-fuzzy</code> Python library</li> <li>to evaluate the result of the constructed fuzzy system</li> </ul>"},{"location":"archive/202008/lab7/#note","title":"Note","text":"<p>Install the <code>scikit-fuzzy</code> Python library in your environment before proceeding with the lab.</p> <pre><code>conda install -c conda-forge scikit-fuzzy\n</code></pre>"},{"location":"archive/202008/lab7/#fuzzy-control-system-for-a-train","title":"Fuzzy control system for a train","text":"<ol> <li> <p>Consider a fuzzy control system to control the brake and throttle of a train based on the speed of the train and the distance of the train to the next stop.</p> </li> <li> <p>Import the <code>skfuzzy</code>, <code>skfuzzy.control</code>, and <code>numpy</code>.</p> <pre><code>import numpy as np\nfrom skfuzzy import control as ctrl\nfrom skfuzzy import membership as mf\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab7/#initialise-inputs-and-outputs","title":"Initialise inputs and outputs","text":"<ol> <li> <p>Speed and distance are the inputs of the system whereas brake and throttle are the outputs.</p> </li> <li> <p>The ranges for the variables are:</p> Variable Range Speed 0 - 85 km/h Distance 0 - 3000 m Brake 0 - 100% Throttle 0 - 100% </li> <li> <p>As the inputs will be the antecedents of the rules, construct the variables <code>speed</code> and <code>distance</code> as <code>skfuzzy.control.Antecedent</code> objects. </p> <pre><code>speed = ctrl.Antecedent(np.arange(0, 85, 0.1), 'speed')\n</code></pre> </li> <li> <p>The initialisation function for <code>skfuzzy.control.Antecedent</code> object takes 2 arguments, the first is the universe of the variable, i.e. the values the variables can take, the second is the label of the variable. The initialisation function for <code>skfuzzy.control.Consequent</code> is similar. </p> </li> <li> <p>The label and the range of the variable can be accessed using <code>.label</code> and <code>.universe</code> respectively.</p> </li> </ol> <p>Task: Initialise the variables <code>distance</code> as <code>Antecedent</code> object, and <code>brake</code> and <code>throttle</code> as <code>Consequent</code> objects. (Outputs of the system will be consequents of the rules)</p>"},{"location":"archive/202008/lab7/#define-membership-functions-for-fuzzy-sets-of-variables","title":"Define membership functions for fuzzy sets of variables","text":"<ol> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>speed (0 to 85 km/h)</p> Linguistic value Fit vector Stopped (1/0, 0/2) Very slow (0/1, 1/2.5, 0/4) Slow (0/2.5, 1/6.5, 0/10.5) Medium fast (0/6.5, 1/26.5, 0/46.5) Fast (0/26.5, 1/70, 1/85) </li> <li> <p>distance (0 to 3000 m)</p> Linguistic value Fit vector At (1/0, 0/2) Very near (0/1, 1/3, 0/5) Near (0/3, 1/101.5, 0/200) Medium far (0/100, 1/1550, 0/3000) Far (0/1500, 1/2250, 1/3000) </li> <li> <p>brake (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/40) Very slight (0/20, 1/50, 0/80) Slight (0/70, 1/83.5, 0/97) Medium (0/95, 1/97, 0/99) Full (0/98, 1/100) </li> <li> <p>throttle (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/2) Very slight (0/1, 1/3, 0/5) Slight (0/3, 1/16.5, 0/30) Medium (0/20, 1/50, 0/80) Full (0/60, 1/80, 1/100) </li> </ul> </li> <li> <p>The <code>skfuzzy.membership</code> module provides the following membership functions:</p> Membership function Description <code>skfuzzy.membership.dsigmf(x, b1, c1, b2, c2)</code> Difference of two fuzzy sigmoid membership functions <code>skfuzzy.membership.gauss2mf(x, mean1, ...)</code> Gaussian fuzzy membership function of two combined Gaussians <code>skfuzzy.membership.gaussmf(x, mean, sigma)</code> Gaussian fuzzy membership function <code>skfuzzy.membership.gbellmf(x, a, b, c)</code> Generalized Bell function fuzzy membership generator <code>skfuzzy.membership.piecemf(x, abc)</code> Piecewise linear membership function (particularly used in FIRE filters) <code>skfuzzy.membership.pimf(x, a, b, c, d)</code> Pi-function fuzzy membership generator <code>skfuzzy.membership.psigmf(x, b1, c1, b2, c2)</code> Product of two sigmoid membership functions <code>skfuzzy.membership.sigmf(x, b, c)</code> The basic sigmoid membership function generator <code>skfuzzy.membership.smf(x, a, b)</code> S-function fuzzy membership generator <code>skfuzzy.membership.trapmf(x, abcd)</code> Trapezoidal membership function generator <code>skfuzzy.membership.trimf(x, abc)</code> Triangular membership function generator <code>skfuzzy.membership.zmf(x, a, b)</code> Z-function fuzzy membership generator </li> <li> <p>The fit vector of a linguitic value can be assigned to a linguistic variable using</p> <pre><code>speed['stopped'] = mf.trimf(speed.universe, [0, 0, 2])\nspeed['very slow'] = mf.trimf(speed.universe, [1, 2.5, 4])\n</code></pre> <p>Task: Assign all fuzzy sets to the linguistic variables.</p> </li> <li> <p>The fuzzy set diagram of a linguistic variable can be viewed using <code>.view()</code></p> <pre><code>speed.view()\n</code></pre> <p>Task: Check if the fuzzy set diagrams match the fit vectors.</p> </li> </ol>"},{"location":"archive/202008/lab7/#define-rules","title":"Define rules","text":"<ol> <li> <p>The rules for this system are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Distance At Very near Near Medium far Far Speed Stopped Full brakeNo throttle Full brakeVery slight throttle Very slow Full brakeNo throttle Medium brakeVery slight throttle Slight brakeVery slight throttle Slow Full brakeNo throttle Medium brakeVery slight throttle Very slight brakeSlight throttle Medium fast Very slight brakeMedium throttle No brakeFull throttle Fast Very slight brakeMedium throttle No brakeFull throttle </p> </li> <li> <p>Rule can be defined using <code>skfuzzy.control.Rule(antecedent, consequent, label)</code>. To define the first rule, i.e. if distance is 'at' and speed is 'stopped', then full brake and no throttle, </p> <pre><code>rule1 = ctrl.Rule(distance['at'] &amp; speed['stopped'], (brake['full'], throttle['no']))\n</code></pre> <p>If the antecedent consists of multiple parts, they can be combined using operators <code>|</code> (OR), <code>&amp;</code> (AND), and <code>~</code> (NOT).</p> <p>If the consequent consists of multiple parts, they can be combined as a <code>list</code>/<code>tuple</code>.</p> <p>Task: Define all the rules. Then combine all the rules in a <code>list</code>, i.e. <code>rules = [rule1, rule2, ...]</code>.</p> </li> </ol>"},{"location":"archive/202008/lab7/#construct-the-fuzzy-control-system","title":"Construct the fuzzy control system","text":"<ol> <li> <p>The train control system can be constructed with</p> <pre><code>train_ctrl = ctrl.ControlSystem(rules=rules)\n</code></pre> </li> <li> <p>A <code>skfuzzy.control.ControlSystemSimulation</code> object is needed to simulate the control system to obtain the outputs given certain inputs.</p> <pre><code>train = ctrl.ControlSystemSimulation(control_system=train_ctrl)\n</code></pre> </li> <li> <p>To obtain the values for <code>brake</code> and <code>throttle</code> given that <code>speed</code> is 30 km/h and <code>distance</code> is 6 m,</p> <pre><code># define the values for the inputs\ntrain.input['speed'] = 30\ntrain.input['distance'] = 2000\n\n# compute the outputs\ntrain.compute()\n\n# print the output values\nprint(train.output)\n\n# to extract one of the outputs\nprint(train.output['brake'])\n</code></pre> </li> <li> <p>To view the results in the graph,</p> <pre><code>brake.view(sim=train)\nthrottle.view(sim=train)\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab7/#view-the-controloutput-space","title":"View the control/output space","text":"<ol> <li> <p>The control/output space allows us to identify if the outputs fit our expectation.</p> </li> <li> <p>Construct an empty 3D space with 100-by-100 x-y grid.</p> <pre><code>x, y = np.meshgrid(np.linspace(speed.universe.min(), speed.universe.max(), 100),\n                   np.linspace(distance.universe.min(), distance.universe.max(), 100))\nz_brake = np.zeros_like(x, dtype=float)\nz_throttle = np.zeros_like(x, dtype=float)\n</code></pre> </li> <li> <p>Loop through every point and identify the value of brake and throttle of each point. As the specified rules are not exhaustive, i.e. some input combinations do not activate any rule, we will set the output of such input combinations to be <code>float('inf')</code>.     <pre><code>for i,r in enumerate(x):\n  for j,c in enumerate(r):\n    train.input['speed'] = x[i,j]\n    train.input['distance'] = y[i,j]\n    try:\n      train.compute()\n    except:\n      z_brake[i,j] = float('inf')\n      z_throttle[i,j] = float('inf')\n    z_brake[i,j] = train.output['brake']\n    z_throttle[i,j] = train.output['throttle']\n</code></pre></p> </li> <li> <p>Plot the result in a 3D graph using the <code>matplotlib.pyplot</code> library.</p> <pre><code>import matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndef plot3d(x,y,z):\n  fig = plt.figure()\n  ax = fig.add_subplot(111, projection='3d')\n\n  ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap='viridis', linewidth=0.4, antialiased=True)\n\n  ax.contourf(x, y, z, zdir='z', offset=-2.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='x', offset=x.max()*1.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='y', offset=y.max()*1.5, cmap='viridis', alpha=0.5)\n\n  ax.view_init(30, 200)\n\nplot3d(x, y, z_brake)\nplot3d(x, y, z_throttle)\n</code></pre> </li> </ol>"},{"location":"archive/202008/lab7/#fuzzy-tipping-recommendation-system","title":"Fuzzy tipping recommendation system","text":"<ol> <li> <p>A fuzzy expert system is designed to identify the percentage of tips a customer will give based on the service and the food the customer received.</p> </li> <li> <p>The system has service and food as inputs, and tips as output.</p> </li> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>service (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>food (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>tips (0 to 30%)</p> Linguistic value Fit vector Low (1/0, 0/15) Medium (0/0, 1/15, 0/30) High (0/15, 1/30) </li> </ul> </li> <li> <p>The rules are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Food Poor Average Good Service Poor low tips low tips medium tips Average low tips medium tips high tips Good medium tips high tips high tips </p> </li> </ol> <p>Task: Construct the fuzzy inference system.</p> <p>Task: Modify the membership functions of the input 'service' to</p> Linguistic value Fit vector Poor (1/0, 0/3) Average (0/2, 1/5, 0/8) Good (0/6, 1/10)"},{"location":"archive/202108/lab1/","title":"Lab 1: Pre-lab","text":""},{"location":"archive/202108/lab1/#refresh-on-python","title":"Refresh on Python","text":"<ol> <li> <p>Fibonacci sequence is a series of numbers:</p> <p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</p> <p>The first two numbers are 0 and 1. The rest of the numbers in the sequence is found by summing up two numbers before it.</p> </li> <li> <p>Create a function, in Python, which takes the sequence length sl as the input of the function and prints the Fibonacci sequence of the length sl.</p> <pre><code>def fibonacci(sl):\n  ...\n  return fib_seq\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab1/#random-selection-based-on-probability","title":"Random selection based on probability","text":"<p>For this section. assume the <code>random.random()</code> function selects the random number with even probability.</p> <ol> <li> <p>Consider a coin tossing event. If the probabilities of getting a head or a tail are even, i.e. 50%. Create a Python function which will simulate the coin tossing event and return the result as <code>head</code> or <code>tail</code>.</p> <pre><code>def tossCoin():\n  ...\n  return headOrTail\n</code></pre> </li> <li> <p>If the probabilities of getting a head or a tail are not even, with head as 20% and tail as 80%, how would you change the Python function you created previously to adapt to this coin?</p> </li> <li> <p>Consider the event of selecting one option out of three options randomly. The probability of choosing option <code>A</code> is 20%, <code>B</code> is 50%, and  <code>C</code> is 30%. Create a Python function to simulate the random selection of the options.</p> <pre><code>def chooseFromThree():\n  ...\n  return selectedOption\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab1/#submission","title":"Submission","text":"<p>Submit a Python file with the three functions: <code>fibonacci</code>, <code>tossCoin</code>, and <code>chooseFromThree</code>.</p>"},{"location":"archive/202108/lab2/","title":"Lab 2: EC (GA)","text":""},{"location":"archive/202108/lab2/#binary-to-gray-code-conversion","title":"Binary-to-gray code conversion","text":"<p>Binary string is often used in the implementation of genetic algorithm. However, the downside of using a binary code is that the Hamming distance between two adjacent values is not consistent. This situation is solved by using a Gray code in place of a binary code.</p> <ol> <li> <p><code>numpy</code> provides the function of <code>binary_repr</code> to convert a decimal value to its corresponding binary code.</p> </li> <li> <p>Create a function to take the input of a binary code and return the correponding Gray code of the binary code. </p> </li> <li> <p>Create a function to calculate the Hamming distance between two binary strings (two binary codes or two Gray codes).</p> </li> <li> <p>Consider a sequence of decimal values of <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>. Convert the sequence to a series of binary codes. Identify and plot (example of a line plot) the Hamming distances between the adjacent values.</p> </li> <li> <p>Repeat the previous step with Gray codes instead of binary codes.</p> </li> </ol>"},{"location":"archive/202108/lab2/#genetic-algorithm","title":"Genetic algorithm","text":"<p>Consider the following problem: </p> <p>Problem</p> <p>You are given a sheet of paper with width <code>w</code> and height <code>h</code>. Your task is to cut the paper into squares of equal size. The aim of the task is to have as many squares as possible, and to have the area of each square as large as possible.</p> <ol> <li> <p>An optimisation problem can always be phrased in the form of</p> <p>to optimise ... such that it maximises/minimises ...</p> <p>In this problem, what is the parameter to be optimised and what are the parameters to be maximised or minimised?</p> </li> <li> <p>Let <code>x</code> denotes the length of the sides of a square. Design a fitness function such that higher fitness corresponds to larger number of squares and large area. If the number of squares (that can be cut out) is zero, or the area of the square is zero, the fitness will be zero.</p> </li> </ol> feature encoding population initialisation selection as parents crossover mutation offspring (next generation population) repeat from fitnexx calculation until termination"},{"location":"archive/202108/lab2/#feature-encoding","title":"Feature encoding","text":"<ol> <li> <p>In this problem as we only have one feature, i.e. the side length of the square, each chromosome consists of the value of the side length of the square. We will encode the chromosome in the form of Gray code. </p> </li> <li> <p>Create two functions <code>value2gray</code> and <code>gray2value</code> to convert a decimal value to its Gray code and vice versa.</p> <pre><code>def value2gray(value):\n  # this function converts a decimal value to its gray code representation\n  ...\n  return gray\n\ndef gray2value(gray):\n  # this function converts a gray code representation to its decimal value\n  ...\n  return value\n</code></pre> </li> <li> <p>Add the following code snippet to the end of the code to test your functions.</p> <pre><code>if __name__ == \"__main__\":\n  print(value2gray(10))\n  print(gray2value(\"1001\"))\n</code></pre> <p>After running the file as a script, you should see the following output.</p> <pre><code>1111\n14\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab2/#population-initialisation","title":"Population initialisation","text":"<ol> <li> <p>A population is randomly generated according to the defined population size. </p> </li> <li> <p>Create a function to generate randomly a population of size <code>pop_size</code> with each value lies between the range of <code>pop_min</code> to <code>pop_max</code>.</p> <pre><code>def generatePopulation(pop_size, pop_min, pop_max):\n  # this function generate the first generation randomly based on the population size and the range of the value of each chromosome\n  ...\n  return population\n</code></pre> <p>This function and all the functions created after this should be placed before the <code>if __name__ == \"__main__\":</code> code block.</p> </li> <li> <p>[Optional testing] You can test the function by changing the <code>__main__</code> code block to </p> <pre><code>if __name__ == \"__main__\":\n  print(generatePopulation(8, 0, 10))\n</code></pre> <p>The printed output should be a series of 8 chromosomes displayed as decimal values.</p> </li> </ol>"},{"location":"archive/202108/lab2/#fitness-calculation","title":"Fitness calculation","text":"<ol> <li> <p>The fitness function was designed at the beginning of this section. Define a function that takes the input of a chromosome (as decimal value) and returns the fitness of the chromosome.</p> <p><pre><code>def calculateFitness(value):\n  # this function calculates the fitness of a chromosome from the decimal value of the chromosome\n  ...\n  return fitness\n</code></pre> 2. [Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(calculateFitness(5))\n</code></pre> <p>The printed output should be the fitness of a chromosome of value 5, which would be a decimal value larger than zero.</p> </li> </ol>"},{"location":"archive/202108/lab2/#selection-as-parents","title":"Selection as parents","text":"<ol> <li> <p>From the list of the chromosomes, we will select the chromosome pairs as parents. As we will be using one-point crossover, each pair of parents will produce exactly two offsprings. Therefore for population size of <code>pop_size</code>, we need <code>pop_size/2</code> pairs of parents.</p> </li> <li> <p>Define a function that takes the inputs of the current population and the total number of chromosomes in current population, and returns the chromosome pairs which will act as parents. The selection process is performed with the roulette wheel selection. The same chromosome can be selected more than once.</p> <pre><code>def selectParents(chromosomes, pop_size):\n  ...\n  return parent_pairs\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(selectParents([13, 8, 14, 7], 6))\n</code></pre> <p>The printed output should be 3 parent pairs, for example, </p> <pre><code>[[13, 8], [8, 14], [13, 7]]\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab2/#crossover","title":"Crossover","text":"<ol> <li> <p>Define a function that takes a parent pair and returns a pair of offspring after performing one-point crossover.</p> <pre><code>def crossover(parents):\n  # this function takes a parent pair and perform one-point crossover to produce a pair of offspring\n  ...\n  return offsprings\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(crossover([13, 9]))\n</code></pre> <p>The printed output should be a pair of offsprings, for example,</p> <pre><code>[10, 14]\n</code></pre> <p><code>13</code> is <code>1011</code> and <code>9</code> is <code>1101</code> in Gray code, the offsprings <code>10</code> is <code>1111</code> and <code>14</code> is <code>1001</code> in Gray code.</p> </li> </ol>"},{"location":"archive/202108/lab2/#mutation","title":"Mutation","text":"<ol> <li> <p>Each gene in all chromosomes has the same mutation probability <code>p_mutation</code>. </p> </li> <li> <p>Define a function that takes a chromosome and the mutation probability <code>p_mutation</code> as the inputs, and returns the mutated chromosome. </p> <p><pre><code>def mutate(chromosome, p_mutation):\n  # this function mutates each gene of a chromosome based on the mutation probability\n  ...\n  return mutated\n</code></pre> 3. [Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(mutate(15, 0.1))\n</code></pre> <p>The printed output should be the mutated or unmutated chromosome, for example, <code>14</code>.</p> <p><code>15</code> is <code>1000</code> and <code>14</code> is <code>1001</code> in Gray code. In the example output, the last bit is mutated.</p> </li> </ol>"},{"location":"archive/202108/lab2/#repeat-until-termination","title":"Repeat until termination","text":"<ol> <li> <p>The common termination criteria are the maximum number of iterations and the distance among the fitnesses of the chromosomes of the latest population.</p> </li> <li> <p>Define a function that calculates one metric to measure the distance among the fitnesses of the chromosomes, i.e. how far the fitnesses of all the chromosomes are from each other.</p> <pre><code>def findOverallDistance(chromosomes):\n  # this function takes the input of the current population and returns the overall distance among fitnesses of all chromosomes\n  ...\n  return overall_distance\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(findOverallDistance([13, 11, 14, 7]))\n</code></pre> <p>The printed output should be a decimal value that represents the overall distance of fitnesses.</p> </li> </ol>"},{"location":"archive/202108/lab2/#combining-all-functions","title":"Combining all functions","text":"<ol> <li> <p>The functions we have created can be combined with the following code snippet to execute the genetic algorithm to solve the problem defined at the beginning of this section. Consider the width and the height of the sheet of paper to be <code>20cm</code> and <code>15cm</code>.</p> <pre><code>if __name__ == \"__main__\":\n  # main function\n  ## parameter definition\n  pop_size = 10\n  pop_min = 1 #1cm\n  pop_max = 10 #10cm\n  curr_iter = 0\n  max_iter = 100\n  min_overalldistance = 0.5\n  p_mutation = 0.05\n  ## initialise population\n  population = []\n  population.append(generatePopulation(pop_size, pop_min, pop_max))\n  while (curr_iter &lt; max_iter and findOverallDistance(population[-1]) &gt; min_overalldistance):\n    curr_iter += 1\n    ## select parent pairs\n    parents = selectParents(population[-1], len(population[-1]))\n    ## perform crossover\n    offsprings = []\n    for p in parents:\n      new_offsprings = crossover(p)\n      for o in new_offsprings:\n        offsprings.append(o)\n    ## perform mutation\n    mutated = [mutate(offspring, p_mutation) for offspring in offsprings]\n    ## update current population\n    population.append(mutated)\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab3/","title":"Lab 3: EC (PSO)","text":""},{"location":"archive/202108/lab3/#particle-swarm-optimisation","title":"Particle swarm optimisation","text":""},{"location":"archive/202108/lab3/#objective","title":"Objective","text":"<ul> <li>develop a Python function to perform global best particle swarm optimisation</li> </ul>"},{"location":"archive/202108/lab3/#setup-for-spyder","title":"Setup for Spyder","text":"<ol> <li> <p>If you are using Spyder for this lab, go to Tools &gt; Preferences &gt; IPython console &gt; Graphics and set Backend to Automatic.</p> </li> <li> <p>Restart kernel by going to Consoles &gt; Restart kernel.</p> </li> </ol>"},{"location":"archive/202108/lab3/#problem-to-solve","title":"Problem to solve","text":"<p>Solve the following problem using global best particle swarm optimisation:</p> <p>Problem</p> <p>Find the value of x to minimise the function \\(f(x) = (x+100)(x+50)(x)(x-20)(x-60)(x-100)\\) for \\(-100 &lt; x &lt; 100\\)</p>"},{"location":"archive/202108/lab3/#particle-swarm-optimisation_1","title":"Particle swarm optimisation","text":"particles initialisation personal best identification global best identification velocity calculation position update repeat from personal best identification until termination"},{"location":"archive/202108/lab3/#parameter-definition","title":"Parameter definition","text":"<ol> <li> <p>With global best particle swarm optimisaton, the position update function is given by</p> \\[x_i(t+1) = x_i(t) + v_i(t+1)\\] <p>and the velocity update function is</p> \\[v_i(t+1) = v_i(t) + \\alpha_1\\beta_1(t) \\Big( p_i(t) - x_i(t) \\Big) + \\alpha_2\\beta_2(t)\\Big(p_g(t) - x_i(t)\\Big)\\] </li> <li> <p>\u03b1<sub>1</sub> and \u03b1<sub>2</sub> are acceleration constants that are fixed throughout the algorithm. Define a small value for \u03b1<sub>1</sub> and \u03b1<sub>2</sub>, for example <code>0.1</code>.</p> <pre><code>alpha = [0.1, 0.1]\n</code></pre> </li> <li> <p>\u03b2<sub>1</sub>(t) and \u03b2<sub>2</sub>(t) are random values between <code>0</code> and <code>1</code> that are regenerated every iteration. Therefore no definition is required.</p> </li> <li> <p>Also, define the number of particles to run the algorithm with.</p> <pre><code>n_particle = 10\n</code></pre> </li> <li> <p>Place the definition of these variables in the <code>__main__</code> block.</p> <pre><code>if __name__ == '__main__':\n  alpha = [0.1, 0.1]\n  n_particle = 10\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab3/#create-a-class-for-particle","title":"Create a class for particle","text":"<ol> <li> <p>As each particle is an individual, create a <code>Particle</code> class to hold the data of the particle's current position, velocity, and personal best position.</p> <pre><code>class Particle:\n  def __init__(self, position = 0, velocity = 0):\n    self.position = position\n    self.velocity = velocity\n    self.best_position = position\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab3/#fitness-function","title":"Fitness function","text":"<ol> <li> <p>Fitness function is how we can compare different particles.</p> </li> <li> <p>As our goal is to minimise f(x) as stated in the beginning, we will use f(x) as our fitness function.</p> </li> <li> <p>By using f(x) in minimisation problem, it implies that the lower the value of f(x), the better the particle it is.</p> </li> <li> <p>The value of x is the position of the particle.</p> </li> <li> <p>Define the fitness function as a Python function.</p> <pre><code>def fit_fcn(position):\n  ...\n  return fitness\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab3/#initialise-particles","title":"Initialise particles","text":"<ol> <li> <p>Particles are initialised with random positions within the constraints. </p> </li> <li> <p>At initialisation, we may assume that the initial velocities of all the particles. It is possible to initialise particles with non-zero velocities. For now, we will stick to zero initial velocities.</p> </li> <li> <p>Define a Python function that takes the input of the number of particles and the limits of the positions to initialise and return a list of objects of class <code>Particle</code>. Each particle has random position within the limits and zero velocity.</p> <pre><code>def initialise_particles(n_ptc, position_limits):\n  # position_limits is a list of two values. The first value is the lower boundary and the second value is the upper boundary.\n  ...\n  return particles\n</code></pre> </li> <li> <p>Remember to test your function before proceed.</p> </li> </ol>"},{"location":"archive/202108/lab3/#update-personal-best","title":"Update personal best","text":"<ol> <li> <p>Create a method in the class <code>Particle</code> to update the <code>best_position</code> if necessary.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(self):\n    # 1. calculate the fitnesses of the best_position and the particle's current position\n    # 2. compare the fitnesses and determine if the current position is better than the best_position\n    # 3. update if necessary\n    # 4. no return statement is required\n</code></pre> </li> <li> <p>If the new position has a lower fitness, i.e. the new position is better than the best position, update the <code>best_position</code> to hold the value of the new position.</p> </li> </ol>"},{"location":"archive/202108/lab3/#update-global-best","title":"Update global best","text":"<ol> <li> <p>Initiate a variable named <code>global_best_position</code> with the value <code>None</code> in the <code>__main__</code> block. </p> </li> <li> <p>Create a function that takes two positions as inputs, compare them, and return the better position of the two.</p> <pre><code>def compareFitness(pos1, pos2):\n  # 1. calculate the fitness of pos1 and pos2\n  # 2. compare to determine the better position\n  return betterpos\n</code></pre> </li> <li> <p>We will later use this function to compare the current global best position with the personal best position of each particle.</p> </li> </ol>"},{"location":"archive/202108/lab3/#update-velocity","title":"Update velocity","text":"<ol> <li> <p>Create a method in the class <code>Particle</code> to update the velocity given \u03b1<sub>1</sub>, \u03b1<sub>2</sub>, \u03b2<sub>1</sub>, \u03b2<sub>2</sub>, and the global best position.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(...):\n    ...\n\n  def update_velocity(self, alpha, beta, glob_best_pos):\n    # alpha is a list of two values. we will access alpha_1 and alpha_2 by alpha[0] and alpha[1] respectively. This also applies to beta.\n    # the current position, current velocity, and personal best position of the particle can be accessed by self.position, self.velocity, and self.best_position\n    # assign the particle's velocity with the updated velocity\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab3/#update-particle-position","title":"Update particle position","text":"<ol> <li> <p>As updating a particle position only require information from within the particle object and the limits of the position, create a method called <code>update_position</code> in the class <code>Particle</code> taking the input of the limits of the position.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(...):\n    ...\n\n  def update_velocity(...):\n    ...\n\n  def update_position(self, position_limits):\n    self.position = self.position + self.velocity\n    # how should you solve the problem of the position (x) going out of the limits\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab3/#create-a-loop-until-termination","title":"Create a loop (until termination)","text":"<ol> <li> <p>Consider the following termination criteria:</p> <ul> <li>exceeding 200 iterations</li> <li>fitnesses of all particles are close</li> <li>positions of all particles are close</li> </ul> </li> <li> <p>Create a function to calculate the average difference between the mean fitness and the fitness of each particle.</p> <pre><code>def calc_avg_fit_diff(particles):\n  # 1. calculate mean fitness of all particles\n  # 2. calculate the difference between the mean fitness and the fitness of each particle\n  # 3. calculate the average of the differences obtained from step 2\n  return avg_fit_diff\n</code></pre> </li> <li> <p>Create a function to calculate the average difference between the mean position and the position of each particle.</p> <pre><code>def calc_avg_pos_diff(particles):\n  # 1. calculate mean position of all particles\n  # 2. calculate the difference between the mean position and the position of each particle\n  # 3. calculate the average of the differences obtained from step 2\n  return avg_pos_diff\n</code></pre> </li> <li> <p>Create a loop (in the <code>__main__</code> block) to execute the global best particle swarm optimisation (gbest PSO) until termination. </p> <pre><code>if __name__ == '__main__':\n  # parameter initialisation\n  alpha = [0.1, 0.1]\n  n_particle = 10\n  global_best_position = None\n  position_limits = [-100, 100]\n  # termination threshold\n  iteration = 0\n  max_iter = 200\n  min_avg_fit_diff = 0.1\n  min_avg_pos_diff = 0.1\n  # initialise particles\n  particles = initialise_particles(n_particle, position_limits)\n  while (...): # how should you define the termination criteria here?\n    print(iteration, [round(x.position,2) for x in particles])\n    for particle in particles:\n      # update personal best\n      particle.update_personal_best()\n      # update global best\n      if global_best_position == None:\n        global_best_position = particle.position\n      else:\n        global_best_position = compareFitness(global_best_position, particle.position)\n    # generate beta randomly for current iteration\n    beta = [random.random(), random.random()]\n    for particle in particles:\n      # update velocity\n      particle.update_velocity(alpha, beta, global_best_position)\n      # update position\n      particle.update_position(position_limits)\n    iteration += 1\n  # display results\n  print(iteration, [round(x.position,2) for x in particles])\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab3/#visualisation","title":"Visualisation","text":"<ol> <li> <p>Let's add a few lines to visualise particles \"flying\" towards to optimal position.</p> <ul> <li> <p>import the visualisation library   <pre><code>import matplotlib.pyplot as plt\n</code></pre></p> </li> <li> <p>add the following lines just before the <code>while</code> loop in the last code block in the previous section.   <pre><code>space_ax = plt.axes()\nspace_ax.plot(list(range(*position_limits)),[fit_fcn(x) for x in range(*position_limits)])\nspace_ax.set_title(\"Position of particles in iteration {}\".format(iteration))\nspace_ax.set_xlabel(\"Position\")\nspace_ax.set_ylabel(\"Fitness\")\n</code></pre></p> </li> <li> <p>add the following lines between line 14 and line 15 in the last code block in the previous section, as well as after line 33.   <pre><code>if len(space_ax.lines) &gt; 1:\n  del space_ax.lines[1]\nspace_ax.plot([x.position for x in particles], [fit_fcn(x.position) for x in particles], 'go')\nspace_ax.set_title(\"Position of particles in iteration {}\".format(iteration))\nplt.pause(0.5) # pause the program for 0.5 second; if graph changes too quickly, increase this value; you can also speed up the process by decreasing this value\n</code></pre></p> </li> </ul> </li> </ol>"},{"location":"archive/202108/lab3/#evaluation","title":"Evaluation","text":"<ol> <li> <p>Store the values of the variables at each iteration for analysis and evaluation.</p> <ul> <li>position of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.position_list = [position]\n\n  def update_position(...):\n    ...\n    self.position_list.append(self.position)\n</code></pre> <ul> <li>velocity of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.velocity_list = [velocity]\n\n  def update_velocity(...):\n    ...\n    self.velocity_list.append(self.velocity)\n</code></pre> <ul> <li>personal best position of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.best_position_list = []\n\n  def update_personal_best(...):\n    ...\n    self.best_position_list.append(self.best_position)\n</code></pre> <ul> <li>global best position at each iteration</li> </ul> <pre><code>if __init__ == '__main__':\n  # parameter initialisation\n  ...\n  global_best_position_list = []\n  ...\n        global_best_position = ...\n    global_best_position_list.append(global_best_position) # take note on the indentation\n    # generate beta randomly for current iteration\n    ...\n</code></pre> </li> <li> <p>Visualise the progression of these variables by adding the following code to the end of the <code>__main__</code> block.</p> <pre><code>[pos_fig, position_axes] = plt.subplots(4,1,sharex=True)\nposition_axes[0].set_title(\"Position of each particle\")\nposition_axes[1].set_title(\"Fitness of each particle\")\nposition_axes[2].set_title(\"Boxplot of position at each iteration\")\nposition_axes[3].set_title(\"Boxplot of fitness at each iteration\")\nposition_axes[3].set_xlabel(\"Iteration\")\n[vel_fig, velocity_axes] = plt.subplots(2,1,sharex=True)\nvelocity_axes[0].set_title(\"Velocity of each particle\")\nvelocity_axes[1].set_title(\"Boxplot for velocity at each iteration\")\nvelocity_axes[1].set_xlabel(\"Iteration\")\n[p_best_fig, personal_best_axes] = plt.subplots(4,1,sharex=True)\npersonal_best_axes[0].set_title(\"Personal best position of each particle\")\npersonal_best_axes[1].set_title(\"Personal best fitness of each particle\")\npersonal_best_axes[2].set_title(\"Boxplot of personal best position at each iteration\")\npersonal_best_axes[3].set_title(\"Boxplot of personal best fitness at each iteration\")\npersonal_best_axes[3].set_xlabel(\"Iteration\")\n[g_best_fig, global_best_axes] = plt.subplots(2,1,sharex=True)\nglobal_best_axes[0].set_title(\"Global best position\")\nglobal_best_axes[1].set_title(\"Fitness for global best position\")\nglobal_best_axes[1].set_xlabel(\"Iteration\")\nfor particle in particles:\n  iteration_list = list(range(len(particle.position_list)))\n  position_axes[0].plot(iteration_list, particle.position_list, '-o')\n  position_axes[1].plot(iteration_list, [fit_fcn(x) for x in particle.position_list], '-o')\n\n  velocity_axes[0].plot(iteration_list, particle.velocity_list, '-o')\n\n  personal_best_axes[0].plot(iteration_list[:-1], particle.best_position_list, '-o')\n  personal_best_axes[1].plot(iteration_list[:-1], [fit_fcn(x) for x in particle.best_position_list], '-o')\n\nposition_axes[2].boxplot([[p.position_list[i] for p in particles] for i in iteration_list], positions=iteration_list)\nposition_axes[3].boxplot([[fit_fcn(p.position_list[i]) for p in particles] for i in iteration_list], positions=iteration_list)\n\nvelocity_axes[1].boxplot([[p.velocity_list[i] for p in particles] for i in iteration_list], positions=iteration_list)\n\npersonal_best_axes[2].boxplot([[p.best_position_list[i] for p in particles] for i in iteration_list[:-1]], positions=iteration_list[:-1])\npersonal_best_axes[3].boxplot([[fit_fcn(p.best_position_list[i]) for p in particles] for i in iteration_list[:-1]], positions=iteration_list[:-1])\n\nglobal_best_axes[0].plot(iteration_list[:-1], global_best_position_list, '-o')\nglobal_best_axes[1].plot(iteration_list[:-1], [fit_fcn(x) for x in global_best_position_list], '-o')\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab3/#exercise","title":"Exercise","text":"<ol> <li> <p>Multiply the velocity memory, \\(v_i(t)\\), with a value between 0 and 1, let's say 0.5. How does the process change? This is the effect of inertia weight.</p> </li> <li> <p>Reduce the value of \\(\\alpha_1\\) to 0.05 while maintaining \\(\\alpha_2\\) at 0.1 and investigate the effect. </p> </li> <li> <p>Reduce the value of \\(\\alpha_1\\) to 0. How does this affect the result?</p> </li> <li> <p>Modify such that \\(\\alpha_1\\) is larger than \\(\\alpha_2\\). What's the effect?</p> </li> </ol>"},{"location":"archive/202108/lab3/#optional","title":"Optional","text":"<ol> <li>How may you modify the formulae for particles with two variables, in which the fitness function is defined as \\(f(x,y) = x^2 + y^2\\)? </li> </ol>"},{"location":"archive/202108/lab4/","title":"Lab 4: EC (ACO)","text":""},{"location":"archive/202108/lab4/#ant-colony-optimisation","title":"Ant colony optimisation","text":""},{"location":"archive/202108/lab4/#objective","title":"Objective","text":"<ul> <li>to develop a Python function to perform ant colony optimisation on a problem</li> </ul>"},{"location":"archive/202108/lab4/#problem-to-solve","title":"Problem to solve","text":"<p>We will use ant colony optimisation to solve the Nick's route-finding problem in Romania. The problem is a route finding problem to identify the best (cheapest) route to travel from Arad to Bucharest.</p> <p>The road map of Romania is provided as follows:</p> 75 71 151 140 118 111 70 75 120 146 80 99 97 138 101 211 90 85 98 86 142 92 87 Arad Zerind Oradea Sibiu Fagaras Rimnicu Vilcea Pitesti Craiova Drobeta Mehadia Lugoj Timisoara Bucharest Giurgiu Urziceni Hirsova Eforie Vaslui Iasi Neamt"},{"location":"archive/202108/lab4/#problem-formulation","title":"Problem formulation","text":"<ol> <li> <p>The coordinates of each town are provided as follows. This will be used later for the purpose of visualisation.</p> <pre><code>location_list = [ # [x,y,name]\n  [75, 125, 'Arad'],\n  [100, 75, 'Zerind'],\n  [125, 25, 'Oradea'],\n  [265, 175, 'Sibiu'],\n  [425, 175, 'Fagaras'],\n  [320, 230, 'Rimnicu Vilcea'],\n  [475, 310, 'Pitesti'],\n  [350, 465, 'Craiova'],\n  [185, 450, 'Drobeta'],\n  [190, 390, 'Mehadia'],\n  [185, 335, 'Lugoj'],\n  [85, 280, 'Timisoara'],\n  [640, 390, 'Bucharest'],\n  [575, 485, 'Giurgiu'],\n  [745, 340, 'Urziceni'],\n  [875, 340, 'Hirsova'],\n  [935, 440, 'Eforie'],\n  [850, 225, 'Vaslui'],\n  [760, 120, 'Iasi'],\n  [625, 60, 'Neamt']\n]\n</code></pre> </li> <li> <p>Then define the travel cost between connected cities. </p> <pre><code>step_cost = [\n  ['Arad', 'Zerind', 75],\n  ['Zerind', 'Oradea', 71],\n  ['Oradea', 'Sibiu', 151],\n  ['Sibiu', 'Arad', 140],\n  ['Sibiu', 'Fagaras', 99],\n  ['Sibiu', 'Rimnicu Vilcea', 80],\n  ['Fagaras', 'Bucharest', 211],\n  ['Bucharest', 'Giurgiu', 90],\n  ['Bucharest', 'Pitesti', 101],\n  ['Pitesti', 'Rimnicu Vilcea', 97],\n  ['Rimnicu Vilcea', 'Craiova', 146],\n  ['Craiova', 'Pitesti', 138],\n  ['Craiova', 'Drobeta', 120],\n  ['Drobeta', 'Mehadia', 75],\n  ['Mehadia', 'Lugoj', 70],\n  ['Lugoj', 'Timisoara', 111],\n  ['Arad', 'Timisoara', 118],\n  ['Bucharest', 'Urziceni', 85],\n  ['Urziceni', 'Vaslui', 142],\n  ['Vaslui', 'Iasi', 92],\n  ['Iasi', 'Neamt', 87],\n  ['Urziceni', 'Hirsova', 98],\n  ['Hirsova', 'Eforie', 86]\n]\n</code></pre> </li> <li> <p>We will define two class, <code>City</code> and <code>Road</code>.</p> </li> <li> <p>An object of class <code>City</code> has the attributes of <code>name</code> (the name of the city), <code>roads</code> (an array of references to the roads connected to the current city), and <code>coordinates</code> (coordinates of the cities).</p> <pre><code>class City:\n  def __init__(self, name):\n    self.name = name\n    self.roads = []\n    self.coordinates = []\n\n  def set_coordinates(self, coordinates):\n    self.coordinates = coordinates\n\n  def add_road(self, road):\n    if road not in self.roads:\n      self.roads.append(road)\n</code></pre> </li> <li> <p>An object of class <code>Road</code> has the attributes of <code>connected_cities</code> (an array of references to the cities connected through this road), <code>cost</code> (the step cost of this road), and <code>pheromone</code> (the pheromone on this road).</p> <pre><code>class Road:\n  def __init__(self, connected_cities, cost, pheromone=0):\n    self.connected_cities = connected_cities\n    self.cost = cost\n    self.pheromone = pheromone\n</code></pre> </li> <li> <p>We will construct the list of <code>City</code> objects and <code>Road</code> objects from the information provided by the question, i.e. information in <code>location_list</code> and <code>step_cost</code>. The following code block should be in the <code>main</code> code block.</p> <pre><code>cities = {}\nfor coord1, coord2, name in location_list:\n  cities[name] = City(name)\n  cities[name].set_coordinates([coord1, coord2])\nroads = []\nfor city1, city2, cost in step_cost:\n  road = Road([cities[city1], cities[city2]], cost)\n  cities[city1].add_road(road)\n  cities[city2].add_road(road)\n  roads.append(road)\n</code></pre> </li> <li> <p>In the <code>main</code> code block, define the <code>origin</code> and <code>destination</code> cities.</p> <pre><code>origin = cities['Arad']\ndestination = cities['Bucharest']\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab4/#initiating-aco-algorithm","title":"Initiating ACO algorithm","text":"<ol> <li> <p>We then define the parameters for ACO, i.e. number of ants, <code>n_ant</code>, pheromone influence constant, <code>alpha</code>, and evaporation rate, <code>rho</code>.</p> <pre><code>n_ant = 10\nalpha = 1\nrho = 0.1\n</code></pre> </li> <li> <p>Add the method <code>set_pheromone</code> to the class <code>Road</code>.      <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(self, pheromone):\n    self.pheromone = pheromone\n</code></pre></p> </li> <li> <p>Set the initial pheromone of each road to 0.01.     <pre><code># in main block\ninitial_pheromone = 0.01\nfor road in roads:\n  road.set_pheromone(initial_pheromone)\n</code></pre></p> </li> <li> <p>Define the class <code>Ant</code>.      <pre><code>class Ant:\n  def __init__(self):\n    self.cities = [] # cities the ant passes through, in sequence\n    self.path = [] # roads the ant uses, in sequence\n</code></pre></p> </li> <li> <p>Initiate <code>n_ants</code> ants.     <pre><code>ants = [Ant() for _ in range(n_ant)]\n</code></pre></p> </li> </ol>"},{"location":"archive/202108/lab4/#identify-path-of-each-ant","title":"Identify path of each ant","text":"<ol> <li> <p>In the <code>Ant</code> class, define a method to identify the path by taking the inputs of the available roads, the origin, the destination, and the pheromone influence constant \u03b1.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(self, origin, destination, alpha):\n    # 1. append origin to the self.cities\n    # 2. if the last city is not destination, search for the next city to go\n    # 3. after getting to the destination, remove the loop within the path, i.e. if there are repeated cities in self.cities, remove the cities and the roads in between the repetition\n</code></pre> </li> <li> <p>Define a method to calculate the path length.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(...):\n    ...\n\n  def get_path_length(self):\n    # calculate path length based on self.path\n    return path_length\n</code></pre> </li> <li> <p>As the path of each ant will be reset every iteration, define a method that reset the <code>path</code> and <code>cities</code>.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(...):\n    ...\n\n  def get_path_length(...):\n    ...\n\n  def reset(self):\n    self.path = []\n    self.cities = []\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab4/#evaporation","title":"Evaporation","text":"<ol> <li> <p>In the <code>Road</code> class, define a method to evaporate the pheromone by taking the input of evaporation rate \u03c1.</p> <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(...):\n    ...\n\n  def evaporate_pheromone(self, rho):\n    # update the pheromone of the road\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab4/#deposition","title":"Deposition","text":"<ol> <li> <p>In the <code>Road</code> class, define a method to calculate the updated pheromone after pheromone deposition by taking the input of all the ants. We will use the following pheromone deposition formula for ant \\(k\\) on road \\(i\\):</p> \\[\\Delta\\tau_{i,k} = \\frac{1}{L_k}\\] <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(...):\n    ...\n\n  def evaporate_pheromone(...):\n    ...\n\n  def deposit_pheromone(self, ants):\n    # 1. search for ants that uses the raod\n    # 2. deposit pheromone using the inversely proportionate relationship between path length and deposited pheromone\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab4/#termination-conditions","title":"Termination conditions","text":"<ol> <li> <p>We will use the following conditions as the termination conditions:</p> <ul> <li>maximum iteration of 200</li> <li>if \u226590% of the ants use the same path</li> </ul> </li> <li> <p>Define a function to calculate the percentage of the most dominant path.</p> <pre><code>def get_percentage_of_dominant_path(ants):\n  ...\n  return percentage\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab4/#loop-until-termination","title":"Loop until termination","text":"<ol> <li> <p>Create a loop to iterate until termination.</p> <pre><code># termination threshold\nmax_iteration = 200\npercentage_of_dominant_path = 0.9\n\niteration = 0\nwhile ...: # termination conditions\n  # loop through all the ants to identify the path of each ant\n  for ant in ants:\n    # reset the path of the ant\n    ant.reset()\n    # identify the path of the ant\n    ant.get_path(origin, destination, alpha)\n  # loop through all roads\n  for road in roads:\n    # evaporate the pheromone on the road\n    road.evaporate_pheromone(rho)\n    # deposit the pheromone\n    road.deposit_pheromone(ants)\n  # increase iteration count\n  iteration += 1\n# after exiting the loop, return the most occurred path as the solution\n...\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab4/#visualisation","title":"Visualisation","text":"<ol> <li> <p>Define the following functions:</p> <pre><code>import matplotlib.pyplot as plt\n...\ndef create_graph(cities):\n  fig = plt.figure()\n  ax = fig.add_subplot(1,1,1)\n  cities_x = [city.coordinates[0] for key, city in cities.items()]\n  cities_y = [city.coordinates[1] for key, city in cities.items()]\n  ax.scatter(cities_x, cities_y)\n  ax.set_aspect(aspect=1.0)\n  return ax\n</code></pre> <pre><code>def draw_pheromone(ax, roads):\n  lines = []\n  for road in roads:\n    from_coord = road.connected_cities[0].coordinates\n    to_coord = road.connected_cities[1].coordinates\n    coord_x = [from_coord[0], to_coord[0]]\n    coord_y = [from_coord[1], to_coord[1]]\n    lines.append(ax.plot(coord_x, coord_y, c='k', linewidth=road.pheromone**2))\n  return lines\n</code></pre> </li> <li> <p>Add the following lines to the <code>main</code> code block just before the <code>while</code> loop (loop until termination).</p> <pre><code>ax = create_graph(cities)\nlines = draw_pheromone(ax, roads)\n</code></pre> </li> <li> <p>Add the following lines to after <code>iteration += 1</code>.</p> <pre><code># visualise\nfor l in lines:\n  del l\nlines = draw_pheromone(ax, roads)\nplt.pause(0.05)\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab4/#evaluate-effect-of-parameters","title":"Evaluate effect of parameters","text":"<ol> <li> <p>Modify the pheromone depositing formula to</p> \\[\\Delta\\tau_{i,k} = \\frac{1}{L_k^{1.5}}\\] <p>What is the effect of this?</p> </li> <li> <p>Modify the pheromone depositing formula to</p> \\[\\Delta\\tau_{i,k} = \\frac{5}{L_k}\\] <p>What is the effect of this?</p> </li> <li> <p>Investigate the effect of number of ants <code>n_ant</code>.</p> </li> <li> <p>Investigate the effect of pheromone influence constant \\(\\alpha\\) <code>alpha</code>.</p> </li> <li> <p>Investigate the effect of evaporation rate \\(\\rho\\) <code>rho</code>.</p> </li> </ol>"},{"location":"archive/202108/lab5/","title":"Lab 5: ANN (Supervised learning)","text":""},{"location":"archive/202108/lab5/#artificial-neural-networks","title":"Artificial neural networks","text":""},{"location":"archive/202108/lab5/#objective","title":"Objective","text":"<ul> <li>to construct an multi-layer perceptron classifier using the scikit-learn Python library</li> </ul>"},{"location":"archive/202108/lab5/#load-data-to-be-learned","title":"Load data to be learned","text":"<p>We will be constructing an artificial neural network and use it to perform prediction.</p> <p>The data we will be using today is the results of a chemical analysis of wines grown in the same region in Italy but derived from three different cultivars.</p> <p>The dataset is available from the scikit-learn library. Therefore we will first import the module. <pre><code>from sklearn import datasets\n</code></pre></p> <p>To load the data,  <pre><code>data = datasets.load_wine()\n</code></pre></p>"},{"location":"archive/202108/lab5/#examine-the-dataset","title":"Examine the dataset","text":"<p>We will use pandas to get more insight into the dataset. Import <code>pandas</code> and construct a data frame from the input and target values.</p> <pre><code>import pandas as pd\nwine = pd.DataFrame(data.data, columns=data.feature_names)\nwine['target'] = data.target\n</code></pre> <p>The <code>describe</code> method of a data frame provides the statistical summary of the dataset.</p> <pre><code>print(wine.describe().transpose())\n</code></pre>"},{"location":"archive/202108/lab5/#split-data-into-training-and-testing-sets","title":"Split data into training and testing sets","text":"<p>scikit-learn library provides a function to split the data into training and testing sets easily. </p> <pre><code>from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(data.data, data.target, train_size=0.8)\n</code></pre> <p>We will split the data into 80% training data and 20% testing data. The first argument will be split into the first two outputs, the second argument the second pair, and so on and so forth.</p>"},{"location":"archive/202108/lab5/#data-preprocessing","title":"Data preprocessing","text":"<p>From Examine the dataset, notice that the range of different features are different. This will cause the training algorithm to be difficult to converge. </p> <p>Now we will use the method of standardisation to normalise the data. scikit-learn provides a built-in class to perform the standardisation, <code>StandardScaler</code>.</p> <pre><code>from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\n</code></pre> <p>We will scale the data based on the training data and then apply the scaler to both the training and testing data.</p> <pre><code>scaler.fit(X_train)\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)\n</code></pre> <p>Examine the training input data with the following code:</p> <pre><code>print(pd.DataFrame(X_train, columns=data.feature_names).describe().transpose())\n</code></pre> <p>Compare this result with the one in Examine the dataset. How are these two datasets different from each other? What did the <code>StandardScaler</code> do to the dataset?</p>"},{"location":"archive/202108/lab5/#construct-the-ann-model","title":"Construct the ANN model","text":"<p>As the target values are classes, i.e. <code>0</code>, <code>1</code>, or <code>2</code>, we need a classifier to perform the classification. </p> <pre><code>from sklearn.neural_network import MLPClassifier\n</code></pre> <p>We will construct a feedforward neural network with 1 hidden layer of 2 neuron and maximum iteration of 1000.</p> <pre><code>mlp = MLPClassifier(hidden_layer_sizes=(2), max_iter=1000)\n</code></pre>"},{"location":"archive/202108/lab5/#train-the-model","title":"Train the model","text":"<p>The model can be trained using the <code>fit</code> method of the classifier. </p> <pre><code>mlp.fit(X_train, y_train)\n</code></pre>"},{"location":"archive/202108/lab5/#predictions","title":"Predictions","text":"<p>The model is now trained. We can use the fitted (trained) model to predict the output of the testing data.</p> <pre><code>predictions = mlp.predict(X_test)\n</code></pre>"},{"location":"archive/202108/lab5/#evaluation","title":"Evaluation","text":"<p>With the prediction results, we can evaluate the performance of the fitted model. scikit-learn library provides some built-in metrics such as confusion matrix and classification report.</p> <pre><code>from sklearn.metrics import confusion_matrix, classification_report\n</code></pre> <p>confusion matrix <pre><code>print(confusion_matrix(y_test, predictions))\n</code></pre></p> <p>classification report <pre><code>print(classification_report(y_test, predictions))\n</code></pre></p> <p>What information is provided by the confusion matrix and the classification report?</p>"},{"location":"archive/202108/lab5/#parameters-of-the-fitted-model","title":"Parameters of the fitted model","text":"<p>The parameters of the fitted model (<code>mlp</code>) can be access through its public attributes:</p> attributes definition <code>.coefs_</code> weight matrix <code>.intercepts_</code> bias (threshold) vector <code>.n_iter_</code> number of iterations the solver has ran <code>.n_layers_</code> number of layers <code>.n_outputs_</code> number of outputs"},{"location":"archive/202108/lab5/#visualisation-the-neural-network","title":"Visualisation the neural network","text":"<p>Copy the following code for the function <code>visualise</code> to the beginning of the script.</p> <pre><code>import matplotlib.pyplot as plt\n\ndef visualise(mlp):\n  # get number of neurons in each layer\n  n_neurons = [len(layer) for layer in mlp.coefs_]\n  n_neurons.append(mlp.n_outputs_)\n\n  # calculate the coordinates of each neuron on the graph\n  y_range = [0, max(n_neurons)]\n  x_range = [0, len(n_neurons)]\n  loc_neurons = [[[l, (n+1)*(y_range[1]/(layer+1))] for n in range(layer)] for l,layer in enumerate(n_neurons)]\n  x_neurons = [x for layer in loc_neurons for x,y in layer]\n  y_neurons = [y for layer in loc_neurons for x,y in layer]\n\n  # identify the range of weights\n  weight_range = [min([layer.min() for layer in mlp.coefs_]), max([layer.max() for layer in mlp.coefs_])]\n\n  # prepare the figure\n  fig = plt.figure()\n  ax = fig.add_subplot(1,1,1)\n  # draw the neurons\n  ax.scatter(x_neurons, y_neurons, s=100, zorder=5)\n  # draw the connections with line width corresponds to the weight of the connection\n  for l,layer in enumerate(mlp.coefs_):\n    for i,neuron in enumerate(layer):\n      for j,w in enumerate(neuron):\n        ax.plot([loc_neurons[l][i][0], loc_neurons[l+1][j][0]], [loc_neurons[l][i][1], loc_neurons[l+1][j][1]], 'white', linewidth=((w-weight_range[0])/(weight_range[1]-weight_range[0])*5+0.2)*1.2)\n        ax.plot([loc_neurons[l][i][0], loc_neurons[l+1][j][0]], [loc_neurons[l][i][1], loc_neurons[l+1][j][1]], 'grey', linewidth=(w-weight_range[0])/(weight_range[1]-weight_range[0])*5+0.2)\n</code></pre> <p>To use this function to visualise the neural network, use the following line after the predictions.</p> <pre><code>visualise(mlp)\n</code></pre>"},{"location":"archive/202108/lab5/#compare-the-weights-before-and-after-the-training","title":"Compare the weights before and after the training","text":"<p>At initiation, the weights are not assigned. Therefore we need to train the model once before we can visualise the neural network. We can train the model once using the <code>.partial_fit</code> method. Put the following lines right after the initiation of <code>mlp</code>.</p> <pre><code>mlp.partial_fit(X_train, y_train, np.unique(data.target))\nvisualise(mlp)\n</code></pre> <p>Compare the weights of the two visualisations.</p>"},{"location":"archive/202108/lab5/#effect-of-parameters","title":"Effect of parameters","text":"<p>Investigate the effect of the following parameters on the performance of the neural network and the number of iterations to achieve convergence.</p> <ul> <li>number of hidden layers</li> <li>number of neurons in hidden layers</li> <li>splitting ratio of training and testing sets</li> </ul>"},{"location":"archive/202108/lab6/","title":"Lab 6: ANN (Hyperplane)","text":""},{"location":"archive/202108/lab6/#artificial-neural-networks","title":"Artificial neural networks","text":""},{"location":"archive/202108/lab6/#objective","title":"Objective","text":"<ul> <li>to visualise the hyperplanes of a neural network configuration for better understanding</li> </ul>"},{"location":"archive/202108/lab6/#data-preparation","title":"Data preparation","text":"<p>We will use the iris data for the training in this lab.</p> <pre><code>from sklearn import datasets\niris = datasets.load_iris()\n</code></pre> <p>We will start with using just two input features. <pre><code>X = [[d[1],d[2]] for d in iris.data]\nnames = [iris.target_names[1],iris.target_names[2]]\nY = iris.target\n</code></pre></p>"},{"location":"archive/202108/lab6/#setup-the-first-configuration-for-neural-network","title":"Setup the first configuration for neural network","text":""},{"location":"archive/202108/lab6/#data-preprocessing","title":"Data preprocessing","text":"<ol> <li> <p>Training and testing sets split</p> <pre><code>from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, Y, train_size=0.8)\n</code></pre> </li> <li> <p>Scale the input data based on the training input data</p> <pre><code>from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nscaler.fit(X_train)\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab6/#construct-and-train-the-ann-model","title":"Construct and train the ANN model","text":"<ol> <li> <p>Construct the model</p> <pre><code>from sklearn.neural_network import MLPClassifier\nmlp = MLPClassifier(hidden_layer_sizes=(2), max_iter=1000)\n</code></pre> </li> <li> <p>Train the model</p> <pre><code>mlp.fit(X_train, y_train)\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab6/#visualise-the-classification-of-a-fitted-model","title":"Visualise the classification of a fitted model","text":""},{"location":"archive/202108/lab6/#prepare-the-figure-and-axis","title":"Prepare the figure and axis","text":"<pre><code>import matplotlib.pyplot as plt\nfig = plt.figure()\nax = fig.add_subplot(1,1,1)\n</code></pre>"},{"location":"archive/202108/lab6/#visualisation-function","title":"Visualisation function","text":"<ol> <li> <p>Download the vis.py and save it to the same folder as your script.</p> </li> <li> <p>Import all functions under the namespace of <code>vis</code> <pre><code>import vis\n</code></pre></p> </li> </ol>"},{"location":"archive/202108/lab6/#visualise-the-result","title":"Visualise the result","text":"<p>Use the following code to visualise the decision area of the model. <pre><code>vis.vis2d(ax, mlp, X_train, y_train, X_test, y_test)\n</code></pre></p>"},{"location":"archive/202108/lab6/#setup-the-second-third-and-more-neural-network-configurations","title":"Setup the second, third, and more neural network configurations","text":"<p>We will investigate the effect of using different activation functions on the hyperplane.</p> <p>The activation functions that are available for <code>MLPClassifier</code> are <code>identity</code>, <code>logistic</code>, <code>tanh</code>, and <code>relu</code> (default). They are explained in the documentation.</p> <p>We can use a <code>for</code>-loop to construct and train the neural network model with different configurations. The same datasets from previous sections are used.</p> <pre><code>activation_functions = ['identity', 'logistic', 'tanh', 'relu']\nfig = plt.figure()\nfor i, actfcn in enumerate(activation_functions):\n  mlp = MLPClassifier(hidden_layer_sizes=(3), activation=actfcn, max_iter=1000)\n  mlp.fit(X_train, y_train)\n  ax = fig.add_subplot(1, len(activation_functions), i+1)\n  ax.set_title(actfcn)\n  vis.vis2d(ax, mlp, X_train, y_train, X_test, y_test)\n</code></pre> <p>Apart from the activation functions, let's compare the results of having different number of hidden layers.</p> <pre><code>activation_functions = ['identity', 'logistic', 'tanh', 'relu']\nhidden_layers = [(3), (3,3), (3,3,3)]\nfig = plt.figure()\nfor i,actfcn in enumerate(activation_functions):\n  for j,hlyr in enumerate(hidden_layers):\n    mlp = MLPClassifier(hidden_layer_sizes=hlyr, activation=actfcn, max_iter=1000)\n    mlp.fit(X_train, y_train)\n    ax = fig.add_subplot(len(hidden_layers), len(activation_functions), j*len(activation_functions)+i+1)\n    ax.set_title('{},{},{}'.format(actfcn,str(hlyr),round(mlp.score(X_test,y_test),2)))\n    vis.vis2d(ax, mlp, X_train, y_train, X_test, y_test)\n    ax.set_xticks([])\n    ax.set_yticks([])\n</code></pre> <p><code>mlp.score(X_test, y_test)</code> gives the prediction accuracy of the model on <code>X_test</code> compared against <code>y_test</code>.</p>"},{"location":"archive/202108/lab6/#consider-more-input-features","title":"Consider more input features","text":"<p>We will now use all the input features instead of two. To prepare the data, <pre><code>X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, train_size=0.8)\nscaler.fit(X_train)\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)\n</code></pre></p>"},{"location":"archive/202108/lab6/#construct-and-train-the-model","title":"Construct and train the model","text":"<pre><code>mlp = MLPClassifier(hidden_layer_sizes=(3), max_iter=10000)\nmlp.fit(X_train, y_train)\n</code></pre>"},{"location":"archive/202108/lab6/#visualise-decision-area-with-more-input-features","title":"Visualise decision area with more input features","text":"<p>We will be using parallel coordinates to display data with more than 2 input features. The following is not a complete parallel coordinates plot but a partial one.</p> <pre><code>fig = plt.figure()\naxes = vis.vis3d(fig, mlp, X_train, y_train, X_test, y_test)\nfor i,a in enumerate(axes):\n  a.set_title(iris.target_names[i])\n  a.set_xticklabels([])\n  a.get_yaxis().set_visible(False)\naxes[-1].set_xticklabels(iris.feature_names)\n</code></pre> <p>Is there other alternative to display data with more than 2 input features?</p>"},{"location":"archive/202108/lab6/#additional","title":"Additional","text":"<p>There is a tensorflow playground which tries to visualise the training process of a neural network. It's similar to what we did in this lab.</p>"},{"location":"archive/202108/lab7/","title":"Lab 7: Fuzzy Systems","text":""},{"location":"archive/202108/lab7/#fuzzy-systems","title":"Fuzzy Systems","text":""},{"location":"archive/202108/lab7/#objective","title":"Objective","text":"<ul> <li>to construct a Mamdani fuzzy system using the <code>scikit-fuzzy</code> Python library</li> <li>to evaluate the result of the constructed fuzzy system</li> </ul>"},{"location":"archive/202108/lab7/#note","title":"Note","text":"<p>Install the <code>scikit-fuzzy</code> Python library in your environment before proceeding with the lab.</p> <pre><code>conda install -c conda-forge scikit-fuzzy\n</code></pre>"},{"location":"archive/202108/lab7/#fuzzy-control-system-for-a-train","title":"Fuzzy control system for a train","text":"<ol> <li> <p>Consider a fuzzy control system to control the brake and throttle of a train based on the speed of the train and the distance of the train to the next stop.</p> </li> <li> <p>Import the <code>skfuzzy</code>, <code>skfuzzy.control</code>, and <code>numpy</code>.</p> <pre><code>import numpy as np\nfrom skfuzzy import control as ctrl\nfrom skfuzzy import membership as mf\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab7/#initialise-inputs-and-outputs","title":"Initialise inputs and outputs","text":"<ol> <li> <p>Speed and distance are the inputs of the system whereas brake and throttle are the outputs.</p> </li> <li> <p>The ranges for the variables are:</p> Variable Range Speed 0 - 85 km/h Distance 0 - 3000 m Brake 0 - 100% Throttle 0 - 100% </li> <li> <p>As the inputs will be the antecedents of the rules, construct the variables <code>speed</code> and <code>distance</code> as <code>skfuzzy.control.Antecedent</code> objects. </p> <pre><code>speed = ctrl.Antecedent(np.arange(0, 85, 0.1), 'speed')\n</code></pre> </li> <li> <p>The initialisation function for <code>skfuzzy.control.Antecedent</code> object takes 2 arguments, the first is the universe of the variable, i.e. the values the variables can take, the second is the label of the variable. The initialisation function for <code>skfuzzy.control.Consequent</code> is similar. </p> </li> <li> <p>The label and the range of the variable can be accessed using <code>.label</code> and <code>.universe</code> respectively.</p> </li> </ol> <p>Task: Initialise the variables <code>distance</code> as <code>Antecedent</code> object, and <code>brake</code> and <code>throttle</code> as <code>Consequent</code> objects. (Outputs of the system will be consequents of the rules)</p>"},{"location":"archive/202108/lab7/#define-membership-functions-for-fuzzy-sets-of-variables","title":"Define membership functions for fuzzy sets of variables","text":"<ol> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>speed (0 to 85 km/h)</p> Linguistic value Fit vector Stopped (1/0, 0/2) Very slow (0/1, 1/2.5, 0/4) Slow (0/2.5, 1/6.5, 0/10.5) Medium fast (0/6.5, 1/26.5, 0/46.5) Fast (0/26.5, 1/70, 1/85) </li> <li> <p>distance (0 to 3000 m)</p> Linguistic value Fit vector At (1/0, 0/2) Very near (0/1, 1/3, 0/5) Near (0/3, 1/101.5, 0/200) Medium far (0/100, 1/1550, 0/3000) Far (0/1500, 1/2250, 1/3000) </li> <li> <p>brake (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/40) Very slight (0/20, 1/50, 0/80) Slight (0/70, 1/83.5, 0/97) Medium (0/95, 1/97, 0/99) Full (0/98, 1/100) </li> <li> <p>throttle (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/2) Very slight (0/1, 1/3, 0/5) Slight (0/3, 1/16.5, 0/30) Medium (0/20, 1/50, 0/80) Full (0/60, 1/80, 1/100) </li> </ul> </li> <li> <p>The <code>skfuzzy.membership</code> module provides the following membership functions:</p> Membership function Description <code>skfuzzy.membership.dsigmf(x, b1, c1, b2, c2)</code> Difference of two fuzzy sigmoid membership functions <code>skfuzzy.membership.gauss2mf(x, mean1, ...)</code> Gaussian fuzzy membership function of two combined Gaussians <code>skfuzzy.membership.gaussmf(x, mean, sigma)</code> Gaussian fuzzy membership function <code>skfuzzy.membership.gbellmf(x, a, b, c)</code> Generalized Bell function fuzzy membership generator <code>skfuzzy.membership.piecemf(x, abc)</code> Piecewise linear membership function (particularly used in FIRE filters) <code>skfuzzy.membership.pimf(x, a, b, c, d)</code> Pi-function fuzzy membership generator <code>skfuzzy.membership.psigmf(x, b1, c1, b2, c2)</code> Product of two sigmoid membership functions <code>skfuzzy.membership.sigmf(x, b, c)</code> The basic sigmoid membership function generator <code>skfuzzy.membership.smf(x, a, b)</code> S-function fuzzy membership generator <code>skfuzzy.membership.trapmf(x, abcd)</code> Trapezoidal membership function generator <code>skfuzzy.membership.trimf(x, abc)</code> Triangular membership function generator <code>skfuzzy.membership.zmf(x, a, b)</code> Z-function fuzzy membership generator </li> <li> <p>The fit vector of a linguitic value can be assigned to a linguistic variable using</p> <pre><code>speed['stopped'] = mf.trimf(speed.universe, [0, 0, 2])\nspeed['very slow'] = mf.trimf(speed.universe, [1, 2.5, 4])\n</code></pre> <p>Task: Assign all fuzzy sets to the linguistic variables.</p> </li> <li> <p>The fuzzy set diagram of a linguistic variable can be viewed using <code>.view()</code></p> <pre><code>speed.view()\n</code></pre> <p>Task: Check if the fuzzy set diagrams match the fit vectors.</p> </li> </ol>"},{"location":"archive/202108/lab7/#define-rules","title":"Define rules","text":"<ol> <li> <p>The rules for this system are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Distance At Very near Near Medium far Far Speed Stopped Full brakeNo throttle Full brakeVery slight throttle Very slow Full brakeNo throttle Medium brakeVery slight throttle Slight brakeVery slight throttle Slow Full brakeNo throttle Medium brakeVery slight throttle Very slight brakeSlight throttle Medium fast Very slight brakeMedium throttle No brakeFull throttle Fast Very slight brakeMedium throttle No brakeFull throttle </p> </li> <li> <p>Rule can be defined using <code>skfuzzy.control.Rule(antecedent, consequent, label)</code>. To define the first rule, i.e. if distance is 'at' and speed is 'stopped', then full brake and no throttle, </p> <pre><code>rule1 = ctrl.Rule(distance['at'] &amp; speed['stopped'], (brake['full'], throttle['no']))\n</code></pre> <p>If the antecedent consists of multiple parts, they can be combined using operators <code>|</code> (OR), <code>&amp;</code> (AND), and <code>~</code> (NOT).</p> <p>If the consequent consists of multiple parts, they can be combined as a <code>list</code>/<code>tuple</code>.</p> <p>Task: Define all the rules. Then combine all the rules in a <code>list</code>, i.e. <code>rules = [rule1, rule2, ...]</code>.</p> </li> </ol>"},{"location":"archive/202108/lab7/#construct-the-fuzzy-control-system","title":"Construct the fuzzy control system","text":"<ol> <li> <p>The train control system can be constructed with</p> <pre><code>train_ctrl = ctrl.ControlSystem(rules=rules)\n</code></pre> </li> <li> <p>A <code>skfuzzy.control.ControlSystemSimulation</code> object is needed to simulate the control system to obtain the outputs given certain inputs.</p> <pre><code>train = ctrl.ControlSystemSimulation(control_system=train_ctrl)\n</code></pre> </li> <li> <p>To obtain the values for <code>brake</code> and <code>throttle</code> given that <code>speed</code> is 30 km/h and <code>distance</code> is 6 m,</p> <pre><code># define the values for the inputs\ntrain.input['speed'] = 30\ntrain.input['distance'] = 2000\n\n# compute the outputs\ntrain.compute()\n\n# print the output values\nprint(train.output)\n\n# to extract one of the outputs\nprint(train.output['brake'])\n</code></pre> </li> <li> <p>To view the results in the graph,</p> <pre><code>brake.view(sim=train)\nthrottle.view(sim=train)\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab7/#view-the-controloutput-space","title":"View the control/output space","text":"<ol> <li> <p>The control/output space allows us to identify if the outputs fit our expectation.</p> </li> <li> <p>Construct an empty 3D space with 100-by-100 x-y grid.</p> <pre><code>x, y = np.meshgrid(np.linspace(speed.universe.min(), speed.universe.max(), 100),\n                   np.linspace(distance.universe.min(), distance.universe.max(), 100))\nz_brake = np.zeros_like(x, dtype=float)\nz_throttle = np.zeros_like(x, dtype=float)\n</code></pre> </li> <li> <p>Loop through every point and identify the value of brake and throttle of each point. As the specified rules are not exhaustive, i.e. some input combinations do not activate any rule, we will set the output of such input combinations to be <code>float('inf')</code>.     <pre><code>for i,r in enumerate(x):\n  for j,c in enumerate(r):\n    train.input['speed'] = x[i,j]\n    train.input['distance'] = y[i,j]\n    try:\n      train.compute()\n    except:\n      z_brake[i,j] = float('inf')\n      z_throttle[i,j] = float('inf')\n    z_brake[i,j] = train.output['brake']\n    z_throttle[i,j] = train.output['throttle']\n</code></pre></p> </li> <li> <p>Plot the result in a 3D graph using the <code>matplotlib.pyplot</code> library.</p> <pre><code>import matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndef plot3d(x,y,z):\n  fig = plt.figure()\n  ax = fig.add_subplot(111, projection='3d')\n\n  ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap='viridis', linewidth=0.4, antialiased=True)\n\n  ax.contourf(x, y, z, zdir='z', offset=-2.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='x', offset=x.max()*1.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='y', offset=y.max()*1.5, cmap='viridis', alpha=0.5)\n\n  ax.view_init(30, 200)\n\nplot3d(x, y, z_brake)\nplot3d(x, y, z_throttle)\n</code></pre> </li> </ol>"},{"location":"archive/202108/lab7/#fuzzy-tipping-recommendation-system","title":"Fuzzy tipping recommendation system","text":"<ol> <li> <p>A fuzzy expert system is designed to identify the percentage of tips a customer will give based on the service and the food the customer received.</p> </li> <li> <p>The system has service and food as inputs, and tips as output.</p> </li> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>service (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>food (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>tips (0 to 30%)</p> Linguistic value Fit vector Low (1/0, 0/15) Medium (0/0, 1/15, 0/30) High (0/15, 1/30) </li> </ul> </li> <li> <p>The rules are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Food Poor Average Good Service Poor low tips low tips medium tips Average low tips medium tips high tips Good medium tips high tips high tips </p> </li> </ol> <p>Task: Construct the fuzzy inference system.</p> <p>Task: Modify the membership functions of the input 'service' to</p> Linguistic value Fit vector Poor (1/0, 0/3) Average (0/2, 1/5, 0/8) Good (0/6, 1/10)"},{"location":"archive/202208/lab1/","title":"Lab 1: Pre-lab","text":""},{"location":"archive/202208/lab1/#refresh-on-python","title":"Refresh on Python","text":"<ol> <li> <p>Fibonacci sequence is a series of numbers:</p> <p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</p> <p>The first two numbers are 0 and 1. The rest of the numbers in the sequence is found by summing up two numbers before it.</p> </li> <li> <p>Create a function, in Python, which takes the sequence length sl as the input of the function and prints the Fibonacci sequence of the length sl.</p> <pre><code>def fibonacci(sl):\n  ...\n  return fib_seq\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab1/#random-selection-based-on-probability","title":"Random selection based on probability","text":"<p>For this section. assume the <code>random.random()</code> function selects the random number with even probability.</p> <ol> <li> <p>Consider a coin tossing event. If the probabilities of getting a head or a tail are even, i.e. 50%. Create a Python function which will simulate the coin tossing event and return the result as <code>head</code> or <code>tail</code>.</p> <pre><code>def tossCoin():\n  ...\n  return headOrTail\n</code></pre> </li> <li> <p>If the probabilities of getting a head or a tail are not even, with head as 20% and tail as 80%, how would you change the Python function you created previously to adapt to this coin?</p> </li> <li> <p>Consider the event of selecting one option out of three options randomly. The probability of choosing option <code>A</code> is 20%, <code>B</code> is 50%, and  <code>C</code> is 30%. Create a Python function to simulate the random selection of the options.</p> <pre><code>def chooseFromThree():\n  ...\n  return selectedOption\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab1/#submission","title":"Submission","text":"<p>Submit a Python file with the three functions: <code>fibonacci</code>, <code>tossCoin</code>, and <code>chooseFromThree</code>.</p>"},{"location":"archive/202208/lab2/","title":"Lab 2: EC (GA)","text":""},{"location":"archive/202208/lab2/#binary-to-gray-code-conversion","title":"Binary-to-gray code conversion","text":"<p>Binary string is often used in the implementation of genetic algorithm. However, the downside of using a binary code is that the Hamming distance between two adjacent values is not consistent. This situation is solved by using a Gray code in place of a binary code.</p> <ol> <li> <p><code>numpy</code> provides the function of <code>binary_repr</code> to convert a decimal value to its corresponding binary code.</p> </li> <li> <p>Create a function to take the input of a binary code and return the correponding Gray code of the binary code. </p> </li> <li> <p>Create a function to calculate the Hamming distance between two binary strings (two binary codes or two Gray codes).</p> </li> <li> <p>Consider a sequence of decimal values of <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>. Convert the sequence to a series of binary codes. Identify and plot (example of a line plot) the Hamming distances between the adjacent values.</p> </li> <li> <p>Repeat the previous step with Gray codes instead of binary codes.</p> </li> </ol>"},{"location":"archive/202208/lab2/#genetic-algorithm","title":"Genetic algorithm","text":"<p>Consider the following problem: </p> <p>Problem</p> <p>You are given a sheet of paper with width <code>w</code> and height <code>h</code>. Your task is to cut the paper into squares of equal size. The aim of the task is to have as many squares as possible, and to have the area of each square as large as possible.</p> <ol> <li> <p>An optimisation problem can always be phrased in the form of</p> <p>to optimise ... such that it maximises/minimises ...</p> <p>In this problem, what is the parameter to be optimised and what are the parameters to be maximised or minimised?</p> </li> <li> <p>Let <code>x</code> denotes the length of the sides of a square. Design a fitness function such that higher fitness corresponds to larger number of squares and large area. If the number of squares (that can be cut out) is zero, or the area of the square is zero, the fitness will be zero.</p> </li> </ol> feature encoding population initialisation selection as parents crossover mutation offspring (next generation population) repeat from fitnexx calculation until termination"},{"location":"archive/202208/lab2/#feature-encoding","title":"Feature encoding","text":"<ol> <li> <p>In this problem as we only have one feature, i.e. the side length of the square, each chromosome consists of the value of the side length of the square. We will encode the chromosome in the form of Gray code. </p> </li> <li> <p>Create two functions <code>value2gray</code> and <code>gray2value</code> to convert a decimal value to its Gray code and vice versa.</p> <pre><code>def value2gray(value):\n  # this function converts a decimal value to its gray code representation\n  ...\n  return gray\n\ndef gray2value(gray):\n  # this function converts a gray code representation to its decimal value\n  ...\n  return value\n</code></pre> </li> <li> <p>Add the following code snippet to the end of the code to test your functions.</p> <pre><code>if __name__ == \"__main__\":\n  print(value2gray(10))\n  print(gray2value(\"1001\"))\n</code></pre> <p>After running the file as a script, you should see the following output.</p> <pre><code>1111\n14\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab2/#population-initialisation","title":"Population initialisation","text":"<ol> <li> <p>A population is randomly generated according to the defined population size. </p> </li> <li> <p>Create a function to generate randomly a population of size <code>pop_size</code> with each value lies between the range of <code>pop_min</code> to <code>pop_max</code>.</p> <pre><code>def generatePopulation(pop_size, pop_min, pop_max):\n  # this function generate the first generation randomly based on the population size and the range of the value of each chromosome\n  ...\n  return population\n</code></pre> <p>This function and all the functions created after this should be placed before the <code>if __name__ == \"__main__\":</code> code block.</p> </li> <li> <p>[Optional testing] You can test the function by changing the <code>__main__</code> code block to </p> <pre><code>if __name__ == \"__main__\":\n  print(generatePopulation(8, 0, 10))\n</code></pre> <p>The printed output should be a series of 8 chromosomes displayed as decimal values.</p> </li> </ol>"},{"location":"archive/202208/lab2/#fitness-calculation","title":"Fitness calculation","text":"<ol> <li> <p>The fitness function was designed at the beginning of this section. Define a function that takes the input of a chromosome (as decimal value) and returns the fitness of the chromosome.</p> <p><pre><code>def calculateFitness(value):\n  # this function calculates the fitness of a chromosome from the decimal value of the chromosome\n  ...\n  return fitness\n</code></pre> 2. [Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(calculateFitness(5))\n</code></pre> <p>The printed output should be the fitness of a chromosome of value 5, which would be a decimal value larger than zero.</p> </li> </ol>"},{"location":"archive/202208/lab2/#selection-as-parents","title":"Selection as parents","text":"<ol> <li> <p>From the list of the chromosomes, we will select the chromosome pairs as parents. As we will be using one-point crossover, each pair of parents will produce exactly two offsprings. Therefore for population size of <code>pop_size</code>, we need <code>pop_size/2</code> pairs of parents.</p> </li> <li> <p>Define a function that takes the inputs of the current population and the total number of chromosomes in current population, and returns the chromosome pairs which will act as parents. The selection process is performed with the roulette wheel selection. The same chromosome can be selected more than once.</p> <pre><code>def selectParents(chromosomes, pop_size):\n  ...\n  return parent_pairs\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(selectParents([13, 8, 14, 7], 6))\n</code></pre> <p>The printed output should be 3 parent pairs, for example, </p> <pre><code>[[13, 8], [8, 14], [13, 7]]\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab2/#crossover","title":"Crossover","text":"<ol> <li> <p>Define a function that takes a parent pair and returns a pair of offspring after performing one-point crossover.</p> <pre><code>def crossover(parents):\n  # this function takes a parent pair and perform one-point crossover to produce a pair of offspring\n  ...\n  return offsprings\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(crossover([13, 9]))\n</code></pre> <p>The printed output should be a pair of offsprings, for example,</p> <pre><code>[10, 14]\n</code></pre> <p><code>13</code> is <code>1011</code> and <code>9</code> is <code>1101</code> in Gray code, the offsprings <code>10</code> is <code>1111</code> and <code>14</code> is <code>1001</code> in Gray code.</p> </li> </ol>"},{"location":"archive/202208/lab2/#mutation","title":"Mutation","text":"<ol> <li> <p>Each gene in all chromosomes has the same mutation probability <code>p_mutation</code>. </p> </li> <li> <p>Define a function that takes a chromosome and the mutation probability <code>p_mutation</code> as the inputs, and returns the mutated chromosome. </p> <p><pre><code>def mutate(chromosome, p_mutation):\n  # this function mutates each gene of a chromosome based on the mutation probability\n  ...\n  return mutated\n</code></pre> 3. [Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(mutate(15, 0.1))\n</code></pre> <p>The printed output should be the mutated or unmutated chromosome, for example, <code>14</code>.</p> <p><code>15</code> is <code>1000</code> and <code>14</code> is <code>1001</code> in Gray code. In the example output, the last bit is mutated.</p> </li> </ol>"},{"location":"archive/202208/lab2/#repeat-until-termination","title":"Repeat until termination","text":"<ol> <li> <p>The common termination criteria are the maximum number of iterations and the distance among the fitnesses of the chromosomes of the latest population.</p> </li> <li> <p>Define a function that calculates one metric to measure the distance among the fitnesses of the chromosomes, i.e. how far the fitnesses of all the chromosomes are from each other.</p> <pre><code>def findOverallDistance(chromosomes):\n  # this function takes the input of the current population and returns the overall distance among fitnesses of all chromosomes\n  ...\n  return overall_distance\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(findOverallDistance([13, 11, 14, 7]))\n</code></pre> <p>The printed output should be a decimal value that represents the overall distance of fitnesses.</p> </li> </ol>"},{"location":"archive/202208/lab2/#combining-all-functions","title":"Combining all functions","text":"<ol> <li> <p>The functions we have created can be combined with the following code snippet to execute the genetic algorithm to solve the problem defined at the beginning of this section. Consider the width and the height of the sheet of paper to be <code>20cm</code> and <code>15cm</code>.</p> <pre><code>if __name__ == \"__main__\":\n  # main function\n  ## parameter definition\n  pop_size = 10\n  pop_min = 1 #1cm\n  pop_max = 10 #10cm\n  curr_iter = 0\n  max_iter = 100\n  min_overalldistance = 0.5\n  p_mutation = 0.05\n  ## initialise population\n  population = []\n  population.append(generatePopulation(pop_size, pop_min, pop_max))\n  while (curr_iter &lt; max_iter and findOverallDistance(population[-1]) &gt; min_overalldistance):\n    curr_iter += 1\n    ## select parent pairs\n    parents = selectParents(population[-1], len(population[-1]))\n    ## perform crossover\n    offsprings = []\n    for p in parents:\n      new_offsprings = crossover(p)\n      for o in new_offsprings:\n        offsprings.append(o)\n    ## perform mutation\n    mutated = [mutate(offspring, p_mutation) for offspring in offsprings]\n    ## update current population\n    population.append(mutated)\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab3/","title":"Lab 3: EC (PSO)","text":""},{"location":"archive/202208/lab3/#particle-swarm-optimisation","title":"Particle swarm optimisation","text":""},{"location":"archive/202208/lab3/#objective","title":"Objective","text":"<ul> <li>develop a Python function to perform global best particle swarm optimisation</li> </ul>"},{"location":"archive/202208/lab3/#setup-for-spyder","title":"Setup for Spyder","text":"<ol> <li> <p>If you are using Spyder for this lab, go to Tools &gt; Preferences &gt; IPython console &gt; Graphics and set Backend to Automatic.</p> </li> <li> <p>Restart kernel by going to Consoles &gt; Restart kernel.</p> </li> </ol>"},{"location":"archive/202208/lab3/#problem-to-solve","title":"Problem to solve","text":"<p>Solve the following problem using global best particle swarm optimisation:</p> <p>Problem</p> <p>Find the value of x to minimise the function \\(f(x) = (x+100)(x+50)(x)(x-20)(x-60)(x-100)\\) for \\(-100 &lt; x &lt; 100\\)</p>"},{"location":"archive/202208/lab3/#particle-swarm-optimisation_1","title":"Particle swarm optimisation","text":"particles initialisation personal best identification global best identification velocity calculation position update repeat from personal best identification until termination"},{"location":"archive/202208/lab3/#parameter-definition","title":"Parameter definition","text":"<ol> <li> <p>With global best particle swarm optimisaton, the position update function is given by</p> \\[x_i(t+1) = x_i(t) + v_i(t+1)\\] <p>and the velocity update function is</p> \\[v_i(t+1) = v_i(t) + \\alpha_1\\beta_1(t) \\Big( p_i(t) - x_i(t) \\Big) + \\alpha_2\\beta_2(t)\\Big(p_g(t) - x_i(t)\\Big)\\] </li> <li> <p>\u03b1<sub>1</sub> and \u03b1<sub>2</sub> are acceleration constants that are fixed throughout the algorithm. Define a small value for \u03b1<sub>1</sub> and \u03b1<sub>2</sub>, for example <code>0.1</code>.</p> <pre><code>alpha = [0.1, 0.1]\n</code></pre> </li> <li> <p>\u03b2<sub>1</sub>(t) and \u03b2<sub>2</sub>(t) are random values between <code>0</code> and <code>1</code> that are regenerated every iteration. Therefore no definition is required.</p> </li> <li> <p>Also, define the number of particles to run the algorithm with.</p> <pre><code>n_particle = 10\n</code></pre> </li> <li> <p>Place the definition of these variables in the <code>__main__</code> block.</p> <pre><code>if __name__ == '__main__':\n  alpha = [0.1, 0.1]\n  n_particle = 10\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab3/#create-a-class-for-particle","title":"Create a class for particle","text":"<ol> <li> <p>As each particle is an individual, create a <code>Particle</code> class to hold the data of the particle's current position, velocity, and personal best position.</p> <pre><code>class Particle:\n  def __init__(self, position = 0, velocity = 0):\n    self.position = position\n    self.velocity = velocity\n    self.best_position = position\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab3/#fitness-function","title":"Fitness function","text":"<ol> <li> <p>Fitness function is how we can compare different particles.</p> </li> <li> <p>As our goal is to minimise f(x) as stated in the beginning, we will use f(x) as our fitness function.</p> </li> <li> <p>By using f(x) in minimisation problem, it implies that the lower the value of f(x), the better the particle it is.</p> </li> <li> <p>The value of x is the position of the particle.</p> </li> <li> <p>Define the fitness function as a Python function.</p> <pre><code>def fit_fcn(position):\n  ...\n  return fitness\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab3/#initialise-particles","title":"Initialise particles","text":"<ol> <li> <p>Particles are initialised with random positions within the constraints. </p> </li> <li> <p>At initialisation, we may assume that the initial velocities of all the particles. It is possible to initialise particles with non-zero velocities. For now, we will stick to zero initial velocities.</p> </li> <li> <p>Define a Python function that takes the input of the number of particles and the limits of the positions to initialise and return a list of objects of class <code>Particle</code>. Each particle has random position within the limits and zero velocity.</p> <pre><code>def initialise_particles(n_ptc, position_limits):\n  # position_limits is a list of two values. The first value is the lower boundary and the second value is the upper boundary.\n  ...\n  return particles\n</code></pre> </li> <li> <p>Remember to test your function before proceed.</p> </li> </ol>"},{"location":"archive/202208/lab3/#update-personal-best","title":"Update personal best","text":"<ol> <li> <p>Create a method in the class <code>Particle</code> to update the <code>best_position</code> if necessary.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(self):\n    # 1. calculate the fitnesses of the best_position and the particle's current position\n    # 2. compare the fitnesses and determine if the current position is better than the best_position\n    # 3. update if necessary\n    # 4. no return statement is required\n</code></pre> </li> <li> <p>If the new position has a lower fitness, i.e. the new position is better than the best position, update the <code>best_position</code> to hold the value of the new position.</p> </li> </ol>"},{"location":"archive/202208/lab3/#update-global-best","title":"Update global best","text":"<ol> <li> <p>Initiate a variable named <code>global_best_position</code> with the value <code>None</code> in the <code>__main__</code> block. </p> </li> <li> <p>Create a function that takes two positions as inputs, compare them, and return the better position of the two.</p> <pre><code>def compareFitness(pos1, pos2):\n  # 1. calculate the fitness of pos1 and pos2\n  # 2. compare to determine the better position\n  return betterpos\n</code></pre> </li> <li> <p>We will later use this function to compare the current global best position with the personal best position of each particle.</p> </li> </ol>"},{"location":"archive/202208/lab3/#update-velocity","title":"Update velocity","text":"<ol> <li> <p>Create a method in the class <code>Particle</code> to update the velocity given \u03b1<sub>1</sub>, \u03b1<sub>2</sub>, \u03b2<sub>1</sub>, \u03b2<sub>2</sub>, and the global best position.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(...):\n    ...\n\n  def update_velocity(self, alpha, beta, glob_best_pos):\n    # alpha is a list of two values. we will access alpha_1 and alpha_2 by alpha[0] and alpha[1] respectively. This also applies to beta.\n    # the current position, current velocity, and personal best position of the particle can be accessed by self.position, self.velocity, and self.best_position\n    # assign the particle's velocity with the updated velocity\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab3/#update-particle-position","title":"Update particle position","text":"<ol> <li> <p>As updating a particle position only require information from within the particle object and the limits of the position, create a method called <code>update_position</code> in the class <code>Particle</code> taking the input of the limits of the position.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(...):\n    ...\n\n  def update_velocity(...):\n    ...\n\n  def update_position(self, position_limits):\n    self.position = self.position + self.velocity\n    # how should you solve the problem of the position (x) going out of the limits\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab3/#create-a-loop-until-termination","title":"Create a loop (until termination)","text":"<ol> <li> <p>Consider the following termination criteria:</p> <ul> <li>exceeding 200 iterations</li> <li>fitnesses of all particles are close</li> <li>positions of all particles are close</li> </ul> </li> <li> <p>Create a function to calculate the average difference between the mean fitness and the fitness of each particle.</p> <pre><code>def calc_avg_fit_diff(particles):\n  # 1. calculate mean fitness of all particles\n  # 2. calculate the difference between the mean fitness and the fitness of each particle\n  # 3. calculate the average of the differences obtained from step 2\n  return avg_fit_diff\n</code></pre> </li> <li> <p>Create a function to calculate the average difference between the mean position and the position of each particle.</p> <pre><code>def calc_avg_pos_diff(particles):\n  # 1. calculate mean position of all particles\n  # 2. calculate the difference between the mean position and the position of each particle\n  # 3. calculate the average of the differences obtained from step 2\n  return avg_pos_diff\n</code></pre> </li> <li> <p>Create a loop (in the <code>__main__</code> block) to execute the global best particle swarm optimisation (gbest PSO) until termination. </p> <pre><code>if __name__ == '__main__':\n  # parameter initialisation\n  alpha = [0.1, 0.1]\n  n_particle = 10\n  global_best_position = None\n  position_limits = [-100, 100]\n  # termination threshold\n  iteration = 0\n  max_iter = 200\n  min_avg_fit_diff = 0.1\n  min_avg_pos_diff = 0.1\n  # initialise particles\n  particles = initialise_particles(n_particle, position_limits)\n  while (...): # how should you define the termination criteria here?\n    print(iteration, [round(x.position,2) for x in particles])\n    for particle in particles:\n      # update personal best\n      particle.update_personal_best()\n      # update global best\n      if global_best_position == None:\n        global_best_position = particle.position\n      else:\n        global_best_position = compareFitness(global_best_position, particle.position)\n    # generate beta randomly for current iteration\n    beta = [random.random(), random.random()]\n    for particle in particles:\n      # update velocity\n      particle.update_velocity(alpha, beta, global_best_position)\n      # update position\n      particle.update_position(position_limits)\n    iteration += 1\n  # display results\n  print(iteration, [round(x.position,2) for x in particles])\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab3/#visualisation","title":"Visualisation","text":"<ol> <li> <p>Let's add a few lines to visualise particles \"flying\" towards to optimal position.</p> <ul> <li> <p>import the visualisation library   <pre><code>import matplotlib.pyplot as plt\n</code></pre></p> </li> <li> <p>add the following lines just before the <code>while</code> loop in the last code block in the previous section.   <pre><code>space_ax = plt.axes()\nspace_ax.plot(list(range(*position_limits)),[fit_fcn(x) for x in range(*position_limits)])\nspace_ax.set_title(\"Position of particles in iteration {}\".format(iteration))\nspace_ax.set_xlabel(\"Position\")\nspace_ax.set_ylabel(\"Fitness\")\n</code></pre></p> </li> <li> <p>add the following lines between line 14 and line 15 in the last code block in the previous section, as well as after line 33.   <pre><code>if len(space_ax.lines) &gt; 1:\n  del space_ax.lines[1]\nspace_ax.plot([x.position for x in particles], [fit_fcn(x.position) for x in particles], 'go')\nspace_ax.set_title(\"Position of particles in iteration {}\".format(iteration))\nplt.pause(0.5) # pause the program for 0.5 second; if graph changes too quickly, increase this value; you can also speed up the process by decreasing this value\n</code></pre></p> </li> </ul> </li> </ol>"},{"location":"archive/202208/lab3/#evaluation","title":"Evaluation","text":"<ol> <li> <p>Store the values of the variables at each iteration for analysis and evaluation.</p> <ul> <li>position of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.position_list = [position]\n\n  def update_position(...):\n    ...\n    self.position_list.append(self.position)\n</code></pre> <ul> <li>velocity of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.velocity_list = [velocity]\n\n  def update_velocity(...):\n    ...\n    self.velocity_list.append(self.velocity)\n</code></pre> <ul> <li>personal best position of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.best_position_list = []\n\n  def update_personal_best(...):\n    ...\n    self.best_position_list.append(self.best_position)\n</code></pre> <ul> <li>global best position at each iteration</li> </ul> <pre><code>if __init__ == '__main__':\n  # parameter initialisation\n  ...\n  global_best_position_list = []\n  ...\n        global_best_position = ...\n    global_best_position_list.append(global_best_position) # take note on the indentation\n    # generate beta randomly for current iteration\n    ...\n</code></pre> </li> <li> <p>Visualise the progression of these variables by adding the following code to the end of the <code>__main__</code> block.</p> <pre><code>[pos_fig, position_axes] = plt.subplots(4,1,sharex=True)\nposition_axes[0].set_title(\"Position of each particle\")\nposition_axes[1].set_title(\"Fitness of each particle\")\nposition_axes[2].set_title(\"Boxplot of position at each iteration\")\nposition_axes[3].set_title(\"Boxplot of fitness at each iteration\")\nposition_axes[3].set_xlabel(\"Iteration\")\n[vel_fig, velocity_axes] = plt.subplots(2,1,sharex=True)\nvelocity_axes[0].set_title(\"Velocity of each particle\")\nvelocity_axes[1].set_title(\"Boxplot for velocity at each iteration\")\nvelocity_axes[1].set_xlabel(\"Iteration\")\n[p_best_fig, personal_best_axes] = plt.subplots(4,1,sharex=True)\npersonal_best_axes[0].set_title(\"Personal best position of each particle\")\npersonal_best_axes[1].set_title(\"Personal best fitness of each particle\")\npersonal_best_axes[2].set_title(\"Boxplot of personal best position at each iteration\")\npersonal_best_axes[3].set_title(\"Boxplot of personal best fitness at each iteration\")\npersonal_best_axes[3].set_xlabel(\"Iteration\")\n[g_best_fig, global_best_axes] = plt.subplots(2,1,sharex=True)\nglobal_best_axes[0].set_title(\"Global best position\")\nglobal_best_axes[1].set_title(\"Fitness for global best position\")\nglobal_best_axes[1].set_xlabel(\"Iteration\")\nfor particle in particles:\n  iteration_list = list(range(len(particle.position_list)))\n  position_axes[0].plot(iteration_list, particle.position_list, '-o')\n  position_axes[1].plot(iteration_list, [fit_fcn(x) for x in particle.position_list], '-o')\n\n  velocity_axes[0].plot(iteration_list, particle.velocity_list, '-o')\n\n  personal_best_axes[0].plot(iteration_list[:-1], particle.best_position_list, '-o')\n  personal_best_axes[1].plot(iteration_list[:-1], [fit_fcn(x) for x in particle.best_position_list], '-o')\n\nposition_axes[2].boxplot([[p.position_list[i] for p in particles] for i in iteration_list], positions=iteration_list)\nposition_axes[3].boxplot([[fit_fcn(p.position_list[i]) for p in particles] for i in iteration_list], positions=iteration_list)\n\nvelocity_axes[1].boxplot([[p.velocity_list[i] for p in particles] for i in iteration_list], positions=iteration_list)\n\npersonal_best_axes[2].boxplot([[p.best_position_list[i] for p in particles] for i in iteration_list[:-1]], positions=iteration_list[:-1])\npersonal_best_axes[3].boxplot([[fit_fcn(p.best_position_list[i]) for p in particles] for i in iteration_list[:-1]], positions=iteration_list[:-1])\n\nglobal_best_axes[0].plot(iteration_list[:-1], global_best_position_list, '-o')\nglobal_best_axes[1].plot(iteration_list[:-1], [fit_fcn(x) for x in global_best_position_list], '-o')\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab3/#exercise","title":"Exercise","text":"<ol> <li> <p>Multiply the velocity memory, \\(v_i(t)\\), with a value between 0 and 1, let's say 0.5. How does the process change? This is the effect of inertia weight.</p> </li> <li> <p>Reduce the value of \\(\\alpha_1\\) to 0.05 while maintaining \\(\\alpha_2\\) at 0.1 and investigate the effect. </p> </li> <li> <p>Reduce the value of \\(\\alpha_1\\) to 0. How does this affect the result?</p> </li> <li> <p>Modify such that \\(\\alpha_1\\) is larger than \\(\\alpha_2\\). What's the effect?</p> </li> </ol>"},{"location":"archive/202208/lab3/#optional","title":"Optional","text":"<ol> <li>How may you modify the formulae for particles with two variables, in which the fitness function is defined as \\(f(x,y) = x^2 + y^2\\)? </li> </ol>"},{"location":"archive/202208/lab4/","title":"Lab 4: EC (ACO)","text":""},{"location":"archive/202208/lab4/#ant-colony-optimisation","title":"Ant colony optimisation","text":""},{"location":"archive/202208/lab4/#objective","title":"Objective","text":"<ul> <li>to develop a Python function to perform ant colony optimisation on a problem</li> </ul>"},{"location":"archive/202208/lab4/#problem-to-solve","title":"Problem to solve","text":"<p>We will use ant colony optimisation to solve the Nick's route-finding problem in Romania. The problem is a route finding problem to identify the best (cheapest) route to travel from Arad to Bucharest.</p> <p>The road map of Romania is provided as follows:</p> 75 71 151 140 118 111 70 75 120 146 80 99 97 138 101 211 90 85 98 86 142 92 87 Arad Zerind Oradea Sibiu Fagaras Rimnicu Vilcea Pitesti Craiova Drobeta Mehadia Lugoj Timisoara Bucharest Giurgiu Urziceni Hirsova Eforie Vaslui Iasi Neamt"},{"location":"archive/202208/lab4/#problem-formulation","title":"Problem formulation","text":"<ol> <li> <p>The coordinates of each town are provided as follows. This will be used later for the purpose of visualisation.</p> <pre><code>location_list = [ # [x,y,name]\n  [75, 125, 'Arad'],\n  [100, 75, 'Zerind'],\n  [125, 25, 'Oradea'],\n  [265, 175, 'Sibiu'],\n  [425, 175, 'Fagaras'],\n  [320, 230, 'Rimnicu Vilcea'],\n  [475, 310, 'Pitesti'],\n  [350, 465, 'Craiova'],\n  [185, 450, 'Drobeta'],\n  [190, 390, 'Mehadia'],\n  [185, 335, 'Lugoj'],\n  [85, 280, 'Timisoara'],\n  [640, 390, 'Bucharest'],\n  [575, 485, 'Giurgiu'],\n  [745, 340, 'Urziceni'],\n  [875, 340, 'Hirsova'],\n  [935, 440, 'Eforie'],\n  [850, 225, 'Vaslui'],\n  [760, 120, 'Iasi'],\n  [625, 60, 'Neamt']\n]\n</code></pre> </li> <li> <p>Then define the travel cost between connected cities. </p> <pre><code>step_cost = [\n  ['Arad', 'Zerind', 75],\n  ['Zerind', 'Oradea', 71],\n  ['Oradea', 'Sibiu', 151],\n  ['Sibiu', 'Arad', 140],\n  ['Sibiu', 'Fagaras', 99],\n  ['Sibiu', 'Rimnicu Vilcea', 80],\n  ['Fagaras', 'Bucharest', 211],\n  ['Bucharest', 'Giurgiu', 90],\n  ['Bucharest', 'Pitesti', 101],\n  ['Pitesti', 'Rimnicu Vilcea', 97],\n  ['Rimnicu Vilcea', 'Craiova', 146],\n  ['Craiova', 'Pitesti', 138],\n  ['Craiova', 'Drobeta', 120],\n  ['Drobeta', 'Mehadia', 75],\n  ['Mehadia', 'Lugoj', 70],\n  ['Lugoj', 'Timisoara', 111],\n  ['Arad', 'Timisoara', 118],\n  ['Bucharest', 'Urziceni', 85],\n  ['Urziceni', 'Vaslui', 142],\n  ['Vaslui', 'Iasi', 92],\n  ['Iasi', 'Neamt', 87],\n  ['Urziceni', 'Hirsova', 98],\n  ['Hirsova', 'Eforie', 86]\n]\n</code></pre> </li> <li> <p>We will define two class, <code>City</code> and <code>Road</code>.</p> </li> <li> <p>An object of class <code>City</code> has the attributes of <code>name</code> (the name of the city), <code>roads</code> (an array of references to the roads connected to the current city), and <code>coordinates</code> (coordinates of the cities).</p> <pre><code>class City:\n  def __init__(self, name):\n    self.name = name\n    self.roads = []\n    self.coordinates = []\n\n  def set_coordinates(self, coordinates):\n    self.coordinates = coordinates\n\n  def add_road(self, road):\n    if road not in self.roads:\n      self.roads.append(road)\n</code></pre> </li> <li> <p>An object of class <code>Road</code> has the attributes of <code>connected_cities</code> (an array of references to the cities connected through this road), <code>cost</code> (the step cost of this road), and <code>pheromone</code> (the pheromone on this road).</p> <pre><code>class Road:\n  def __init__(self, connected_cities, cost, pheromone=0):\n    self.connected_cities = connected_cities\n    self.cost = cost\n    self.pheromone = pheromone\n</code></pre> </li> <li> <p>We will construct the list of <code>City</code> objects and <code>Road</code> objects from the information provided by the question, i.e. information in <code>location_list</code> and <code>step_cost</code>. The following code block should be in the <code>main</code> code block.</p> <pre><code>cities = {}\nfor coord1, coord2, name in location_list:\n  cities[name] = City(name)\n  cities[name].set_coordinates([coord1, coord2])\nroads = []\nfor city1, city2, cost in step_cost:\n  road = Road([cities[city1], cities[city2]], cost)\n  cities[city1].add_road(road)\n  cities[city2].add_road(road)\n  roads.append(road)\n</code></pre> </li> <li> <p>In the <code>main</code> code block, define the <code>origin</code> and <code>destination</code> cities.</p> <pre><code>origin = cities['Arad']\ndestination = cities['Bucharest']\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab4/#initiating-aco-algorithm","title":"Initiating ACO algorithm","text":"<ol> <li> <p>We then define the parameters for ACO, i.e. number of ants, <code>n_ant</code>, pheromone influence constant, <code>alpha</code>, and evaporation rate, <code>rho</code>.</p> <pre><code>n_ant = 10\nalpha = 1\nrho = 0.1\n</code></pre> </li> <li> <p>Add the method <code>set_pheromone</code> to the class <code>Road</code>.      <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(self, pheromone):\n    self.pheromone = pheromone\n</code></pre></p> </li> <li> <p>Set the initial pheromone of each road to 0.01.     <pre><code># in main block\ninitial_pheromone = 0.01\nfor road in roads:\n  road.set_pheromone(initial_pheromone)\n</code></pre></p> </li> <li> <p>Define the class <code>Ant</code>.      <pre><code>class Ant:\n  def __init__(self):\n    self.cities = [] # cities the ant passes through, in sequence\n    self.path = [] # roads the ant uses, in sequence\n</code></pre></p> </li> <li> <p>Initiate <code>n_ants</code> ants.     <pre><code>ants = [Ant() for _ in range(n_ant)]\n</code></pre></p> </li> </ol>"},{"location":"archive/202208/lab4/#identify-path-of-each-ant","title":"Identify path of each ant","text":"<ol> <li> <p>In the <code>Ant</code> class, define a method to identify the path by taking the inputs of the available roads, the origin, the destination, and the pheromone influence constant \u03b1.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(self, origin, destination, alpha):\n    # 1. append origin to the self.cities\n    # 2. if the last city is not destination, search for the next city to go\n    # 3. after getting to the destination, remove the loop within the path, i.e. if there are repeated cities in self.cities, remove the cities and the roads in between the repetition\n</code></pre> </li> <li> <p>Define a method to calculate the path length.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(...):\n    ...\n\n  def get_path_length(self):\n    # calculate path length based on self.path\n    return path_length\n</code></pre> </li> <li> <p>As the path of each ant will be reset every iteration, define a method that reset the <code>path</code> and <code>cities</code>.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(...):\n    ...\n\n  def get_path_length(...):\n    ...\n\n  def reset(self):\n    self.path = []\n    self.cities = []\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab4/#evaporation","title":"Evaporation","text":"<ol> <li> <p>In the <code>Road</code> class, define a method to evaporate the pheromone by taking the input of evaporation rate \u03c1.</p> <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(...):\n    ...\n\n  def evaporate_pheromone(self, rho):\n    # update the pheromone of the road\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab4/#deposition","title":"Deposition","text":"<ol> <li> <p>In the <code>Road</code> class, define a method to calculate the updated pheromone after pheromone deposition by taking the input of all the ants. We will use the following pheromone deposition formula for ant \\(k\\) on road \\(i\\):</p> \\[\\Delta\\tau_{i,k} = \\frac{1}{L_k}\\] <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(...):\n    ...\n\n  def evaporate_pheromone(...):\n    ...\n\n  def deposit_pheromone(self, ants):\n    # 1. search for ants that uses the raod\n    # 2. deposit pheromone using the inversely proportionate relationship between path length and deposited pheromone\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab4/#termination-conditions","title":"Termination conditions","text":"<ol> <li> <p>We will use the following conditions as the termination conditions:</p> <ul> <li>maximum iteration of 200</li> <li>if \u226590% of the ants use the same path</li> </ul> </li> <li> <p>Define a function to calculate the percentage of the most dominant path.</p> <pre><code>def get_percentage_of_dominant_path(ants):\n  ...\n  return percentage\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab4/#loop-until-termination","title":"Loop until termination","text":"<ol> <li> <p>Create a loop to iterate until termination.</p> <pre><code># termination threshold\nmax_iteration = 200\npercentage_of_dominant_path = 0.9\n\niteration = 0\nwhile ...: # termination conditions\n  # loop through all the ants to identify the path of each ant\n  for ant in ants:\n    # reset the path of the ant\n    ant.reset()\n    # identify the path of the ant\n    ant.get_path(origin, destination, alpha)\n  # loop through all roads\n  for road in roads:\n    # evaporate the pheromone on the road\n    road.evaporate_pheromone(rho)\n    # deposit the pheromone\n    road.deposit_pheromone(ants)\n  # increase iteration count\n  iteration += 1\n# after exiting the loop, return the most occurred path as the solution\n...\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab4/#visualisation","title":"Visualisation","text":"<ol> <li> <p>Define the following functions:</p> <pre><code>import matplotlib.pyplot as plt\n...\ndef create_graph(cities):\n  fig = plt.figure()\n  ax = fig.add_subplot(1,1,1)\n  cities_x = [city.coordinates[0] for key, city in cities.items()]\n  cities_y = [city.coordinates[1] for key, city in cities.items()]\n  ax.scatter(cities_x, cities_y)\n  ax.set_aspect(aspect=1.0)\n  return ax\n</code></pre> <pre><code>def draw_pheromone(ax, roads):\n  lines = []\n  for road in roads:\n    from_coord = road.connected_cities[0].coordinates\n    to_coord = road.connected_cities[1].coordinates\n    coord_x = [from_coord[0], to_coord[0]]\n    coord_y = [from_coord[1], to_coord[1]]\n    lines.append(ax.plot(coord_x, coord_y, c='k', linewidth=road.pheromone**2))\n  return lines\n</code></pre> </li> <li> <p>Add the following lines to the <code>main</code> code block just before the <code>while</code> loop (loop until termination).</p> <pre><code>ax = create_graph(cities)\nlines = draw_pheromone(ax, roads)\n</code></pre> </li> <li> <p>Add the following lines to after <code>iteration += 1</code>.</p> <pre><code># visualise\nfor l in lines:\n  del l\nlines = draw_pheromone(ax, roads)\nplt.pause(0.05)\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab4/#evaluate-effect-of-parameters","title":"Evaluate effect of parameters","text":"<ol> <li> <p>Modify the pheromone depositing formula to</p> \\[\\Delta\\tau_{i,k} = \\frac{1}{L_k^{1.5}}\\] <p>What is the effect of this?</p> </li> <li> <p>Modify the pheromone depositing formula to</p> \\[\\Delta\\tau_{i,k} = \\frac{5}{L_k}\\] <p>What is the effect of this?</p> </li> <li> <p>Investigate the effect of number of ants <code>n_ant</code>.</p> </li> <li> <p>Investigate the effect of pheromone influence constant \\(\\alpha\\) <code>alpha</code>.</p> </li> <li> <p>Investigate the effect of evaporation rate \\(\\rho\\) <code>rho</code>.</p> </li> </ol>"},{"location":"archive/202208/lab5/","title":"Lab 5: ANN (Supervised learning)","text":""},{"location":"archive/202208/lab5/#artificial-neural-networks","title":"Artificial neural networks","text":""},{"location":"archive/202208/lab5/#objective","title":"Objective","text":"<ul> <li>to construct an multi-layer perceptron classifier using the scikit-learn Python library</li> </ul>"},{"location":"archive/202208/lab5/#load-data-to-be-learned","title":"Load data to be learned","text":"<p>We will be constructing an artificial neural network and use it to perform prediction.</p> <p>The data we will be using today is the results of a chemical analysis of wines grown in the same region in Italy but derived from three different cultivars.</p> <p>The dataset is available from the scikit-learn library. Therefore we will first import the module. <pre><code>from sklearn import datasets\n</code></pre></p> <p>To load the data,  <pre><code>data = datasets.load_wine()\n</code></pre></p>"},{"location":"archive/202208/lab5/#examine-the-dataset","title":"Examine the dataset","text":"<p>We will use pandas to get more insight into the dataset. Import <code>pandas</code> and construct a data frame from the input and target values.</p> <pre><code>import pandas as pd\nwine = pd.DataFrame(data.data, columns=data.feature_names)\nwine['target'] = data.target\n</code></pre> <p>The <code>describe</code> method of a data frame provides the statistical summary of the dataset.</p> <pre><code>print(wine.describe().transpose())\n</code></pre>"},{"location":"archive/202208/lab5/#split-data-into-training-and-testing-sets","title":"Split data into training and testing sets","text":"<p>scikit-learn library provides a function to split the data into training and testing sets easily. </p> <pre><code>from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(data.data, data.target, train_size=0.8)\n</code></pre> <p>We will split the data into 80% training data and 20% testing data. The first argument will be split into the first two outputs, the second argument the second pair, and so on and so forth.</p>"},{"location":"archive/202208/lab5/#data-preprocessing","title":"Data preprocessing","text":"<p>From Examine the dataset, notice that the range of different features are different. This will cause the training algorithm to be difficult to converge. </p> <p>Now we will use the method of standardisation to normalise the data. scikit-learn provides a built-in class to perform the standardisation, <code>StandardScaler</code>.</p> <pre><code>from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\n</code></pre> <p>We will scale the data based on the training data and then apply the scaler to both the training and testing data.</p> <pre><code>scaler.fit(X_train)\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)\n</code></pre> <p>Examine the training input data with the following code:</p> <pre><code>print(pd.DataFrame(X_train, columns=data.feature_names).describe().transpose())\n</code></pre> <p>Compare this result with the one in Examine the dataset. How are these two datasets different from each other? What did the <code>StandardScaler</code> do to the dataset?</p>"},{"location":"archive/202208/lab5/#construct-the-ann-model","title":"Construct the ANN model","text":"<p>As the target values are classes, i.e. <code>0</code>, <code>1</code>, or <code>2</code>, we need a classifier to perform the classification. </p> <pre><code>from sklearn.neural_network import MLPClassifier\n</code></pre> <p>We will construct a feedforward neural network with 1 hidden layer of 2 neuron and maximum iteration of 1000.</p> <pre><code>mlp = MLPClassifier(hidden_layer_sizes=(2), max_iter=1000)\n</code></pre>"},{"location":"archive/202208/lab5/#train-the-model","title":"Train the model","text":"<p>The model can be trained using the <code>fit</code> method of the classifier. </p> <pre><code>mlp.fit(X_train, y_train)\n</code></pre>"},{"location":"archive/202208/lab5/#predictions","title":"Predictions","text":"<p>The model is now trained. We can use the fitted (trained) model to predict the output of the testing data.</p> <pre><code>predictions = mlp.predict(X_test)\n</code></pre>"},{"location":"archive/202208/lab5/#evaluation","title":"Evaluation","text":"<p>With the prediction results, we can evaluate the performance of the fitted model. scikit-learn library provides some built-in metrics such as confusion matrix and classification report.</p> <pre><code>from sklearn.metrics import confusion_matrix, classification_report\n</code></pre> <p>confusion matrix <pre><code>print(confusion_matrix(y_test, predictions))\n</code></pre></p> <p>classification report <pre><code>print(classification_report(y_test, predictions))\n</code></pre></p> <p>What information is provided by the confusion matrix and the classification report?</p>"},{"location":"archive/202208/lab5/#parameters-of-the-fitted-model","title":"Parameters of the fitted model","text":"<p>The parameters of the fitted model (<code>mlp</code>) can be access through its public attributes:</p> attributes definition <code>.coefs_</code> weight matrix <code>.intercepts_</code> bias (threshold) vector <code>.n_iter_</code> number of iterations the solver has ran <code>.n_layers_</code> number of layers <code>.n_outputs_</code> number of outputs"},{"location":"archive/202208/lab5/#visualisation-the-neural-network","title":"Visualisation the neural network","text":"<p>Copy the following code for the function <code>visualise</code> to the beginning of the script.</p> <pre><code>import matplotlib.pyplot as plt\n\ndef visualise(mlp):\n  # get number of neurons in each layer\n  n_neurons = [len(layer) for layer in mlp.coefs_]\n  n_neurons.append(mlp.n_outputs_)\n\n  # calculate the coordinates of each neuron on the graph\n  y_range = [0, max(n_neurons)]\n  x_range = [0, len(n_neurons)]\n  loc_neurons = [[[l, (n+1)*(y_range[1]/(layer+1))] for n in range(layer)] for l,layer in enumerate(n_neurons)]\n  x_neurons = [x for layer in loc_neurons for x,y in layer]\n  y_neurons = [y for layer in loc_neurons for x,y in layer]\n\n  # identify the range of weights\n  weight_range = [min([layer.min() for layer in mlp.coefs_]), max([layer.max() for layer in mlp.coefs_])]\n\n  # prepare the figure\n  fig = plt.figure()\n  ax = fig.add_subplot(1,1,1)\n  # draw the neurons\n  ax.scatter(x_neurons, y_neurons, s=100, zorder=5)\n  # draw the connections with line width corresponds to the weight of the connection\n  for l,layer in enumerate(mlp.coefs_):\n    for i,neuron in enumerate(layer):\n      for j,w in enumerate(neuron):\n        ax.plot([loc_neurons[l][i][0], loc_neurons[l+1][j][0]], [loc_neurons[l][i][1], loc_neurons[l+1][j][1]], 'white', linewidth=((w-weight_range[0])/(weight_range[1]-weight_range[0])*5+0.2)*1.2)\n        ax.plot([loc_neurons[l][i][0], loc_neurons[l+1][j][0]], [loc_neurons[l][i][1], loc_neurons[l+1][j][1]], 'grey', linewidth=(w-weight_range[0])/(weight_range[1]-weight_range[0])*5+0.2)\n</code></pre> <p>To use this function to visualise the neural network, use the following line after the predictions.</p> <pre><code>visualise(mlp)\n</code></pre>"},{"location":"archive/202208/lab5/#compare-the-weights-before-and-after-the-training","title":"Compare the weights before and after the training","text":"<p>At initiation, the weights are not assigned. Therefore we need to train the model once before we can visualise the neural network. We can train the model once using the <code>.partial_fit</code> method. Put the following lines right after the initiation of <code>mlp</code>.</p> <pre><code>mlp.partial_fit(X_train, y_train, np.unique(data.target))\nvisualise(mlp)\n</code></pre> <p>Compare the weights of the two visualisations.</p>"},{"location":"archive/202208/lab5/#effect-of-parameters","title":"Effect of parameters","text":"<p>Investigate the effect of the following parameters on the performance of the neural network and the number of iterations to achieve convergence.</p> <ul> <li>number of hidden layers</li> <li>number of neurons in hidden layers</li> <li>splitting ratio of training and testing sets</li> </ul>"},{"location":"archive/202208/lab6/","title":"Lab 6: ANN (Hyperplane)","text":""},{"location":"archive/202208/lab6/#artificial-neural-networks","title":"Artificial neural networks","text":""},{"location":"archive/202208/lab6/#objective","title":"Objective","text":"<ul> <li>to visualise the hyperplanes of a neural network configuration for better understanding</li> </ul>"},{"location":"archive/202208/lab6/#data-preparation","title":"Data preparation","text":"<p>We will use the iris data for the training in this lab.</p> <pre><code>from sklearn import datasets\niris = datasets.load_iris()\n</code></pre> <p>We will start with using just two input features. <pre><code>X = [[d[1],d[2]] for d in iris.data]\nnames = [iris.target_names[1],iris.target_names[2]]\nY = iris.target\n</code></pre></p>"},{"location":"archive/202208/lab6/#setup-the-first-configuration-for-neural-network","title":"Setup the first configuration for neural network","text":""},{"location":"archive/202208/lab6/#data-preprocessing","title":"Data preprocessing","text":"<ol> <li> <p>Training and testing sets split</p> <pre><code>from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, Y, train_size=0.8)\n</code></pre> </li> <li> <p>Scale the input data based on the training input data</p> <pre><code>from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nscaler.fit(X_train)\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab6/#construct-and-train-the-ann-model","title":"Construct and train the ANN model","text":"<ol> <li> <p>Construct the model</p> <pre><code>from sklearn.neural_network import MLPClassifier\nmlp = MLPClassifier(hidden_layer_sizes=(2), max_iter=1000)\n</code></pre> </li> <li> <p>Train the model</p> <pre><code>mlp.fit(X_train, y_train)\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab6/#visualise-the-classification-of-a-fitted-model","title":"Visualise the classification of a fitted model","text":""},{"location":"archive/202208/lab6/#prepare-the-figure-and-axis","title":"Prepare the figure and axis","text":"<pre><code>import matplotlib.pyplot as plt\nfig = plt.figure()\nax = fig.add_subplot(1,1,1)\n</code></pre>"},{"location":"archive/202208/lab6/#visualisation-function","title":"Visualisation function","text":"<ol> <li> <p>Download the vis.py and save it to the same folder as your script.</p> </li> <li> <p>Import all functions under the namespace of <code>vis</code> <pre><code>import vis\n</code></pre></p> </li> </ol>"},{"location":"archive/202208/lab6/#visualise-the-result","title":"Visualise the result","text":"<p>Use the following code to visualise the decision area of the model. <pre><code>vis.vis2d(ax, mlp, X_train, y_train, X_test, y_test)\n</code></pre></p>"},{"location":"archive/202208/lab6/#setup-the-second-third-and-more-neural-network-configurations","title":"Setup the second, third, and more neural network configurations","text":"<p>We will investigate the effect of using different activation functions on the hyperplane.</p> <p>The activation functions that are available for <code>MLPClassifier</code> are <code>identity</code>, <code>logistic</code>, <code>tanh</code>, and <code>relu</code> (default). They are explained in the documentation.</p> <p>We can use a <code>for</code>-loop to construct and train the neural network model with different configurations. The same datasets from previous sections are used.</p> <pre><code>activation_functions = ['identity', 'logistic', 'tanh', 'relu']\nfig = plt.figure()\nfor i, actfcn in enumerate(activation_functions):\n  mlp = MLPClassifier(hidden_layer_sizes=(3), activation=actfcn, max_iter=1000)\n  mlp.fit(X_train, y_train)\n  ax = fig.add_subplot(1, len(activation_functions), i+1)\n  ax.set_title(actfcn)\n  vis.vis2d(ax, mlp, X_train, y_train, X_test, y_test)\n</code></pre> <p>Apart from the activation functions, let's compare the results of having different number of hidden layers.</p> <pre><code>activation_functions = ['identity', 'logistic', 'tanh', 'relu']\nhidden_layers = [(3), (3,3), (3,3,3)]\nfig = plt.figure()\nfor i,actfcn in enumerate(activation_functions):\n  for j,hlyr in enumerate(hidden_layers):\n    mlp = MLPClassifier(hidden_layer_sizes=hlyr, activation=actfcn, max_iter=1000)\n    mlp.fit(X_train, y_train)\n    ax = fig.add_subplot(len(hidden_layers), len(activation_functions), j*len(activation_functions)+i+1)\n    ax.set_title('{},{},{}'.format(actfcn,str(hlyr),round(mlp.score(X_test,y_test),2)))\n    vis.vis2d(ax, mlp, X_train, y_train, X_test, y_test)\n    ax.set_xticks([])\n    ax.set_yticks([])\n</code></pre> <p><code>mlp.score(X_test, y_test)</code> gives the prediction accuracy of the model on <code>X_test</code> compared against <code>y_test</code>.</p>"},{"location":"archive/202208/lab6/#consider-more-input-features","title":"Consider more input features","text":"<p>We will now use all the input features instead of two. To prepare the data, <pre><code>X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, train_size=0.8)\nscaler.fit(X_train)\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)\n</code></pre></p>"},{"location":"archive/202208/lab6/#construct-and-train-the-model","title":"Construct and train the model","text":"<pre><code>mlp = MLPClassifier(hidden_layer_sizes=(3), max_iter=10000)\nmlp.fit(X_train, y_train)\n</code></pre>"},{"location":"archive/202208/lab6/#visualise-decision-area-with-more-input-features","title":"Visualise decision area with more input features","text":"<p>We will be using parallel coordinates to display data with more than 2 input features. The following is not a complete parallel coordinates plot but a partial one.</p> <pre><code>fig = plt.figure()\naxes = vis.vis3d(fig, mlp, X_train, y_train, X_test, y_test)\nfor i,a in enumerate(axes):\n  a.set_title(iris.target_names[i])\n  a.set_xticklabels([])\n  a.get_yaxis().set_visible(False)\naxes[-1].set_xticklabels(iris.feature_names)\n</code></pre> <p>Is there other alternative to display data with more than 2 input features?</p>"},{"location":"archive/202208/lab6/#additional","title":"Additional","text":"<p>There is a tensorflow playground which tries to visualise the training process of a neural network. It's similar to what we did in this lab.</p>"},{"location":"archive/202208/lab7/","title":"Lab 7: Fuzzy Systems","text":""},{"location":"archive/202208/lab7/#fuzzy-systems","title":"Fuzzy Systems","text":""},{"location":"archive/202208/lab7/#objective","title":"Objective","text":"<ul> <li>to construct a Mamdani fuzzy system using the <code>scikit-fuzzy</code> Python library</li> <li>to evaluate the result of the constructed fuzzy system</li> </ul>"},{"location":"archive/202208/lab7/#note","title":"Note","text":"<p>Install the <code>scikit-fuzzy</code> Python library in your environment before proceeding with the lab.</p> <pre><code>conda install -c conda-forge scikit-fuzzy\n</code></pre>"},{"location":"archive/202208/lab7/#fuzzy-control-system-for-a-train","title":"Fuzzy control system for a train","text":"<ol> <li> <p>Consider a fuzzy control system to control the brake and throttle of a train based on the speed of the train and the distance of the train to the next stop.</p> </li> <li> <p>Import the <code>skfuzzy</code>, <code>skfuzzy.control</code>, and <code>numpy</code>.</p> <pre><code>import numpy as np\nfrom skfuzzy import control as ctrl\nfrom skfuzzy import membership as mf\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab7/#initialise-inputs-and-outputs","title":"Initialise inputs and outputs","text":"<ol> <li> <p>Speed and distance are the inputs of the system whereas brake and throttle are the outputs.</p> </li> <li> <p>The ranges for the variables are:</p> Variable Range Speed 0 - 85 km/h Distance 0 - 3000 m Brake 0 - 100% Throttle 0 - 100% </li> <li> <p>As the inputs will be the antecedents of the rules, construct the variables <code>speed</code> and <code>distance</code> as <code>skfuzzy.control.Antecedent</code> objects. </p> <pre><code>speed = ctrl.Antecedent(np.arange(0, 85, 0.1), 'speed')\n</code></pre> </li> <li> <p>The initialisation function for <code>skfuzzy.control.Antecedent</code> object takes 2 arguments, the first is the universe of the variable, i.e. the values the variables can take, the second is the label of the variable. The initialisation function for <code>skfuzzy.control.Consequent</code> is similar. </p> </li> <li> <p>The label and the range of the variable can be accessed using <code>.label</code> and <code>.universe</code> respectively.</p> </li> </ol> <p>Task: Initialise the variables <code>distance</code> as <code>Antecedent</code> object, and <code>brake</code> and <code>throttle</code> as <code>Consequent</code> objects. (Outputs of the system will be consequents of the rules)</p>"},{"location":"archive/202208/lab7/#define-membership-functions-for-fuzzy-sets-of-variables","title":"Define membership functions for fuzzy sets of variables","text":"<ol> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>speed (0 to 85 km/h)</p> Linguistic value Fit vector Stopped (1/0, 0/2) Very slow (0/1, 1/2.5, 0/4) Slow (0/2.5, 1/6.5, 0/10.5) Medium fast (0/6.5, 1/26.5, 0/46.5) Fast (0/26.5, 1/70, 1/85) </li> <li> <p>distance (0 to 3000 m)</p> Linguistic value Fit vector At (1/0, 0/2) Very near (0/1, 1/3, 0/5) Near (0/3, 1/101.5, 0/200) Medium far (0/100, 1/1550, 0/3000) Far (0/1500, 1/2250, 1/3000) </li> <li> <p>brake (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/40) Very slight (0/20, 1/50, 0/80) Slight (0/70, 1/83.5, 0/97) Medium (0/95, 1/97, 0/99) Full (0/98, 1/100) </li> <li> <p>throttle (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/2) Very slight (0/1, 1/3, 0/5) Slight (0/3, 1/16.5, 0/30) Medium (0/20, 1/50, 0/80) Full (0/60, 1/80, 1/100) </li> </ul> </li> <li> <p>The <code>skfuzzy.membership</code> module provides the following membership functions:</p> Membership function Description <code>skfuzzy.membership.dsigmf(x, b1, c1, b2, c2)</code> Difference of two fuzzy sigmoid membership functions <code>skfuzzy.membership.gauss2mf(x, mean1, ...)</code> Gaussian fuzzy membership function of two combined Gaussians <code>skfuzzy.membership.gaussmf(x, mean, sigma)</code> Gaussian fuzzy membership function <code>skfuzzy.membership.gbellmf(x, a, b, c)</code> Generalized Bell function fuzzy membership generator <code>skfuzzy.membership.piecemf(x, abc)</code> Piecewise linear membership function (particularly used in FIRE filters) <code>skfuzzy.membership.pimf(x, a, b, c, d)</code> Pi-function fuzzy membership generator <code>skfuzzy.membership.psigmf(x, b1, c1, b2, c2)</code> Product of two sigmoid membership functions <code>skfuzzy.membership.sigmf(x, b, c)</code> The basic sigmoid membership function generator <code>skfuzzy.membership.smf(x, a, b)</code> S-function fuzzy membership generator <code>skfuzzy.membership.trapmf(x, abcd)</code> Trapezoidal membership function generator <code>skfuzzy.membership.trimf(x, abc)</code> Triangular membership function generator <code>skfuzzy.membership.zmf(x, a, b)</code> Z-function fuzzy membership generator </li> <li> <p>The fit vector of a linguitic value can be assigned to a linguistic variable using</p> <pre><code>speed['stopped'] = mf.trimf(speed.universe, [0, 0, 2])\nspeed['very slow'] = mf.trimf(speed.universe, [1, 2.5, 4])\n</code></pre> <p>Task: Assign all fuzzy sets to the linguistic variables.</p> </li> <li> <p>The fuzzy set diagram of a linguistic variable can be viewed using <code>.view()</code></p> <pre><code>speed.view()\n</code></pre> <p>Task: Check if the fuzzy set diagrams match the fit vectors.</p> </li> </ol>"},{"location":"archive/202208/lab7/#define-rules","title":"Define rules","text":"<ol> <li> <p>The rules for this system are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Distance At Very near Near Medium far Far Speed Stopped Full brakeNo throttle Full brakeVery slight throttle Very slow Full brakeNo throttle Medium brakeVery slight throttle Slight brakeVery slight throttle Slow Full brakeNo throttle Medium brakeVery slight throttle Very slight brakeSlight throttle Medium fast Very slight brakeMedium throttle No brakeFull throttle Fast Very slight brakeMedium throttle No brakeFull throttle </p> </li> <li> <p>Rule can be defined using <code>skfuzzy.control.Rule(antecedent, consequent, label)</code>. To define the first rule, i.e. if distance is 'at' and speed is 'stopped', then full brake and no throttle, </p> <pre><code>rule1 = ctrl.Rule(distance['at'] &amp; speed['stopped'], (brake['full'], throttle['no']))\n</code></pre> <p>If the antecedent consists of multiple parts, they can be combined using operators <code>|</code> (OR), <code>&amp;</code> (AND), and <code>~</code> (NOT).</p> <p>If the consequent consists of multiple parts, they can be combined as a <code>list</code>/<code>tuple</code>.</p> <p>Task: Define all the rules. Then combine all the rules in a <code>list</code>, i.e. <code>rules = [rule1, rule2, ...]</code>.</p> </li> </ol>"},{"location":"archive/202208/lab7/#construct-the-fuzzy-control-system","title":"Construct the fuzzy control system","text":"<ol> <li> <p>The train control system can be constructed with</p> <pre><code>train_ctrl = ctrl.ControlSystem(rules=rules)\n</code></pre> </li> <li> <p>A <code>skfuzzy.control.ControlSystemSimulation</code> object is needed to simulate the control system to obtain the outputs given certain inputs.</p> <pre><code>train = ctrl.ControlSystemSimulation(control_system=train_ctrl)\n</code></pre> </li> <li> <p>To obtain the values for <code>brake</code> and <code>throttle</code> given that <code>speed</code> is 30 km/h and <code>distance</code> is 6 m,</p> <pre><code># define the values for the inputs\ntrain.input['speed'] = 30\ntrain.input['distance'] = 2000\n\n# compute the outputs\ntrain.compute()\n\n# print the output values\nprint(train.output)\n\n# to extract one of the outputs\nprint(train.output['brake'])\n</code></pre> </li> <li> <p>To view the results in the graph,</p> <pre><code>brake.view(sim=train)\nthrottle.view(sim=train)\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab7/#view-the-controloutput-space","title":"View the control/output space","text":"<ol> <li> <p>The control/output space allows us to identify if the outputs fit our expectation.</p> </li> <li> <p>Construct an empty 3D space with 100-by-100 x-y grid.</p> <pre><code>x, y = np.meshgrid(np.linspace(speed.universe.min(), speed.universe.max(), 100),\n                   np.linspace(distance.universe.min(), distance.universe.max(), 100))\nz_brake = np.zeros_like(x, dtype=float)\nz_throttle = np.zeros_like(x, dtype=float)\n</code></pre> </li> <li> <p>Loop through every point and identify the value of brake and throttle of each point. As the specified rules are not exhaustive, i.e. some input combinations do not activate any rule, we will set the output of such input combinations to be <code>float('inf')</code>.     <pre><code>for i,r in enumerate(x):\n  for j,c in enumerate(r):\n    train.input['speed'] = x[i,j]\n    train.input['distance'] = y[i,j]\n    try:\n      train.compute()\n    except:\n      z_brake[i,j] = float('inf')\n      z_throttle[i,j] = float('inf')\n    z_brake[i,j] = train.output['brake']\n    z_throttle[i,j] = train.output['throttle']\n</code></pre></p> </li> <li> <p>Plot the result in a 3D graph using the <code>matplotlib.pyplot</code> library.</p> <pre><code>import matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndef plot3d(x,y,z):\n  fig = plt.figure()\n  ax = fig.add_subplot(111, projection='3d')\n\n  ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap='viridis', linewidth=0.4, antialiased=True)\n\n  ax.contourf(x, y, z, zdir='z', offset=-2.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='x', offset=x.max()*1.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='y', offset=y.max()*1.5, cmap='viridis', alpha=0.5)\n\n  ax.view_init(30, 200)\n\nplot3d(x, y, z_brake)\nplot3d(x, y, z_throttle)\n</code></pre> </li> </ol>"},{"location":"archive/202208/lab7/#fuzzy-tipping-recommendation-system","title":"Fuzzy tipping recommendation system","text":"<ol> <li> <p>A fuzzy expert system is designed to identify the percentage of tips a customer will give based on the service and the food the customer received.</p> </li> <li> <p>The system has service and food as inputs, and tips as output.</p> </li> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>service (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>food (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>tips (0 to 30%)</p> Linguistic value Fit vector Low (1/0, 0/15) Medium (0/0, 1/15, 0/30) High (0/15, 1/30) </li> </ul> </li> <li> <p>The rules are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Food Poor Average Good Service Poor low tips low tips medium tips Average low tips medium tips high tips Good medium tips high tips high tips </p> </li> </ol> <p>Task: Construct the fuzzy inference system.</p> <p>Task: Modify the membership functions of the input 'service' to</p> Linguistic value Fit vector Poor (1/0, 0/3) Average (0/2, 1/5, 0/8) Good (0/6, 1/10)"},{"location":"archive/202309/lab1/","title":"Lab 1: Refresh on Python","text":""},{"location":"archive/202309/lab1/#amoeba-community","title":"Amoeba community","text":"<ol> <li> <p>Assuming a new amoeba takes one month to grow, and from the second month onwards, it takes one month to duplicate itself to create a new amoeba. Given that there is one new amoeba at the beginning of the first month, this is the progression of the number of amoeba in different months.</p> <ul> <li><code>Month 0</code>: 1 (new)</li> <li><code>Month 1</code>: 1 (grown)</li> <li><code>Month 2</code>: 1 (grown) + 1 (new) = 2</li> <li><code>Month 3</code>: 2 (grown) + 1 (new) = 3</li> <li><code>Month 4</code>: 3 (grown) + 2 (new) = 5</li> <li><code>Month 5</code>: 5 (grown) + 3 (new) = 8</li> <li><code>Month 6</code>: 8 (grown) + 5 (new) = 13</li> <li><code>Month 7</code>: 13 (grown) + 8 (new) = 21</li> <li>...</li> </ul> <p>Hint</p> <p>Note the pattern of the sequence</p> </li> <li> <p>Write a function that takes the month number as input argument and provides the number of amoeba at the beginning of that month as output.</p> <pre><code>def numberofamoeba(month):\n  ...\n  return number_of_amoeba\n</code></pre> </li> <li> <p>Write a function to take the same input argument as <code>numberofamoeba</code> but instead of giving the number of amoeba at that month as output, provide the whole sequence of amoeba number starting from the beginning. For example, if <code>month</code> is <code>4</code>, the output of the function should be the list of <code>[1,1,2,3,5]</code></p> <pre><code>def numberofamoebaseq(month):\n  ...\n  return number_seq\n</code></pre> </li> <li> <p>Create a scatter plot to plot the sequence of amoeba number from month 0 to month 100.</p> <p>Hint</p> <p><code>import matplotlib.pyplot as plt</code> to use the Python visualisation library Matplotlib. Scatter plot can be produced with <code>plt.scatter(...)</code>.</p> </li> </ol>"},{"location":"archive/202309/lab1/#fibonacci-and-golden-ratio","title":"Fibonacci and Golden Ratio","text":"<ol> <li> <p>The above sequence of number is also known as the Fibonacci sequence.</p> <p>Note</p> <p>A Fibonacci sequence may or may not include a 0 as the first element of the series, i.e. <code>0,1,1,2,3,5,8,...</code> instead of <code>1,1,2,3,5,8</code>.</p> </li> <li> <p>Plot the ratio between every two consecutive numbers in the Fibonacci sequence. For Fibonacci sequence of <code>1,1,2,3,5,8,13,21</code>, plot the line of \\(\\frac{1}{1}\\), \\(\\frac{2}{1}\\), \\(\\frac{3}{2}\\), \\(\\frac{5}{3}\\), \\(\\frac{8}{5}\\), \\(\\frac{13}{8}\\), \\(\\frac{21}{13}\\).</p> <p>Note</p> <p>The longer the Fibonacci sequence you use, the closer is the value of the ratio between two consecutive numbers to be the golden ratio.</p> </li> <li> <p>Generate a series of coordinates following the algorithm:</p> <ol> <li>Start from <code>(0,0)</code>.</li> <li>Get the next Fibonacci number, i.e. <code>1</code>.</li> <li>Add <code>(+1,+1)</code> to the previous point <code>(0,0)</code> to get <code>(1,1)</code>.</li> <li>Get the next Fibonacci number, i.e. <code>1</code>.</li> <li>Add <code>(+1,-1)</code> to the previous point <code>(1,1)</code> to get <code>(2,0)</code>.</li> <li>Get the next Fibonacci number, i.e. <code>2</code>.</li> <li>Add <code>(-2,-2)</code> to the previous point <code>(2,0)</code> to get <code>(0,-2)</code>.</li> <li>Get the next Fibonacci number, i.e. <code>3</code>.</li> <li>Add <code>(-3,+3)</code> to the previous point <code>(0,-2)</code> to get <code>(-3,1)</code>.</li> <li>Continue with the next Fibonacci number and update the coordinates with the sequence of the signs <code>(+,+), (+,-), (-,-), (-,+)</code>.</li> </ol> <p>The process will create a spiral in the following manner. The sequence of the signs produce the change in directions, and the fibonacci number provides the distance.  (0,0) (1,1) (2,0) (0,-2) (-3,1) </p> </li> <li> <p>Create a line plot of the series of coordinates. If the lines are smoothen, it would form the golden spiral which can be found in pinecorns, seashells, and hurricanes.</p> <p>Additional</p> <p>If you are interested in how we may plot arc to connect the points instead of using straight lines, you can refer to Additional: plot arc to form golden spiral.</p> </li> </ol>"},{"location":"archive/202309/lab1/#random-selection-based-on-probability","title":"Random selection based on probability","text":"<p>For this section. assume the <code>random.random()</code> function selects the random number with even probability.</p> <ol> <li> <p>Consider a coin tossing event. If the probabilities of getting a head or a tail are even, i.e. 50%. Create a Python function which will simulate the coin tossing event and return the result as <code>head</code> or <code>tail</code>.</p> <pre><code>def tossCoin():\n  ...\n  return headOrTail\n</code></pre> </li> <li> <p>If the probabilities of getting a head or a tail are not even, with head as 20% and tail as 80%, how would you change the Python function you created previously to adapt to this coin?</p> </li> <li> <p>Consider the event of selecting one option out of three options randomly. The probability of choosing option <code>A</code> is 20%, <code>B</code> is 50%, and  <code>C</code> is 30%. Create a Python function to simulate the random selection of the options.</p> <pre><code>def chooseFromThree():\n  ...\n  return selectedOption\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab1/#additional-plot-arc-to-form-golden-spiral","title":"Additional: plot arc to form golden spiral","text":"<ol> <li> <p>The golden spiral can be produced by drawing the arc connecting every consecutive coordinates.      (0,0) (1,1) (2,0) (0,-2) (-3,1) (1,0) (1,0) </p> </li> <li> <p>To draw the arc using <code>matplotlib</code> library, we need to identify the center of each arc. The arc and its corresponding center are colored with the same color in the previous figure.      <pre><code>matplotlib.patches.Arc(\n    xy, # center of the arc\n    width, # length of horizontal axis, \n    height, # length of vertical axis, \n    angle, # rotation of the ellipse in degrees (counterclockwise)\n    theta1, # starting angle of the arc in degrees\n    theta2 # end angle of the arc in degrees\n)\n</code></pre></p> </li> <li> <p>The centers of every arc can be genrated from the sequence of coordinates using the following function:     function generatecenters<pre><code>def generatecenters(coordinates):\n    centers = []\n    for i, coord in enumerate(coordinates):\n        if i == 0: # add coordinate to list of center\n        centers.append([coord[0], coord[1]])\n        elif i == 1: # change x-coordinate of the first center\n        centers[-1][0] = coord[0]\n        else:\n        centers.append([centers[-1][0], centers[-1][1]])\n        if i % 2 == 0: # use y-coordinate as y for new center\n            centers[-1][1] = coord[1]\n        else: # use x-coordinate as x for new center\n            centers[-1][0] = coord[0]\n    return centers\n</code></pre>     The <code>coordinates</code> is the list of coordinates generated from Fibonacci and Golden Ratio step 3.</p> </li> <li> <p>The following function will then use the generated centers of the arc, and the Fibonacci sequence generated from <code>numberofamoebaseq</code> to draw the arc. The handler of the axis needs to be passed into the function as well.     function plotspiral<pre><code>def plotspiral(axis, series, centers):\n    angle = 90\n    for number,center in zip(series,centers):\n        arc = Arc(\n            xy=center, \n            width=2*number, \n            height=2*number, \n            angle=angle,\n            theta1=0, \n            theta2=90\n        )\n        axis.add_patch(arc)\n        angle -= 90\n</code></pre></p> <p>In your script, you will first generate the Fibonacci sequence, use the sequence to generate coordinates, generate centers of arcs, and plot the arcs to form the spiral.</p> <pre><code>n = 80\nnumber_seq = numberofamoebaseq(n)\ncoordinates = generatecoordinatesfromseries(number_seq)\ncenters = generatecenters(coordinates)\nplt.figure()\nplt.scatter(...) # or plt.plot(...) to plot the coordinates as in Fibonacci and Golden Ratio step 4\nplotspiral(plt.gca(), number_seq, centers) # plt.gca() returns handle of the current axis\n</code></pre> <p>Limitation</p> <p>Due to the limitation of matplotlib, the spiral plotting only works for the Fibonacci sequence with length less than 93.</p> </li> </ol>"},{"location":"archive/202309/lab2/","title":"Lab 2: Fuzzy Systems","text":""},{"location":"archive/202309/lab2/#fuzzy-systems","title":"Fuzzy Systems","text":""},{"location":"archive/202309/lab2/#objective","title":"Objective","text":"<ul> <li>to construct a Mamdani fuzzy system using the <code>scikit-fuzzy</code> Python library</li> <li>to evaluate the result of the constructed fuzzy system</li> </ul>"},{"location":"archive/202309/lab2/#note","title":"Note","text":"<p>Install the <code>scikit-fuzzy</code> Python library in your environment before proceeding with the lab.</p> <pre><code>conda install -c conda-forge scikit-fuzzy\n</code></pre>"},{"location":"archive/202309/lab2/#fuzzy-control-system-for-a-train","title":"Fuzzy control system for a train","text":"<ol> <li> <p>Consider a fuzzy control system to control the brake and throttle of a train based on the speed of the train and the distance of the train to the next stop.</p> </li> <li> <p>Import the <code>skfuzzy</code>, <code>skfuzzy.control</code>, and <code>numpy</code>.</p> <pre><code>import numpy as np\nfrom skfuzzy import control as ctrl\nfrom skfuzzy import membership as mf\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab2/#initialise-inputs-and-outputs","title":"Initialise inputs and outputs","text":"<ol> <li> <p>Speed and distance are the inputs of the system whereas brake and throttle are the outputs.</p> </li> <li> <p>The ranges for the variables are:</p> Variable Range Speed 0 - 85 km/h Distance 0 - 3000 m Brake 0 - 100% Throttle 0 - 100% </li> <li> <p>As the inputs will be the antecedents of the rules, construct the variables <code>speed</code> and <code>distance</code> as <code>skfuzzy.control.Antecedent</code> objects. </p> <pre><code>speed = ctrl.Antecedent(np.arange(0, 85, 0.1), 'speed')\n</code></pre> </li> <li> <p>The initialisation function for <code>skfuzzy.control.Antecedent</code> object takes 2 arguments, the first is the universe of the variable, i.e. the values the variables can take, the second is the label of the variable. The initialisation function for <code>skfuzzy.control.Consequent</code> is similar. </p> </li> <li> <p>The label and the range of the variable can be accessed using <code>.label</code> and <code>.universe</code> respectively.</p> </li> </ol> <p>Task: Initialise the variables <code>distance</code> as <code>Antecedent</code> object, and <code>brake</code> and <code>throttle</code> as <code>Consequent</code> objects. (Outputs of the system will be consequents of the rules)</p>"},{"location":"archive/202309/lab2/#define-membership-functions-for-fuzzy-sets-of-variables","title":"Define membership functions for fuzzy sets of variables","text":"<ol> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>speed (0 to 85 km/h)</p> Linguistic value Fit vector Stopped (1/0, 0/2) Very slow (0/1, 1/2.5, 0/4) Slow (0/2.5, 1/6.5, 0/10.5) Medium fast (0/6.5, 1/26.5, 0/46.5) Fast (0/26.5, 1/70, 1/85) </li> <li> <p>distance (0 to 3000 m)</p> Linguistic value Fit vector At (1/0, 0/2) Very near (0/1, 1/3, 0/5) Near (0/3, 1/101.5, 0/200) Medium far (0/100, 1/1550, 0/3000) Far (0/1500, 1/2250, 1/3000) </li> <li> <p>brake (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/40) Very slight (0/20, 1/50, 0/80) Slight (0/70, 1/83.5, 0/97) Medium (0/95, 1/97, 0/99) Full (0/98, 1/100) </li> <li> <p>throttle (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/2) Very slight (0/1, 1/3, 0/5) Slight (0/3, 1/16.5, 0/30) Medium (0/20, 1/50, 0/80) Full (0/60, 1/80, 1/100) </li> </ul> </li> <li> <p>The <code>skfuzzy.membership</code> module provides the following membership functions:</p> Membership function Description <code>skfuzzy.membership.dsigmf(x, b1, c1, b2, c2)</code> Difference of two fuzzy sigmoid membership functions <code>skfuzzy.membership.gauss2mf(x, mean1, ...)</code> Gaussian fuzzy membership function of two combined Gaussians <code>skfuzzy.membership.gaussmf(x, mean, sigma)</code> Gaussian fuzzy membership function <code>skfuzzy.membership.gbellmf(x, a, b, c)</code> Generalized Bell function fuzzy membership generator <code>skfuzzy.membership.piecemf(x, abc)</code> Piecewise linear membership function (particularly used in FIRE filters) <code>skfuzzy.membership.pimf(x, a, b, c, d)</code> Pi-function fuzzy membership generator <code>skfuzzy.membership.psigmf(x, b1, c1, b2, c2)</code> Product of two sigmoid membership functions <code>skfuzzy.membership.sigmf(x, b, c)</code> The basic sigmoid membership function generator <code>skfuzzy.membership.smf(x, a, b)</code> S-function fuzzy membership generator <code>skfuzzy.membership.trapmf(x, abcd)</code> Trapezoidal membership function generator <code>skfuzzy.membership.trimf(x, abc)</code> Triangular membership function generator <code>skfuzzy.membership.zmf(x, a, b)</code> Z-function fuzzy membership generator </li> <li> <p>The fit vector of a linguitic value can be assigned to a linguistic variable using</p> <pre><code>speed['stopped'] = mf.trimf(speed.universe, [0, 0, 2])\nspeed['very slow'] = mf.trimf(speed.universe, [1, 2.5, 4])\n</code></pre> <p>Task: Assign all fuzzy sets to the linguistic variables.</p> </li> <li> <p>The fuzzy set diagram of a linguistic variable can be viewed using <code>.view()</code></p> <pre><code>speed.view()\n</code></pre> <p>Task: Check if the fuzzy set diagrams match the fit vectors.</p> </li> </ol>"},{"location":"archive/202309/lab2/#define-rules","title":"Define rules","text":"<ol> <li> <p>The rules for this system are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Distance At Very near Near Medium far Far Speed Stopped Full brakeNo throttle Full brakeVery slight throttle Very slow Full brakeNo throttle Medium brakeVery slight throttle Slight brakeVery slight throttle Slow Full brakeNo throttle Medium brakeVery slight throttle Very slight brakeSlight throttle Medium fast Very slight brakeMedium throttle No brakeFull throttle Fast Very slight brakeMedium throttle No brakeFull throttle </p> </li> <li> <p>Rule can be defined using <code>skfuzzy.control.Rule(antecedent, consequent, label)</code>. To define the first rule, i.e. if distance is 'at' and speed is 'stopped', then full brake and no throttle, </p> <pre><code>rule1 = ctrl.Rule(distance['at'] &amp; speed['stopped'], (brake['full'], throttle['no']))\n</code></pre> <p>If the antecedent consists of multiple parts, they can be combined using operators <code>|</code> (OR), <code>&amp;</code> (AND), and <code>~</code> (NOT).</p> <p>If the consequent consists of multiple parts, they can be combined as a <code>list</code>/<code>tuple</code>.</p> <p>Task: Define all the rules. Then combine all the rules in a <code>list</code>, i.e. <code>rules = [rule1, rule2, ...]</code>.</p> </li> </ol>"},{"location":"archive/202309/lab2/#construct-the-fuzzy-control-system","title":"Construct the fuzzy control system","text":"<ol> <li> <p>The train control system can be constructed with</p> <pre><code>train_ctrl = ctrl.ControlSystem(rules=rules)\n</code></pre> </li> <li> <p>A <code>skfuzzy.control.ControlSystemSimulation</code> object is needed to simulate the control system to obtain the outputs given certain inputs.</p> <pre><code>train = ctrl.ControlSystemSimulation(control_system=train_ctrl)\n</code></pre> </li> <li> <p>To obtain the values for <code>brake</code> and <code>throttle</code> given that <code>speed</code> is 30 km/h and <code>distance</code> is 6 m,</p> <pre><code># define the values for the inputs\ntrain.input['speed'] = 30\ntrain.input['distance'] = 2000\n\n# compute the outputs\ntrain.compute()\n\n# print the output values\nprint(train.output)\n\n# to extract one of the outputs\nprint(train.output['brake'])\n</code></pre> </li> <li> <p>To view the results in the graph,</p> <pre><code>brake.view(sim=train)\nthrottle.view(sim=train)\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab2/#view-the-controloutput-space","title":"View the control/output space","text":"<ol> <li> <p>The control/output space allows us to identify if the outputs fit our expectation.</p> </li> <li> <p>Construct an empty 3D space with 100-by-100 x-y grid.</p> <pre><code>x, y = np.meshgrid(np.linspace(speed.universe.min(), speed.universe.max(), 100),\n                   np.linspace(distance.universe.min(), distance.universe.max(), 100))\nz_brake = np.zeros_like(x, dtype=float)\nz_throttle = np.zeros_like(x, dtype=float)\n</code></pre> </li> <li> <p>Loop through every point and identify the value of brake and throttle of each point. As the specified rules are not exhaustive, i.e. some input combinations do not activate any rule, we will set the output of such input combinations to be <code>float('inf')</code>.     <pre><code>for i,r in enumerate(x):\n  for j,c in enumerate(r):\n    train.input['speed'] = x[i,j]\n    train.input['distance'] = y[i,j]\n    try:\n      train.compute()\n    except:\n      z_brake[i,j] = float('inf')\n      z_throttle[i,j] = float('inf')\n    z_brake[i,j] = train.output['brake']\n    z_throttle[i,j] = train.output['throttle']\n</code></pre></p> </li> <li> <p>Plot the result in a 3D graph using the <code>matplotlib.pyplot</code> library.</p> <pre><code>import matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndef plot3d(x,y,z):\n  fig = plt.figure()\n  ax = fig.add_subplot(111, projection='3d')\n\n  ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap='viridis', linewidth=0.4, antialiased=True)\n\n  ax.contourf(x, y, z, zdir='z', offset=-2.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='x', offset=x.max()*1.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='y', offset=y.max()*1.5, cmap='viridis', alpha=0.5)\n\n  ax.view_init(30, 200)\n\nplot3d(x, y, z_brake)\nplot3d(x, y, z_throttle)\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab2/#fuzzy-tipping-recommendation-system","title":"Fuzzy tipping recommendation system","text":"<ol> <li> <p>A fuzzy expert system is designed to identify the percentage of tips a customer will give based on the service and the food the customer received.</p> </li> <li> <p>The system has service and food as inputs, and tips as output.</p> </li> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>service (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>food (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>tips (0 to 30%)</p> Linguistic value Fit vector Low (1/0, 0/15) Medium (0/0, 1/15, 0/30) High (0/15, 1/30) </li> </ul> </li> <li> <p>The rules are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Food Poor Average Good Service Poor low tips low tips medium tips Average low tips medium tips high tips Good medium tips high tips high tips </p> </li> </ol> <p>Task: Construct the fuzzy inference system.</p> <p>Task: Modify the membership functions of the input 'service' to</p> Linguistic value Fit vector Poor (1/0, 0/3) Average (0/2, 1/5, 0/8) Good (0/6, 1/10)"},{"location":"archive/202309/lab3/","title":"Lab 3: EC (GA)","text":""},{"location":"archive/202309/lab3/#binary-to-gray-code-conversion","title":"Binary-to-gray code conversion","text":"<p>Binary string is often used in the implementation of genetic algorithm. However, the downside of using a binary code is that the Hamming distance between two adjacent values is not consistent. This situation is solved by using a Gray code in place of a binary code.</p> <ol> <li> <p><code>numpy</code> provides the function of <code>binary_repr</code> to convert a decimal value to its corresponding binary code.</p> </li> <li> <p>Create a function to take the input of a binary code and return the correponding Gray code of the binary code. </p> </li> <li> <p>Create a function to calculate the Hamming distance between two binary strings (two binary codes or two Gray codes).</p> </li> <li> <p>Consider a sequence of decimal values of <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>. Convert the sequence to a series of binary codes. Identify and plot (example of a line plot) the Hamming distances between the adjacent values.</p> </li> <li> <p>Repeat the previous step with Gray codes instead of binary codes.</p> </li> </ol>"},{"location":"archive/202309/lab3/#genetic-algorithm","title":"Genetic algorithm","text":"<p>Consider the following problem: </p> <p>Problem</p> <p>You are given a sheet of paper with width <code>w</code> and height <code>h</code>. Your task is to cut the paper into squares of equal size. The aim of the task is to have as many squares as possible, and to have the area of each square as large as possible.</p> <ol> <li> <p>An optimisation problem can always be phrased in the form of</p> <p>to optimise ... such that it maximises/minimises ...</p> <p>In this problem, what is the parameter to be optimised and what are the parameters to be maximised or minimised?</p> </li> <li> <p>Let <code>x</code> denotes the length of the sides of a square. Design a fitness function such that higher fitness corresponds to larger number of squares and large area. If the number of squares (that can be cut out) is zero, or the area of the square is zero, the fitness will be zero.</p> </li> </ol> feature encoding population initialisation selection as parents crossover mutation offspring (next generation population) repeat from fitnexx calculation until termination"},{"location":"archive/202309/lab3/#feature-encoding","title":"Feature encoding","text":"<ol> <li> <p>In this problem as we only have one feature, i.e. the side length of the square, each chromosome consists of the value of the side length of the square. We will encode the chromosome in the form of Gray code. </p> </li> <li> <p>Create two functions <code>value2gray</code> and <code>gray2value</code> to convert a decimal value to its Gray code and vice versa.</p> <pre><code>def value2gray(value):\n  # this function converts a decimal value to its gray code representation\n  ...\n  return gray\n\ndef gray2value(gray):\n  # this function converts a gray code representation to its decimal value\n  ...\n  return value\n</code></pre> </li> <li> <p>Add the following code snippet to the end of the code to test your functions.</p> <pre><code>if __name__ == \"__main__\":\n  print(value2gray(10))\n  print(gray2value(\"1001\"))\n</code></pre> <p>After running the file as a script, you should see the following output.</p> <pre><code>1111\n14\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab3/#population-initialisation","title":"Population initialisation","text":"<ol> <li> <p>A population is randomly generated according to the defined population size. </p> </li> <li> <p>Create a function to generate randomly a population of size <code>pop_size</code> with each value lies between the range of <code>pop_min</code> to <code>pop_max</code>.</p> <pre><code>def generatePopulation(pop_size, pop_min, pop_max):\n  # this function generate the first generation randomly based on the population size and the range of the value of each chromosome\n  ...\n  return population\n</code></pre> <p>This function and all the functions created after this should be placed before the <code>if __name__ == \"__main__\":</code> code block.</p> </li> <li> <p>[Optional testing] You can test the function by changing the <code>__main__</code> code block to </p> <pre><code>if __name__ == \"__main__\":\n  print(generatePopulation(8, 0, 10))\n</code></pre> <p>The printed output should be a series of 8 chromosomes displayed as decimal values.</p> </li> </ol>"},{"location":"archive/202309/lab3/#fitness-calculation","title":"Fitness calculation","text":"<ol> <li> <p>The fitness function was designed at the beginning of this section. Define a function that takes the input of a chromosome (as decimal value) and returns the fitness of the chromosome.</p> <p><pre><code>def calculateFitness(value):\n  # this function calculates the fitness of a chromosome from the decimal value of the chromosome\n  ...\n  return fitness\n</code></pre> 2. [Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(calculateFitness(5))\n</code></pre> <p>The printed output should be the fitness of a chromosome of value 5, which would be a decimal value larger than zero.</p> </li> </ol>"},{"location":"archive/202309/lab3/#selection-as-parents","title":"Selection as parents","text":"<ol> <li> <p>From the list of the chromosomes, we will select the chromosome pairs as parents. As we will be using one-point crossover, each pair of parents will produce exactly two offsprings. Therefore for population size of <code>pop_size</code>, we need <code>pop_size/2</code> pairs of parents.</p> </li> <li> <p>Define a function that takes the inputs of the current population and the total number of chromosomes in current population, and returns the chromosome pairs which will act as parents. The selection process is performed with the roulette wheel selection. The same chromosome can be selected more than once.</p> <pre><code>def selectParents(chromosomes, pop_size):\n  ...\n  return parent_pairs\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(selectParents([13, 8, 14, 7], 6))\n</code></pre> <p>The printed output should be 3 parent pairs, for example, </p> <pre><code>[[13, 8], [8, 14], [13, 7]]\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab3/#crossover","title":"Crossover","text":"<ol> <li> <p>Define a function that takes a parent pair and returns a pair of offspring after performing one-point crossover.</p> <pre><code>def crossover(parents):\n  # this function takes a parent pair and perform one-point crossover to produce a pair of offspring\n  ...\n  return offsprings\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(crossover([13, 9]))\n</code></pre> <p>The printed output should be a pair of offsprings, for example,</p> <pre><code>[10, 14]\n</code></pre> <p><code>13</code> is <code>1011</code> and <code>9</code> is <code>1101</code> in Gray code, the offsprings <code>10</code> is <code>1111</code> and <code>14</code> is <code>1001</code> in Gray code.</p> </li> </ol>"},{"location":"archive/202309/lab3/#mutation","title":"Mutation","text":"<ol> <li> <p>Each gene in all chromosomes has the same mutation probability <code>p_mutation</code>. </p> </li> <li> <p>Define a function that takes a chromosome and the mutation probability <code>p_mutation</code> as the inputs, and returns the mutated chromosome. </p> <p><pre><code>def mutate(chromosome, p_mutation):\n  # this function mutates each gene of a chromosome based on the mutation probability\n  ...\n  return mutated\n</code></pre> 3. [Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(mutate(15, 0.1))\n</code></pre> <p>The printed output should be the mutated or unmutated chromosome, for example, <code>14</code>.</p> <p><code>15</code> is <code>1000</code> and <code>14</code> is <code>1001</code> in Gray code. In the example output, the last bit is mutated.</p> </li> </ol>"},{"location":"archive/202309/lab3/#repeat-until-termination","title":"Repeat until termination","text":"<ol> <li> <p>The common termination criteria are the maximum number of iterations and the distance among the fitnesses of the chromosomes of the latest population.</p> </li> <li> <p>Define a function that calculates one metric to measure the distance among the fitnesses of the chromosomes, i.e. how far the fitnesses of all the chromosomes are from each other.</p> <pre><code>def findOverallDistance(chromosomes):\n  # this function takes the input of the current population and returns the overall distance among fitnesses of all chromosomes\n  ...\n  return overall_distance\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(findOverallDistance([13, 11, 14, 7]))\n</code></pre> <p>The printed output should be a decimal value that represents the overall distance of fitnesses.</p> </li> </ol>"},{"location":"archive/202309/lab3/#combining-all-functions","title":"Combining all functions","text":"<ol> <li> <p>The functions we have created can be combined with the following code snippet to execute the genetic algorithm to solve the problem defined at the beginning of this section. Consider the width and the height of the sheet of paper to be <code>20cm</code> and <code>15cm</code>.</p> <pre><code>if __name__ == \"__main__\":\n  # main function\n  ## parameter definition\n  pop_size = 10\n  pop_min = 1 #1cm\n  pop_max = 10 #10cm\n  curr_iter = 0\n  max_iter = 100\n  min_overalldistance = 0.5\n  p_mutation = 0.05\n  ## initialise population\n  population = []\n  population.append(generatePopulation(pop_size, pop_min, pop_max))\n  while (curr_iter &lt; max_iter and findOverallDistance(population[-1]) &gt; min_overalldistance):\n    curr_iter += 1\n    ## select parent pairs\n    parents = selectParents(population[-1], len(population[-1]))\n    ## perform crossover\n    offsprings = []\n    for p in parents:\n      new_offsprings = crossover(p)\n      for o in new_offsprings:\n        offsprings.append(o)\n    ## perform mutation\n    mutated = [mutate(offspring, p_mutation) for offspring in offsprings]\n    ## update current population\n    population.append(mutated)\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab4/","title":"Lab 4: EC (PSO)","text":""},{"location":"archive/202309/lab4/#particle-swarm-optimisation","title":"Particle swarm optimisation","text":""},{"location":"archive/202309/lab4/#objective","title":"Objective","text":"<ul> <li>develop a Python function to perform global best particle swarm optimisation</li> </ul>"},{"location":"archive/202309/lab4/#setup-for-spyder","title":"Setup for Spyder","text":"<ol> <li> <p>If you are using Spyder for this lab, go to Tools &gt; Preferences &gt; IPython console &gt; Graphics and set Backend to Automatic.</p> </li> <li> <p>Restart kernel by going to Consoles &gt; Restart kernel.</p> </li> </ol>"},{"location":"archive/202309/lab4/#problem-to-solve","title":"Problem to solve","text":"<p>Solve the following problem using global best particle swarm optimisation:</p> <p>Problem</p> <p>Find the value of x to minimise the function \\(f(x) = (x+100)(x+50)(x)(x-20)(x-60)(x-100)\\) for \\(-100 &lt; x &lt; 100\\)</p>"},{"location":"archive/202309/lab4/#particle-swarm-optimisation_1","title":"Particle swarm optimisation","text":"particles initialisation personal best identification global best identification velocity calculation position update repeat from personal best identification until termination"},{"location":"archive/202309/lab4/#parameter-definition","title":"Parameter definition","text":"<ol> <li> <p>With global best particle swarm optimisaton, the position update function is given by</p> \\[x_i(t+1) = x_i(t) + v_i(t+1)\\] <p>and the velocity update function is</p> \\[v_i(t+1) = v_i(t) + \\alpha_1\\beta_1(t) \\Big( p_i(t) - x_i(t) \\Big) + \\alpha_2\\beta_2(t)\\Big(p_g(t) - x_i(t)\\Big)\\] </li> <li> <p>\u03b1<sub>1</sub> and \u03b1<sub>2</sub> are acceleration constants that are fixed throughout the algorithm. Define a small value for \u03b1<sub>1</sub> and \u03b1<sub>2</sub>, for example <code>0.1</code>.</p> <pre><code>alpha = [0.1, 0.1]\n</code></pre> </li> <li> <p>\u03b2<sub>1</sub>(t) and \u03b2<sub>2</sub>(t) are random values between <code>0</code> and <code>1</code> that are regenerated every iteration. Therefore no definition is required.</p> </li> <li> <p>Also, define the number of particles to run the algorithm with.</p> <pre><code>n_particle = 10\n</code></pre> </li> <li> <p>Place the definition of these variables in the <code>__main__</code> block.</p> <pre><code>if __name__ == '__main__':\n  alpha = [0.1, 0.1]\n  n_particle = 10\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab4/#create-a-class-for-particle","title":"Create a class for particle","text":"<ol> <li> <p>As each particle is an individual, create a <code>Particle</code> class to hold the data of the particle's current position, velocity, and personal best position.</p> <pre><code>class Particle:\n  def __init__(self, position = 0, velocity = 0):\n    self.position = position\n    self.velocity = velocity\n    self.best_position = position\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab4/#fitness-function","title":"Fitness function","text":"<ol> <li> <p>Fitness function is how we can compare different particles.</p> </li> <li> <p>As our goal is to minimise f(x) as stated in the beginning, we will use f(x) as our fitness function.</p> </li> <li> <p>By using f(x) in minimisation problem, it implies that the lower the value of f(x), the better the particle it is.</p> </li> <li> <p>The value of x is the position of the particle.</p> </li> <li> <p>Define the fitness function as a Python function.</p> <pre><code>def fit_fcn(position):\n  ...\n  return fitness\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab4/#initialise-particles","title":"Initialise particles","text":"<ol> <li> <p>Particles are initialised with random positions within the constraints. </p> </li> <li> <p>At initialisation, we may assume that the initial velocities of all the particles. It is possible to initialise particles with non-zero velocities. For now, we will stick to zero initial velocities.</p> </li> <li> <p>Define a Python function that takes the input of the number of particles and the limits of the positions to initialise and return a list of objects of class <code>Particle</code>. Each particle has random position within the limits and zero velocity.</p> <pre><code>def initialise_particles(n_ptc, position_limits):\n  # position_limits is a list of two values. The first value is the lower boundary and the second value is the upper boundary.\n  ...\n  return particles\n</code></pre> </li> <li> <p>Remember to test your function before proceed.</p> </li> </ol>"},{"location":"archive/202309/lab4/#update-personal-best","title":"Update personal best","text":"<ol> <li> <p>Create a method in the class <code>Particle</code> to update the <code>best_position</code> if necessary.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(self):\n    # 1. calculate the fitnesses of the best_position and the particle's current position\n    # 2. compare the fitnesses and determine if the current position is better than the best_position\n    # 3. update if necessary\n    # 4. no return statement is required\n</code></pre> </li> <li> <p>If the new position has a lower fitness, i.e. the new position is better than the best position, update the <code>best_position</code> to hold the value of the new position.</p> </li> </ol>"},{"location":"archive/202309/lab4/#update-global-best","title":"Update global best","text":"<ol> <li> <p>Initiate a variable named <code>global_best_position</code> with the value <code>None</code> in the <code>__main__</code> block. </p> </li> <li> <p>Create a function that takes two positions as inputs, compare them, and return the better position of the two.</p> <pre><code>def compareFitness(pos1, pos2):\n  # 1. calculate the fitness of pos1 and pos2\n  # 2. compare to determine the better position\n  return betterpos\n</code></pre> </li> <li> <p>We will later use this function to compare the current global best position with the personal best position of each particle.</p> </li> </ol>"},{"location":"archive/202309/lab4/#update-velocity","title":"Update velocity","text":"<ol> <li> <p>Create a method in the class <code>Particle</code> to update the velocity given \u03b1<sub>1</sub>, \u03b1<sub>2</sub>, \u03b2<sub>1</sub>, \u03b2<sub>2</sub>, and the global best position.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(...):\n    ...\n\n  def update_velocity(self, alpha, beta, glob_best_pos):\n    # alpha is a list of two values. we will access alpha_1 and alpha_2 by alpha[0] and alpha[1] respectively. This also applies to beta.\n    # the current position, current velocity, and personal best position of the particle can be accessed by self.position, self.velocity, and self.best_position\n    # assign the particle's velocity with the updated velocity\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab4/#update-particle-position","title":"Update particle position","text":"<ol> <li> <p>As updating a particle position only require information from within the particle object and the limits of the position, create a method called <code>update_position</code> in the class <code>Particle</code> taking the input of the limits of the position.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(...):\n    ...\n\n  def update_velocity(...):\n    ...\n\n  def update_position(self, position_limits):\n    self.position = self.position + self.velocity\n    # how should you solve the problem of the position (x) going out of the limits\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab4/#create-a-loop-until-termination","title":"Create a loop (until termination)","text":"<ol> <li> <p>Consider the following termination criteria:</p> <ul> <li>exceeding 200 iterations</li> <li>fitnesses of all particles are close</li> <li>positions of all particles are close</li> </ul> </li> <li> <p>Create a function to calculate the average difference between the mean fitness and the fitness of each particle.</p> <pre><code>def calc_avg_fit_diff(particles):\n  # 1. calculate mean fitness of all particles\n  # 2. calculate the difference between the mean fitness and the fitness of each particle\n  # 3. calculate the average of the differences obtained from step 2\n  return avg_fit_diff\n</code></pre> </li> <li> <p>Create a function to calculate the average difference between the mean position and the position of each particle.</p> <pre><code>def calc_avg_pos_diff(particles):\n  # 1. calculate mean position of all particles\n  # 2. calculate the difference between the mean position and the position of each particle\n  # 3. calculate the average of the differences obtained from step 2\n  return avg_pos_diff\n</code></pre> </li> <li> <p>Create a loop (in the <code>__main__</code> block) to execute the global best particle swarm optimisation (gbest PSO) until termination. </p> <pre><code>if __name__ == '__main__':\n  # parameter initialisation\n  alpha = [0.1, 0.1]\n  n_particle = 10\n  global_best_position = None\n  position_limits = [-100, 100]\n  # termination threshold\n  iteration = 0\n  max_iter = 200\n  min_avg_fit_diff = 0.1\n  min_avg_pos_diff = 0.1\n  # initialise particles\n  particles = initialise_particles(n_particle, position_limits)\n  while (...): # how should you define the termination criteria here?\n    print(iteration, [round(x.position,2) for x in particles])\n    for particle in particles:\n      # update personal best\n      particle.update_personal_best()\n      # update global best\n      if global_best_position == None:\n        global_best_position = particle.position\n      else:\n        global_best_position = compareFitness(global_best_position, particle.position)\n    # generate beta randomly for current iteration\n    beta = [random.random(), random.random()]\n    for particle in particles:\n      # update velocity\n      particle.update_velocity(alpha, beta, global_best_position)\n      # update position\n      particle.update_position(position_limits)\n    iteration += 1\n  # display results\n  print(iteration, [round(x.position,2) for x in particles])\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab4/#visualisation","title":"Visualisation","text":"<ol> <li> <p>Let's add a few lines to visualise particles \"flying\" towards to optimal position.</p> <ul> <li> <p>import the visualisation library   <pre><code>import matplotlib.pyplot as plt\n</code></pre></p> </li> <li> <p>add the following lines just before the <code>while</code> loop in the last code block in the previous section.   <pre><code>space_ax = plt.axes()\nspace_ax.plot(list(range(*position_limits)),[fit_fcn(x) for x in range(*position_limits)])\nspace_ax.set_title(\"Position of particles in iteration {}\".format(iteration))\nspace_ax.set_xlabel(\"Position\")\nspace_ax.set_ylabel(\"Fitness\")\n</code></pre></p> </li> <li> <p>add the following lines between line 14 and line 15 in the last code block in the previous section, as well as after line 33.   <pre><code>if len(space_ax.lines) &gt; 1:\n  space_ax.lines[1].remove()\nspace_ax.plot([x.position for x in particles], [fit_fcn(x.position) for x in particles], 'go')\nspace_ax.set_title(\"Position of particles in iteration {}\".format(iteration))\nplt.pause(0.5) # pause the program for 0.5 second; if graph changes too quickly, increase this value; you can also speed up the process by decreasing this value\n</code></pre></p> </li> </ul> </li> </ol>"},{"location":"archive/202309/lab4/#evaluation","title":"Evaluation","text":"<ol> <li> <p>Store the values of the variables at each iteration for analysis and evaluation.</p> <ul> <li>position of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.position_list = [position]\n\n  def update_position(...):\n    ...\n    self.position_list.append(self.position)\n</code></pre> <ul> <li>velocity of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.velocity_list = [velocity]\n\n  def update_velocity(...):\n    ...\n    self.velocity_list.append(self.velocity)\n</code></pre> <ul> <li>personal best position of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.best_position_list = []\n\n  def update_personal_best(...):\n    ...\n    self.best_position_list.append(self.best_position)\n</code></pre> <ul> <li>global best position at each iteration</li> </ul> <pre><code>if __init__ == '__main__':\n  # parameter initialisation\n  ...\n  global_best_position_list = []\n  ...\n        global_best_position = ...\n    global_best_position_list.append(global_best_position) # take note on the indentation\n    # generate beta randomly for current iteration\n    ...\n</code></pre> </li> <li> <p>Visualise the progression of these variables by adding the following code to the end of the <code>__main__</code> block.</p> <pre><code>[pos_fig, position_axes] = plt.subplots(4,1,sharex=True)\nposition_axes[0].set_title(\"Position of each particle\")\nposition_axes[1].set_title(\"Fitness of each particle\")\nposition_axes[2].set_title(\"Boxplot of position at each iteration\")\nposition_axes[3].set_title(\"Boxplot of fitness at each iteration\")\nposition_axes[3].set_xlabel(\"Iteration\")\n[vel_fig, velocity_axes] = plt.subplots(2,1,sharex=True)\nvelocity_axes[0].set_title(\"Velocity of each particle\")\nvelocity_axes[1].set_title(\"Boxplot for velocity at each iteration\")\nvelocity_axes[1].set_xlabel(\"Iteration\")\n[p_best_fig, personal_best_axes] = plt.subplots(4,1,sharex=True)\npersonal_best_axes[0].set_title(\"Personal best position of each particle\")\npersonal_best_axes[1].set_title(\"Personal best fitness of each particle\")\npersonal_best_axes[2].set_title(\"Boxplot of personal best position at each iteration\")\npersonal_best_axes[3].set_title(\"Boxplot of personal best fitness at each iteration\")\npersonal_best_axes[3].set_xlabel(\"Iteration\")\n[g_best_fig, global_best_axes] = plt.subplots(2,1,sharex=True)\nglobal_best_axes[0].set_title(\"Global best position\")\nglobal_best_axes[1].set_title(\"Fitness for global best position\")\nglobal_best_axes[1].set_xlabel(\"Iteration\")\nfor particle in particles:\n  iteration_list = list(range(len(particle.position_list)))\n  position_axes[0].plot(iteration_list, particle.position_list, '-o')\n  position_axes[1].plot(iteration_list, [fit_fcn(x) for x in particle.position_list], '-o')\n\n  velocity_axes[0].plot(iteration_list, particle.velocity_list, '-o')\n\n  personal_best_axes[0].plot(iteration_list[:-1], particle.best_position_list, '-o')\n  personal_best_axes[1].plot(iteration_list[:-1], [fit_fcn(x) for x in particle.best_position_list], '-o')\n\nposition_axes[2].boxplot([[p.position_list[i] for p in particles] for i in iteration_list], positions=iteration_list)\nposition_axes[3].boxplot([[fit_fcn(p.position_list[i]) for p in particles] for i in iteration_list], positions=iteration_list)\n\nvelocity_axes[1].boxplot([[p.velocity_list[i] for p in particles] for i in iteration_list], positions=iteration_list)\n\npersonal_best_axes[2].boxplot([[p.best_position_list[i] for p in particles] for i in iteration_list[:-1]], positions=iteration_list[:-1])\npersonal_best_axes[3].boxplot([[fit_fcn(p.best_position_list[i]) for p in particles] for i in iteration_list[:-1]], positions=iteration_list[:-1])\n\nglobal_best_axes[0].plot(iteration_list[:-1], global_best_position_list, '-o')\nglobal_best_axes[1].plot(iteration_list[:-1], [fit_fcn(x) for x in global_best_position_list], '-o')\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab4/#exercise","title":"Exercise","text":"<ol> <li> <p>Multiply the velocity memory, \\(v_i(t)\\), with a value between 0 and 1, let's say 0.5. How does the process change? This is the effect of inertia weight.</p> </li> <li> <p>Reduce the value of \\(\\alpha_1\\) to 0.05 while maintaining \\(\\alpha_2\\) at 0.1 and investigate the effect. </p> </li> <li> <p>Reduce the value of \\(\\alpha_1\\) to 0. How does this affect the result?</p> </li> <li> <p>Modify such that \\(\\alpha_1\\) is larger than \\(\\alpha_2\\). What's the effect?</p> </li> </ol>"},{"location":"archive/202309/lab4/#optional","title":"Optional","text":"<ol> <li>How may you modify the formulae for particles with two variables, in which the fitness function is defined as \\(f(x,y) = x^2 + y^2\\)? </li> </ol>"},{"location":"archive/202309/lab5/","title":"Lab 5: EC (ACO)","text":""},{"location":"archive/202309/lab5/#ant-colony-optimisation","title":"Ant colony optimisation","text":""},{"location":"archive/202309/lab5/#objective","title":"Objective","text":"<ul> <li>to develop a Python function to perform ant colony optimisation on a problem</li> </ul>"},{"location":"archive/202309/lab5/#problem-to-solve","title":"Problem to solve","text":"<p>We will use ant colony optimisation to solve the Nick's route-finding problem in Romania. The problem is a route finding problem to identify the best (cheapest) route to travel from Arad to Bucharest.</p> <p>The road map of Romania is provided as follows:</p> 75 71 151 140 118 111 70 75 120 146 80 99 97 138 101 211 90 85 98 86 142 92 87 Arad Zerind Oradea Sibiu Fagaras Rimnicu Vilcea Pitesti Craiova Drobeta Mehadia Lugoj Timisoara Bucharest Giurgiu Urziceni Hirsova Eforie Vaslui Iasi Neamt"},{"location":"archive/202309/lab5/#problem-formulation","title":"Problem formulation","text":"<ol> <li> <p>The coordinates of each town are provided as follows. This will be used later for the purpose of visualisation.</p> <pre><code>location_list = [ # [x,y,name]\n  [75, 125, 'Arad'],\n  [100, 75, 'Zerind'],\n  [125, 25, 'Oradea'],\n  [265, 175, 'Sibiu'],\n  [425, 175, 'Fagaras'],\n  [320, 230, 'Rimnicu Vilcea'],\n  [475, 310, 'Pitesti'],\n  [350, 465, 'Craiova'],\n  [185, 450, 'Drobeta'],\n  [190, 390, 'Mehadia'],\n  [185, 335, 'Lugoj'],\n  [85, 280, 'Timisoara'],\n  [640, 390, 'Bucharest'],\n  [575, 485, 'Giurgiu'],\n  [745, 340, 'Urziceni'],\n  [875, 340, 'Hirsova'],\n  [935, 440, 'Eforie'],\n  [850, 225, 'Vaslui'],\n  [760, 120, 'Iasi'],\n  [625, 60, 'Neamt']\n]\n</code></pre> </li> <li> <p>Then define the travel cost between connected cities. </p> <pre><code>step_cost = [\n  ['Arad', 'Zerind', 75],\n  ['Zerind', 'Oradea', 71],\n  ['Oradea', 'Sibiu', 151],\n  ['Sibiu', 'Arad', 140],\n  ['Sibiu', 'Fagaras', 99],\n  ['Sibiu', 'Rimnicu Vilcea', 80],\n  ['Fagaras', 'Bucharest', 211],\n  ['Bucharest', 'Giurgiu', 90],\n  ['Bucharest', 'Pitesti', 101],\n  ['Pitesti', 'Rimnicu Vilcea', 97],\n  ['Rimnicu Vilcea', 'Craiova', 146],\n  ['Craiova', 'Pitesti', 138],\n  ['Craiova', 'Drobeta', 120],\n  ['Drobeta', 'Mehadia', 75],\n  ['Mehadia', 'Lugoj', 70],\n  ['Lugoj', 'Timisoara', 111],\n  ['Arad', 'Timisoara', 118],\n  ['Bucharest', 'Urziceni', 85],\n  ['Urziceni', 'Vaslui', 142],\n  ['Vaslui', 'Iasi', 92],\n  ['Iasi', 'Neamt', 87],\n  ['Urziceni', 'Hirsova', 98],\n  ['Hirsova', 'Eforie', 86]\n]\n</code></pre> </li> <li> <p>We will define two class, <code>City</code> and <code>Road</code>.</p> </li> <li> <p>An object of class <code>City</code> has the attributes of <code>name</code> (the name of the city), <code>roads</code> (an array of references to the roads connected to the current city), and <code>coordinates</code> (coordinates of the cities).</p> <pre><code>class City:\n  def __init__(self, name):\n    self.name = name\n    self.roads = []\n    self.coordinates = []\n\n  def set_coordinates(self, coordinates):\n    self.coordinates = coordinates\n\n  def add_road(self, road):\n    if road not in self.roads:\n      self.roads.append(road)\n</code></pre> </li> <li> <p>An object of class <code>Road</code> has the attributes of <code>connected_cities</code> (an array of references to the cities connected through this road), <code>cost</code> (the step cost of this road), and <code>pheromone</code> (the pheromone on this road).</p> <pre><code>class Road:\n  def __init__(self, connected_cities, cost, pheromone=0):\n    self.connected_cities = connected_cities\n    self.cost = cost\n    self.pheromone = pheromone\n</code></pre> </li> <li> <p>We will construct the list of <code>City</code> objects and <code>Road</code> objects from the information provided by the question, i.e. information in <code>location_list</code> and <code>step_cost</code>. The following code block should be in the <code>main</code> code block.</p> <pre><code>cities = {}\nfor coord1, coord2, name in location_list:\n  cities[name] = City(name)\n  cities[name].set_coordinates([coord1, coord2])\nroads = []\nfor city1, city2, cost in step_cost:\n  road = Road([cities[city1], cities[city2]], cost)\n  cities[city1].add_road(road)\n  cities[city2].add_road(road)\n  roads.append(road)\n</code></pre> </li> <li> <p>In the <code>main</code> code block, define the <code>origin</code> and <code>destination</code> cities.</p> <pre><code>origin = cities['Arad']\ndestination = cities['Bucharest']\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab5/#initiating-aco-algorithm","title":"Initiating ACO algorithm","text":"<ol> <li> <p>We then define the parameters for ACO, i.e. number of ants, <code>n_ant</code>, pheromone influence constant, <code>alpha</code>, and evaporation rate, <code>rho</code>.</p> <pre><code>n_ant = 10\nalpha = 1\nrho = 0.1\n</code></pre> </li> <li> <p>Add the method <code>set_pheromone</code> to the class <code>Road</code>.      <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(self, pheromone):\n    self.pheromone = pheromone\n</code></pre></p> </li> <li> <p>Set the initial pheromone of each road to 0.01.     <pre><code># in main block\ninitial_pheromone = 0.01\nfor road in roads:\n  road.set_pheromone(initial_pheromone)\n</code></pre></p> </li> <li> <p>Define the class <code>Ant</code>.      <pre><code>class Ant:\n  def __init__(self):\n    self.cities = [] # cities the ant passes through, in sequence\n    self.path = [] # roads the ant uses, in sequence\n</code></pre></p> </li> <li> <p>Initiate <code>n_ants</code> ants.     <pre><code>ants = [Ant() for _ in range(n_ant)]\n</code></pre></p> </li> </ol>"},{"location":"archive/202309/lab5/#identify-path-of-each-ant","title":"Identify path of each ant","text":"<ol> <li> <p>In the <code>Ant</code> class, define a method to identify the path by taking the inputs of the available roads, the origin, the destination, and the pheromone influence constant \u03b1.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(self, origin, destination, alpha):\n    # 1. append origin to the self.cities\n    # 2. if the last city is not destination, search for the next city to go\n    # 3. after getting to the destination, remove the loop within the path, i.e. if there are repeated cities in self.cities, remove the cities and the roads in between the repetition\n</code></pre> </li> <li> <p>Define a method to calculate the path length.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(...):\n    ...\n\n  def get_path_length(self):\n    # calculate path length based on self.path\n    return path_length\n</code></pre> </li> <li> <p>As the path of each ant will be reset every iteration, define a method that reset the <code>path</code> and <code>cities</code>.</p> <pre><code>class Ant:\n  def __init__(...):\n    ...\n\n  def get_path(...):\n    ...\n\n  def get_path_length(...):\n    ...\n\n  def reset(self):\n    self.path = []\n    self.cities = []\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab5/#evaporation","title":"Evaporation","text":"<ol> <li> <p>In the <code>Road</code> class, define a method to evaporate the pheromone by taking the input of evaporation rate \u03c1.</p> <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(...):\n    ...\n\n  def evaporate_pheromone(self, rho):\n    # update the pheromone of the road\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab5/#deposition","title":"Deposition","text":"<ol> <li> <p>In the <code>Road</code> class, define a method to calculate the updated pheromone after pheromone deposition by taking the input of all the ants. We will use the following pheromone deposition formula for ant \\(k\\) on road \\(i\\):</p> \\[\\Delta\\tau_{i,k} = \\frac{1}{L_k}\\] <pre><code>class Road:\n  def __init__(...):\n    ...\n\n  def set_pheromone(...):\n    ...\n\n  def evaporate_pheromone(...):\n    ...\n\n  def deposit_pheromone(self, ants):\n    # 1. search for ants that uses the raod\n    # 2. deposit pheromone using the inversely proportionate relationship between path length and deposited pheromone\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab5/#termination-conditions","title":"Termination conditions","text":"<ol> <li> <p>We will use the following conditions as the termination conditions:</p> <ul> <li>maximum iteration of 200</li> <li>if \u226590% of the ants use the same path</li> </ul> </li> <li> <p>Define a function to calculate the percentage of the most dominant path.</p> <pre><code>def get_percentage_of_dominant_path(ants):\n  ...\n  return percentage\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab5/#loop-until-termination","title":"Loop until termination","text":"<ol> <li> <p>Create a loop to iterate until termination.</p> <pre><code># termination threshold\nmax_iteration = 200\npercentage_of_dominant_path = 0.9\n\niteration = 0\nwhile ...: # termination conditions\n  # loop through all the ants to identify the path of each ant\n  for ant in ants:\n    # reset the path of the ant\n    ant.reset()\n    # identify the path of the ant\n    ant.get_path(origin, destination, alpha)\n  # loop through all roads\n  for road in roads:\n    # evaporate the pheromone on the road\n    road.evaporate_pheromone(rho)\n    # deposit the pheromone\n    road.deposit_pheromone(ants)\n  # increase iteration count\n  iteration += 1\n# after exiting the loop, return the most occurred path as the solution\n...\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab5/#visualisation","title":"Visualisation","text":"<ol> <li> <p>Define the following functions:</p> <pre><code>import matplotlib.pyplot as plt\n...\ndef create_graph(cities):\n  fig = plt.figure()\n  ax = fig.add_subplot(1,1,1)\n  cities_x = [city.coordinates[0] for key, city in cities.items()]\n  cities_y = [city.coordinates[1] for key, city in cities.items()]\n  ax.scatter(cities_x, cities_y)\n  ax.set_aspect(aspect=1.0)\n  return ax\n</code></pre> <pre><code>def draw_pheromone(ax, roads):\n  lines = []\n  for road in roads:\n    from_coord = road.connected_cities[0].coordinates\n    to_coord = road.connected_cities[1].coordinates\n    coord_x = [from_coord[0], to_coord[0]]\n    coord_y = [from_coord[1], to_coord[1]]\n    lines.append(ax.plot(coord_x, coord_y, c='k', linewidth=road.pheromone**2))\n  return lines\n</code></pre> </li> <li> <p>Add the following lines to the <code>main</code> code block just before the <code>while</code> loop (loop until termination).</p> <pre><code>ax = create_graph(cities)\nlines = draw_pheromone(ax, roads)\n</code></pre> </li> <li> <p>Add the following lines to after <code>iteration += 1</code>.</p> <pre><code># visualise\nfor l in lines:\n  del l\nlines = draw_pheromone(ax, roads)\nplt.pause(0.05)\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab5/#evaluate-effect-of-parameters","title":"Evaluate effect of parameters","text":"<ol> <li> <p>Modify the pheromone depositing formula to</p> \\[\\Delta\\tau_{i,k} = \\frac{1}{L_k^{1.5}}\\] <p>What is the effect of this?</p> </li> <li> <p>Modify the pheromone depositing formula to</p> \\[\\Delta\\tau_{i,k} = \\frac{5}{L_k}\\] <p>What is the effect of this?</p> </li> <li> <p>Investigate the effect of number of ants <code>n_ant</code>.</p> </li> <li> <p>Investigate the effect of pheromone influence constant \\(\\alpha\\) <code>alpha</code>.</p> </li> <li> <p>Investigate the effect of evaporation rate \\(\\rho\\) <code>rho</code>.</p> </li> </ol>"},{"location":"archive/202309/lab6/","title":"Lab 6: ANN (Supervised learning)","text":""},{"location":"archive/202309/lab6/#artificial-neural-networks","title":"Artificial neural networks","text":""},{"location":"archive/202309/lab6/#objective","title":"Objective","text":"<ul> <li>to construct an multi-layer perceptron classifier using the scikit-learn Python library</li> </ul>"},{"location":"archive/202309/lab6/#load-data-to-be-learned","title":"Load data to be learned","text":"<p>We will be constructing an artificial neural network and use it to perform prediction.</p> <p>The data we will be using today is the results of a chemical analysis of wines grown in the same region in Italy but derived from three different cultivars.</p> <p>The dataset is available from the scikit-learn library. Therefore we will first import the module. <pre><code>from sklearn import datasets\n</code></pre></p> <p>To load the data,  <pre><code>data = datasets.load_wine()\n</code></pre></p>"},{"location":"archive/202309/lab6/#examine-the-dataset","title":"Examine the dataset","text":"<p>We will use pandas to get more insight into the dataset. Import <code>pandas</code> and construct a data frame from the input and target values.</p> <pre><code>import pandas as pd\nwine = pd.DataFrame(data.data, columns=data.feature_names)\nwine['target'] = data.target\n</code></pre> <p>The <code>describe</code> method of a data frame provides the statistical summary of the dataset.</p> <pre><code>print(wine.describe().transpose())\n</code></pre>"},{"location":"archive/202309/lab6/#split-data-into-training-and-testing-sets","title":"Split data into training and testing sets","text":"<p>scikit-learn library provides a function to split the data into training and testing sets easily. </p> <pre><code>from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(data.data, data.target, train_size=0.8)\n</code></pre> <p>We will split the data into 80% training data and 20% testing data. The first argument will be split into the first two outputs, the second argument the second pair, and so on and so forth.</p>"},{"location":"archive/202309/lab6/#data-preprocessing","title":"Data preprocessing","text":"<p>From Examine the dataset, notice that the range of different features are different. This will cause the training algorithm to be difficult to converge. </p> <p>Now we will use the method of standardisation to normalise the data. scikit-learn provides a built-in class to perform the standardisation, <code>StandardScaler</code>.</p> <pre><code>from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\n</code></pre> <p>We will scale the data based on the training data and then apply the scaler to both the training and testing data.</p> <pre><code>scaler.fit(X_train)\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)\n</code></pre> <p>Examine the training input data with the following code:</p> <pre><code>print(pd.DataFrame(X_train, columns=data.feature_names).describe().transpose())\n</code></pre> <p>Compare this result with the one in Examine the dataset. How are these two datasets different from each other? What did the <code>StandardScaler</code> do to the dataset?</p>"},{"location":"archive/202309/lab6/#construct-the-ann-model","title":"Construct the ANN model","text":"<p>As the target values are classes, i.e. <code>0</code>, <code>1</code>, or <code>2</code>, we need a classifier to perform the classification. </p> <pre><code>from sklearn.neural_network import MLPClassifier\n</code></pre> <p>We will construct a feedforward neural network with 1 hidden layer of 2 neuron and maximum iteration of 1000.</p> <pre><code>mlp = MLPClassifier(hidden_layer_sizes=(2), max_iter=1000)\n</code></pre>"},{"location":"archive/202309/lab6/#train-the-model","title":"Train the model","text":"<p>The model can be trained using the <code>fit</code> method of the classifier. </p> <pre><code>mlp.fit(X_train, y_train)\n</code></pre>"},{"location":"archive/202309/lab6/#predictions","title":"Predictions","text":"<p>The model is now trained. We can use the fitted (trained) model to predict the output of the testing data.</p> <pre><code>predictions = mlp.predict(X_test)\n</code></pre>"},{"location":"archive/202309/lab6/#evaluation","title":"Evaluation","text":"<p>With the prediction results, we can evaluate the performance of the fitted model. scikit-learn library provides some built-in metrics such as confusion matrix and classification report.</p> <pre><code>from sklearn.metrics import confusion_matrix, classification_report\n</code></pre> <p>confusion matrix <pre><code>print(confusion_matrix(y_test, predictions))\n</code></pre></p> <p>classification report <pre><code>print(classification_report(y_test, predictions))\n</code></pre></p> <p>What information is provided by the confusion matrix and the classification report?</p>"},{"location":"archive/202309/lab6/#parameters-of-the-fitted-model","title":"Parameters of the fitted model","text":"<p>The parameters of the fitted model (<code>mlp</code>) can be access through its public attributes:</p> attributes definition <code>.coefs_</code> weight matrix <code>.intercepts_</code> bias (threshold) vector <code>.n_iter_</code> number of iterations the solver has ran <code>.n_layers_</code> number of layers <code>.n_outputs_</code> number of outputs"},{"location":"archive/202309/lab6/#visualisation-the-neural-network","title":"Visualisation the neural network","text":"<p>Copy the following code for the function <code>visualise</code> to the beginning of the script.</p> <pre><code>import matplotlib.pyplot as plt\n\ndef visualise(mlp):\n  # get number of neurons in each layer\n  n_neurons = [len(layer) for layer in mlp.coefs_]\n  n_neurons.append(mlp.n_outputs_)\n\n  # calculate the coordinates of each neuron on the graph\n  y_range = [0, max(n_neurons)]\n  x_range = [0, len(n_neurons)]\n  loc_neurons = [[[l, (n+1)*(y_range[1]/(layer+1))] for n in range(layer)] for l,layer in enumerate(n_neurons)]\n  x_neurons = [x for layer in loc_neurons for x,y in layer]\n  y_neurons = [y for layer in loc_neurons for x,y in layer]\n\n  # identify the range of weights\n  weight_range = [min([layer.min() for layer in mlp.coefs_]), max([layer.max() for layer in mlp.coefs_])]\n\n  # prepare the figure\n  fig = plt.figure()\n  ax = fig.add_subplot(1,1,1)\n  # draw the neurons\n  ax.scatter(x_neurons, y_neurons, s=100, zorder=5)\n  # draw the connections with line width corresponds to the weight of the connection\n  for l,layer in enumerate(mlp.coefs_):\n    for i,neuron in enumerate(layer):\n      for j,w in enumerate(neuron):\n        ax.plot([loc_neurons[l][i][0], loc_neurons[l+1][j][0]], [loc_neurons[l][i][1], loc_neurons[l+1][j][1]], 'white', linewidth=((w-weight_range[0])/(weight_range[1]-weight_range[0])*5+0.2)*1.2)\n        ax.plot([loc_neurons[l][i][0], loc_neurons[l+1][j][0]], [loc_neurons[l][i][1], loc_neurons[l+1][j][1]], 'grey', linewidth=(w-weight_range[0])/(weight_range[1]-weight_range[0])*5+0.2)\n</code></pre> <p>To use this function to visualise the neural network, use the following line after the predictions.</p> <pre><code>visualise(mlp)\n</code></pre>"},{"location":"archive/202309/lab6/#compare-the-weights-before-and-after-the-training","title":"Compare the weights before and after the training","text":"<p>At initiation, the weights are not assigned. Therefore we need to train the model once before we can visualise the neural network. We can train the model once using the <code>.partial_fit</code> method. Put the following lines right after the initiation of <code>mlp</code>.</p> <pre><code>mlp.partial_fit(X_train, y_train, np.unique(data.target))\nvisualise(mlp)\n</code></pre> <p>Compare the weights of the two visualisations.</p>"},{"location":"archive/202309/lab6/#effect-of-parameters","title":"Effect of parameters","text":"<p>Investigate the effect of the following parameters on the performance of the neural network and the number of iterations to achieve convergence.</p> <ul> <li>number of hidden layers</li> <li>number of neurons in hidden layers</li> <li>splitting ratio of training and testing sets</li> </ul>"},{"location":"archive/202309/lab7/","title":"Lab 7: ANN (Hyperplane)","text":""},{"location":"archive/202309/lab7/#artificial-neural-networks","title":"Artificial neural networks","text":""},{"location":"archive/202309/lab7/#objective","title":"Objective","text":"<ul> <li>to visualise the hyperplanes of a neural network configuration for better understanding</li> </ul>"},{"location":"archive/202309/lab7/#data-preparation","title":"Data preparation","text":"<p>We will use the iris data for the training in this lab.</p> <pre><code>from sklearn import datasets\niris = datasets.load_iris()\n</code></pre> <p>We will start with using just two input features. <pre><code>X = [[d[1],d[2]] for d in iris.data]\nnames = [iris.target_names[1],iris.target_names[2]]\nY = iris.target\n</code></pre></p>"},{"location":"archive/202309/lab7/#setup-the-first-configuration-for-neural-network","title":"Setup the first configuration for neural network","text":""},{"location":"archive/202309/lab7/#data-preprocessing","title":"Data preprocessing","text":"<ol> <li> <p>Training and testing sets split</p> <pre><code>from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, Y, train_size=0.8)\n</code></pre> </li> <li> <p>Scale the input data based on the training input data</p> <pre><code>from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nscaler.fit(X_train)\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab7/#construct-and-train-the-ann-model","title":"Construct and train the ANN model","text":"<ol> <li> <p>Construct the model</p> <pre><code>from sklearn.neural_network import MLPClassifier\nmlp = MLPClassifier(hidden_layer_sizes=(2), max_iter=1000)\n</code></pre> </li> <li> <p>Train the model</p> <pre><code>mlp.fit(X_train, y_train)\n</code></pre> </li> </ol>"},{"location":"archive/202309/lab7/#visualise-the-classification-of-a-fitted-model","title":"Visualise the classification of a fitted model","text":""},{"location":"archive/202309/lab7/#prepare-the-figure-and-axis","title":"Prepare the figure and axis","text":"<pre><code>import matplotlib.pyplot as plt\nfig = plt.figure()\nax = fig.add_subplot(1,1,1)\n</code></pre>"},{"location":"archive/202309/lab7/#visualisation-function","title":"Visualisation function","text":"<ol> <li> <p>Download the vis.py and save it to the same folder as your script.</p> </li> <li> <p>Import all functions under the namespace of <code>vis</code> <pre><code>import vis\n</code></pre></p> </li> </ol>"},{"location":"archive/202309/lab7/#visualise-the-result","title":"Visualise the result","text":"<p>Use the following code to visualise the decision area of the model. <pre><code>vis.vis2d(ax, mlp, X_train, y_train, X_test, y_test)\n</code></pre></p>"},{"location":"archive/202309/lab7/#setup-the-second-third-and-more-neural-network-configurations","title":"Setup the second, third, and more neural network configurations","text":"<p>We will investigate the effect of using different activation functions on the hyperplane.</p> <p>The activation functions that are available for <code>MLPClassifier</code> are <code>identity</code>, <code>logistic</code>, <code>tanh</code>, and <code>relu</code> (default). They are explained in the documentation.</p> <p>We can use a <code>for</code>-loop to construct and train the neural network model with different configurations. The same datasets from previous sections are used.</p> <pre><code>activation_functions = ['identity', 'logistic', 'tanh', 'relu']\nfig = plt.figure()\nfor i, actfcn in enumerate(activation_functions):\n  mlp = MLPClassifier(hidden_layer_sizes=(3), activation=actfcn, max_iter=1000)\n  mlp.fit(X_train, y_train)\n  ax = fig.add_subplot(1, len(activation_functions), i+1)\n  ax.set_title(actfcn)\n  vis.vis2d(ax, mlp, X_train, y_train, X_test, y_test)\n</code></pre> <p>Apart from the activation functions, let's compare the results of having different number of hidden layers.</p> <pre><code>activation_functions = ['identity', 'logistic', 'tanh', 'relu']\nhidden_layers = [(3), (3,3), (3,3,3)]\nfig = plt.figure()\nfor i,actfcn in enumerate(activation_functions):\n  for j,hlyr in enumerate(hidden_layers):\n    mlp = MLPClassifier(hidden_layer_sizes=hlyr, activation=actfcn, max_iter=1000)\n    mlp.fit(X_train, y_train)\n    ax = fig.add_subplot(len(hidden_layers), len(activation_functions), j*len(activation_functions)+i+1)\n    ax.set_title('{},{},{}'.format(actfcn,str(hlyr),round(mlp.score(X_test,y_test),2)))\n    vis.vis2d(ax, mlp, X_train, y_train, X_test, y_test)\n    ax.set_xticks([])\n    ax.set_yticks([])\n</code></pre> <p><code>mlp.score(X_test, y_test)</code> gives the prediction accuracy of the model on <code>X_test</code> compared against <code>y_test</code>.</p>"},{"location":"archive/202309/lab7/#consider-more-input-features","title":"Consider more input features","text":"<p>We will now use all the input features instead of two. To prepare the data, <pre><code>X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, train_size=0.8)\nscaler.fit(X_train)\nX_train = scaler.transform(X_train)\nX_test = scaler.transform(X_test)\n</code></pre></p>"},{"location":"archive/202309/lab7/#construct-and-train-the-model","title":"Construct and train the model","text":"<pre><code>mlp = MLPClassifier(hidden_layer_sizes=(3), max_iter=10000)\nmlp.fit(X_train, y_train)\n</code></pre>"},{"location":"archive/202309/lab7/#visualise-decision-area-with-more-input-features","title":"Visualise decision area with more input features","text":"<p>We will be using parallel coordinates to display data with more than 2 input features. The following is not a complete parallel coordinates plot but a partial one.</p> <pre><code>fig = plt.figure()\naxes = vis.vis3d(fig, mlp, X_train, y_train, X_test, y_test)\nfor i,a in enumerate(axes):\n  a.set_title(iris.target_names[i])\n  a.set_xticklabels([])\n  a.get_yaxis().set_visible(False)\naxes[-1].set_xticklabels(iris.feature_names)\n</code></pre> <p>Is there other alternative to display data with more than 2 input features?</p>"},{"location":"archive/202309/lab7/#additional","title":"Additional","text":"<p>There is a tensorflow playground which tries to visualise the training process of a neural network. It's similar to what we did in this lab.</p>"}]}